import {
  css_box_model_esm_exports,
  es2015_exports,
  es2015_exports2,
  es2015_exports3,
  init_css_box_model_esm,
  init_es2015,
  init_es20152,
  init_es20153,
  init_is_prop_valid_browser_esm,
  init_lib,
  is_prop_valid_browser_esm_exports,
  lib_exports,
  require_copy_to_clipboard,
  require_lodash
} from "./chunk-KNWS3ENA.js";
import "./chunk-5B5HXILZ.js";
import {
  require_react_fast_compare
} from "./chunk-MVHRZIAK.js";
import {
  require_jsx_runtime
} from "./chunk-2KX3DJT3.js";
import {
  require_react_dom
} from "./chunk-IAJVP4OK.js";
import {
  require_hoist_non_react_statics_cjs
} from "./chunk-WCRGSUFM.js";
import "./chunk-LAYEANMH.js";
import "./chunk-2QINEMXG.js";
import {
  require_react
} from "./chunk-OYMDD5DX.js";
import {
  init_public_api,
  public_api_exports
} from "./chunk-KWDUSFWG.js";
import "./chunk-IUBHD4U4.js";
import "./chunk-76T6WHU2.js";
import "./chunk-QPQOIBEH.js";
import "./chunk-76U3Z6EO.js";
import "./chunk-XOVEFRVR.js";
import "./chunk-2DI76JXX.js";
import "./chunk-37VBO4G4.js";
import "./chunk-F7GRIZ6Y.js";
import "./chunk-UIQ4UU2S.js";
import "./chunk-AZLJP73L.js";
import "./chunk-7SOW5ZNJ.js";
import "./chunk-EU3NVPBZ.js";
import "./chunk-FQAGO6O4.js";
import "./chunk-JXC5TS4Y.js";
import "./chunk-Y5OPPFNQ.js";
import "./chunk-7IX35PRV.js";
import "./chunk-Q7QQNGZS.js";
import "./chunk-WI74YQJT.js";
import "./chunk-ZPUMN62S.js";
import "./chunk-IPOUH34V.js";
import {
  __commonJS,
  __toCommonJS
} from "./chunk-S5KM4IGW.js";

// ../../node_modules/@chakra-ui/react-use-safe-layout-effect/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/@chakra-ui/react-use-safe-layout-effect/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      useSafeLayoutEffect: () => useSafeLayoutEffect
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react = require_react();
    var useSafeLayoutEffect = Boolean(globalThis == null ? void 0 : globalThis.document) ? import_react.useLayoutEffect : import_react.useEffect;
  }
});

// ../../node_modules/@chakra-ui/color-mode/dist/index.js
var require_dist2 = __commonJS({
  "../../node_modules/@chakra-ui/color-mode/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      ColorModeContext: () => ColorModeContext,
      ColorModeProvider: () => ColorModeProvider,
      ColorModeScript: () => ColorModeScript,
      DarkMode: () => DarkMode,
      LightMode: () => LightMode,
      cookieStorageManager: () => cookieStorageManager,
      cookieStorageManagerSSR: () => cookieStorageManagerSSR,
      createCookieStorageManager: () => createCookieStorageManager,
      createLocalStorageManager: () => createLocalStorageManager,
      getScriptSrc: () => getScriptSrc,
      localStorageManager: () => localStorageManager,
      useColorMode: () => useColorMode,
      useColorModeValue: () => useColorModeValue
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react_use_safe_layout_effect = require_dist();
    var import_react2 = require_react();
    var import_react = require_react();
    var ColorModeContext = (0, import_react.createContext)({});
    ColorModeContext.displayName = "ColorModeContext";
    function useColorMode() {
      const context = (0, import_react.useContext)(ColorModeContext);
      if (context === void 0) {
        throw new Error("useColorMode must be used within a ColorModeProvider");
      }
      return context;
    }
    function useColorModeValue(light, dark) {
      const { colorMode } = useColorMode();
      return colorMode === "dark" ? dark : light;
    }
    var classNames = {
      light: "chakra-ui-light",
      dark: "chakra-ui-dark"
    };
    function getColorModeUtils(options = {}) {
      const { preventTransition = true } = options;
      const utils = {
        setDataset: (value) => {
          const cleanup = preventTransition ? utils.preventTransition() : void 0;
          document.documentElement.dataset.theme = value;
          document.documentElement.style.colorScheme = value;
          cleanup == null ? void 0 : cleanup();
        },
        setClassName(dark) {
          document.body.classList.add(dark ? classNames.dark : classNames.light);
          document.body.classList.remove(dark ? classNames.light : classNames.dark);
        },
        query() {
          return window.matchMedia("(prefers-color-scheme: dark)");
        },
        getSystemTheme(fallback) {
          var _a;
          const dark = (_a = utils.query().matches) != null ? _a : fallback === "dark";
          return dark ? "dark" : "light";
        },
        addListener(fn) {
          const mql = utils.query();
          const listener = (e) => {
            fn(e.matches ? "dark" : "light");
          };
          if (typeof mql.addListener === "function")
            mql.addListener(listener);
          else
            mql.addEventListener("change", listener);
          return () => {
            if (typeof mql.removeListener === "function")
              mql.removeListener(listener);
            else
              mql.removeEventListener("change", listener);
          };
        },
        preventTransition() {
          const css = document.createElement("style");
          css.appendChild(
            document.createTextNode(
              `*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}`
            )
          );
          document.head.appendChild(css);
          return () => {
            ;
            (() => window.getComputedStyle(document.body))();
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                document.head.removeChild(css);
              });
            });
          };
        }
      };
      return utils;
    }
    var STORAGE_KEY = "chakra-ui-color-mode";
    function createLocalStorageManager(key) {
      return {
        ssr: false,
        type: "localStorage",
        get(init) {
          if (!(globalThis == null ? void 0 : globalThis.document))
            return init;
          let value;
          try {
            value = localStorage.getItem(key) || init;
          } catch (e) {
          }
          return value || init;
        },
        set(value) {
          try {
            localStorage.setItem(key, value);
          } catch (e) {
          }
        }
      };
    }
    var localStorageManager = createLocalStorageManager(STORAGE_KEY);
    function parseCookie(cookie, key) {
      const match = cookie.match(new RegExp(`(^| )${key}=([^;]+)`));
      return match == null ? void 0 : match[2];
    }
    function createCookieStorageManager(key, cookie) {
      return {
        ssr: !!cookie,
        type: "cookie",
        get(init) {
          if (cookie)
            return parseCookie(cookie, key);
          if (!(globalThis == null ? void 0 : globalThis.document))
            return init;
          return parseCookie(document.cookie, key) || init;
        },
        set(value) {
          document.cookie = `${key}=${value}; max-age=31536000; path=/`;
        }
      };
    }
    var cookieStorageManager = createCookieStorageManager(STORAGE_KEY);
    var cookieStorageManagerSSR = (cookie) => createCookieStorageManager(STORAGE_KEY, cookie);
    var import_jsx_runtime = require_jsx_runtime();
    var noop = () => {
    };
    function getTheme(manager, fallback) {
      return manager.type === "cookie" && manager.ssr ? manager.get(fallback) : fallback;
    }
    function ColorModeProvider(props) {
      const {
        value,
        children,
        options: {
          useSystemColorMode,
          initialColorMode,
          disableTransitionOnChange
        } = {},
        colorModeManager = localStorageManager
      } = props;
      const defaultColorMode = initialColorMode === "dark" ? "dark" : "light";
      const [colorMode, rawSetColorMode] = (0, import_react2.useState)(
        () => getTheme(colorModeManager, defaultColorMode)
      );
      const [resolvedColorMode, setResolvedColorMode] = (0, import_react2.useState)(
        () => getTheme(colorModeManager)
      );
      const { getSystemTheme, setClassName, setDataset, addListener } = (0, import_react2.useMemo)(
        () => getColorModeUtils({ preventTransition: disableTransitionOnChange }),
        [disableTransitionOnChange]
      );
      const resolvedValue = initialColorMode === "system" && !colorMode ? resolvedColorMode : colorMode;
      const setColorMode = (0, import_react2.useCallback)(
        (value2) => {
          const resolved = value2 === "system" ? getSystemTheme() : value2;
          rawSetColorMode(resolved);
          setClassName(resolved === "dark");
          setDataset(resolved);
          colorModeManager.set(resolved);
        },
        [colorModeManager, getSystemTheme, setClassName, setDataset]
      );
      (0, import_react_use_safe_layout_effect.useSafeLayoutEffect)(() => {
        if (initialColorMode === "system") {
          setResolvedColorMode(getSystemTheme());
        }
      }, []);
      (0, import_react2.useEffect)(() => {
        const managerValue = colorModeManager.get();
        if (managerValue) {
          setColorMode(managerValue);
          return;
        }
        if (initialColorMode === "system") {
          setColorMode("system");
          return;
        }
        setColorMode(defaultColorMode);
      }, [colorModeManager, defaultColorMode, initialColorMode, setColorMode]);
      const toggleColorMode = (0, import_react2.useCallback)(() => {
        setColorMode(resolvedValue === "dark" ? "light" : "dark");
      }, [resolvedValue, setColorMode]);
      (0, import_react2.useEffect)(() => {
        if (!useSystemColorMode)
          return;
        return addListener(setColorMode);
      }, [useSystemColorMode, addListener, setColorMode]);
      const context = (0, import_react2.useMemo)(
        () => ({
          colorMode: value != null ? value : resolvedValue,
          toggleColorMode: value ? noop : toggleColorMode,
          setColorMode: value ? noop : setColorMode,
          forced: value !== void 0
        }),
        [resolvedValue, toggleColorMode, setColorMode, value]
      );
      return (0, import_jsx_runtime.jsx)(ColorModeContext.Provider, { value: context, children });
    }
    ColorModeProvider.displayName = "ColorModeProvider";
    function DarkMode(props) {
      const context = (0, import_react2.useMemo)(
        () => ({
          colorMode: "dark",
          toggleColorMode: noop,
          setColorMode: noop,
          forced: true
        }),
        []
      );
      return (0, import_jsx_runtime.jsx)(ColorModeContext.Provider, { value: context, ...props });
    }
    DarkMode.displayName = "DarkMode";
    function LightMode(props) {
      const context = (0, import_react2.useMemo)(
        () => ({
          colorMode: "light",
          toggleColorMode: noop,
          setColorMode: noop,
          forced: true
        }),
        []
      );
      return (0, import_jsx_runtime.jsx)(ColorModeContext.Provider, { value: context, ...props });
    }
    LightMode.displayName = "LightMode";
    var import_jsx_runtime2 = require_jsx_runtime();
    var VALID_VALUES = /* @__PURE__ */ new Set(["dark", "light", "system"]);
    function normalize(initialColorMode) {
      let value = initialColorMode;
      if (!VALID_VALUES.has(value))
        value = "light";
      return value;
    }
    function getScriptSrc(props = {}) {
      const {
        initialColorMode = "light",
        type = "localStorage",
        storageKey: key = "chakra-ui-color-mode"
      } = props;
      const init = normalize(initialColorMode);
      const isCookie = type === "cookie";
      const cookieScript = `(function(){try{var a=function(o){var l="(prefers-color-scheme: dark)",v=window.matchMedia(l).matches?"dark":"light",e=o==="system"?v:o,d=document.documentElement,m=document.body,i="chakra-ui-light",n="chakra-ui-dark",s=e==="dark";return m.classList.add(s?n:i),m.classList.remove(s?i:n),d.style.colorScheme=e,d.dataset.theme=e,e},u=a,h="${init}",r="${key}",t=document.cookie.match(new RegExp("(^| )".concat(r,"=([^;]+)"))),c=t?t[2]:null;c?a(c):document.cookie="".concat(r,"=").concat(a(h),"; max-age=31536000; path=/")}catch(a){}})();
  `;
      const localStorageScript = `(function(){try{var a=function(c){var v="(prefers-color-scheme: dark)",h=window.matchMedia(v).matches?"dark":"light",r=c==="system"?h:c,o=document.documentElement,s=document.body,l="chakra-ui-light",d="chakra-ui-dark",i=r==="dark";return s.classList.add(i?d:l),s.classList.remove(i?l:d),o.style.colorScheme=r,o.dataset.theme=r,r},n=a,m="${init}",e="${key}",t=localStorage.getItem(e);t?a(t):localStorage.setItem(e,a(m))}catch(a){}})();
  `;
      const fn = isCookie ? cookieScript : localStorageScript;
      return `!${fn}`.trim();
    }
    function ColorModeScript(props = {}) {
      const { nonce } = props;
      return (0, import_jsx_runtime2.jsx)(
        "script",
        {
          id: "chakra-script",
          nonce,
          dangerouslySetInnerHTML: { __html: getScriptSrc(props) }
        }
      );
    }
  }
});

// ../../node_modules/@chakra-ui/shared-utils/dist/index.js
var require_dist3 = __commonJS({
  "../../node_modules/@chakra-ui/shared-utils/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      ariaAttr: () => ariaAttr,
      callAll: () => callAll,
      callAllHandlers: () => callAllHandlers,
      cx: () => cx,
      dataAttr: () => dataAttr,
      isObject: () => isObject,
      runIfFn: () => runIfFn,
      warn: () => warn
    });
    module.exports = __toCommonJS2(src_exports);
    var cx = (...classNames) => classNames.filter(Boolean).join(" ");
    function isDev() {
      return true;
    }
    function isObject(value) {
      const type = typeof value;
      return value != null && (type === "object" || type === "function") && !Array.isArray(value);
    }
    var warn = (options) => {
      const { condition, message } = options;
      if (condition && isDev()) {
        console.warn(message);
      }
    };
    function runIfFn(valueOrFn, ...args) {
      return isFunction(valueOrFn) ? valueOrFn(...args) : valueOrFn;
    }
    var isFunction = (value) => typeof value === "function";
    var dataAttr = (condition) => condition ? "" : void 0;
    var ariaAttr = (condition) => condition ? true : void 0;
    function callAllHandlers(...fns) {
      return function func(event) {
        fns.some((fn) => {
          fn == null ? void 0 : fn(event);
          return event == null ? void 0 : event.defaultPrevented;
        });
      };
    }
    function callAll(...fns) {
      return function mergedFn(arg) {
        fns.forEach((fn) => {
          fn == null ? void 0 : fn(arg);
        });
      };
    }
  }
});

// ../../node_modules/@chakra-ui/styled-system/dist/index.js
var require_dist4 = __commonJS({
  "../../node_modules/@chakra-ui/styled-system/dist/index.js"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      addPrefix: () => addPrefix,
      background: () => background,
      border: () => border,
      calc: () => calc,
      color: () => color,
      createMultiStyleConfigHelpers: () => createMultiStyleConfigHelpers,
      css: () => css,
      cssVar: () => cssVar,
      defineCssVars: () => defineCssVars,
      defineStyle: () => defineStyle,
      defineStyleConfig: () => defineStyleConfig,
      effect: () => effect,
      filter: () => filter,
      flattenTokens: () => flattenTokens,
      flexbox: () => flexbox,
      getCSSVar: () => getCSSVar,
      getCss: () => getCss,
      grid: () => grid,
      interactivity: () => interactivity,
      isStyleProp: () => isStyleProp,
      layout: () => layout,
      layoutPropNames: () => layoutPropNames,
      list: () => list,
      omitThemingProps: () => omitThemingProps,
      others: () => others,
      position: () => position,
      propNames: () => propNames,
      pseudoPropNames: () => pseudoPropNames,
      pseudoSelectors: () => pseudoSelectors,
      resolveStyleConfig: () => resolveStyleConfig,
      ring: () => ring,
      scroll: () => scroll,
      space: () => space,
      systemProps: () => systemProps,
      textDecoration: () => textDecoration,
      toCSSVar: () => toCSSVar,
      toVarDefinition: () => toVarDefinition,
      toVarReference: () => toVarReference,
      tokenToCSSVar: () => tokenToCSSVar,
      transform: () => transform,
      transition: () => transition,
      typography: () => typography
    });
    module.exports = __toCommonJS2(src_exports);
    var import_shared_utils = require_dist3();
    var isImportant = (value) => /!(important)?$/.test(value);
    var withoutImportant = (value) => typeof value === "string" ? value.replace(/!(important)?$/, "").trim() : value;
    var tokenToCSSVar = (scale, value) => (theme) => {
      const valueStr = String(value);
      const important = isImportant(valueStr);
      const valueWithoutImportant = withoutImportant(valueStr);
      const key = scale ? `${scale}.${valueWithoutImportant}` : valueWithoutImportant;
      let transformed = (0, import_shared_utils.isObject)(theme.__cssMap) && key in theme.__cssMap ? theme.__cssMap[key].varRef : value;
      transformed = withoutImportant(transformed);
      return important ? `${transformed} !important` : transformed;
    };
    function createTransform(options) {
      const { scale, transform: transform2, compose } = options;
      const fn = (value, theme) => {
        var _a;
        const _value = tokenToCSSVar(scale, value)(theme);
        let result = (_a = transform2 == null ? void 0 : transform2(_value, theme)) != null ? _a : _value;
        if (compose) {
          result = compose(result, theme);
        }
        return result;
      };
      return fn;
    }
    var pipe = (...fns) => (v) => fns.reduce((a, b) => b(a), v);
    function toConfig(scale, transform2) {
      return (property) => {
        const result = { property, scale };
        result.transform = createTransform({
          scale,
          transform: transform2
        });
        return result;
      };
    }
    var getRtl = ({ rtl, ltr }) => (theme) => theme.direction === "rtl" ? rtl : ltr;
    function logical(options) {
      const { property, scale, transform: transform2 } = options;
      return {
        scale,
        property: getRtl(property),
        transform: scale ? createTransform({
          scale,
          compose: transform2
        }) : transform2
      };
    }
    var transformTemplate = [
      "rotate(var(--chakra-rotate, 0))",
      "scaleX(var(--chakra-scale-x, 1))",
      "scaleY(var(--chakra-scale-y, 1))",
      "skewX(var(--chakra-skew-x, 0))",
      "skewY(var(--chakra-skew-y, 0))"
    ];
    function getTransformTemplate() {
      return [
        "translateX(var(--chakra-translate-x, 0))",
        "translateY(var(--chakra-translate-y, 0))",
        ...transformTemplate
      ].join(" ");
    }
    function getTransformGpuTemplate() {
      return [
        "translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)",
        ...transformTemplate
      ].join(" ");
    }
    var filterTemplate = {
      "--chakra-blur": "var(--chakra-empty,/*!*/ /*!*/)",
      "--chakra-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
      "--chakra-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
      "--chakra-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
      "--chakra-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
      "--chakra-invert": "var(--chakra-empty,/*!*/ /*!*/)",
      "--chakra-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
      "--chakra-sepia": "var(--chakra-empty,/*!*/ /*!*/)",
      "--chakra-drop-shadow": "var(--chakra-empty,/*!*/ /*!*/)",
      filter: [
        "var(--chakra-blur)",
        "var(--chakra-brightness)",
        "var(--chakra-contrast)",
        "var(--chakra-grayscale)",
        "var(--chakra-hue-rotate)",
        "var(--chakra-invert)",
        "var(--chakra-saturate)",
        "var(--chakra-sepia)",
        "var(--chakra-drop-shadow)"
      ].join(" ")
    };
    var backdropFilterTemplate = {
      backdropFilter: [
        "var(--chakra-backdrop-blur)",
        "var(--chakra-backdrop-brightness)",
        "var(--chakra-backdrop-contrast)",
        "var(--chakra-backdrop-grayscale)",
        "var(--chakra-backdrop-hue-rotate)",
        "var(--chakra-backdrop-invert)",
        "var(--chakra-backdrop-opacity)",
        "var(--chakra-backdrop-saturate)",
        "var(--chakra-backdrop-sepia)"
      ].join(" "),
      "--chakra-backdrop-blur": "var(--chakra-empty,/*!*/ /*!*/)",
      "--chakra-backdrop-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
      "--chakra-backdrop-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
      "--chakra-backdrop-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
      "--chakra-backdrop-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
      "--chakra-backdrop-invert": "var(--chakra-empty,/*!*/ /*!*/)",
      "--chakra-backdrop-opacity": "var(--chakra-empty,/*!*/ /*!*/)",
      "--chakra-backdrop-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
      "--chakra-backdrop-sepia": "var(--chakra-empty,/*!*/ /*!*/)"
    };
    function getRingTemplate(value) {
      return {
        "--chakra-ring-offset-shadow": `var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)`,
        "--chakra-ring-shadow": `var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)`,
        "--chakra-ring-width": value,
        boxShadow: [
          `var(--chakra-ring-offset-shadow)`,
          `var(--chakra-ring-shadow)`,
          `var(--chakra-shadow, 0 0 #0000)`
        ].join(", ")
      };
    }
    var flexDirectionTemplate = {
      "row-reverse": {
        space: "--chakra-space-x-reverse",
        divide: "--chakra-divide-x-reverse"
      },
      "column-reverse": {
        space: "--chakra-space-y-reverse",
        divide: "--chakra-divide-y-reverse"
      }
    };
    var directionMap = {
      "to-t": "to top",
      "to-tr": "to top right",
      "to-r": "to right",
      "to-br": "to bottom right",
      "to-b": "to bottom",
      "to-bl": "to bottom left",
      "to-l": "to left",
      "to-tl": "to top left"
    };
    var valueSet = new Set(Object.values(directionMap));
    var globalSet = /* @__PURE__ */ new Set([
      "none",
      "-moz-initial",
      "inherit",
      "initial",
      "revert",
      "unset"
    ]);
    var trimSpace = (str) => str.trim();
    function parseGradient(value, theme) {
      if (value == null || globalSet.has(value))
        return value;
      const prevent = isCSSFunction(value) || globalSet.has(value);
      if (!prevent)
        return `url('${value}')`;
      const regex = /(^[a-z-A-Z]+)\((.*)\)/g;
      const results = regex.exec(value);
      const type = results == null ? void 0 : results[1];
      const values = results == null ? void 0 : results[2];
      if (!type || !values)
        return value;
      const _type = type.includes("-gradient") ? type : `${type}-gradient`;
      const [maybeDirection, ...stops] = values.split(",").map(trimSpace).filter(Boolean);
      if ((stops == null ? void 0 : stops.length) === 0)
        return value;
      const direction = maybeDirection in directionMap ? directionMap[maybeDirection] : maybeDirection;
      stops.unshift(direction);
      const _values = stops.map((stop) => {
        if (valueSet.has(stop))
          return stop;
        const firstStop = stop.indexOf(" ");
        const [_color, _stop] = firstStop !== -1 ? [stop.substr(0, firstStop), stop.substr(firstStop + 1)] : [stop];
        const _stopOrFunc = isCSSFunction(_stop) ? _stop : _stop && _stop.split(" ");
        const key = `colors.${_color}`;
        const color2 = key in theme.__cssMap ? theme.__cssMap[key].varRef : _color;
        return _stopOrFunc ? [
          color2,
          ...Array.isArray(_stopOrFunc) ? _stopOrFunc : [_stopOrFunc]
        ].join(" ") : color2;
      });
      return `${_type}(${_values.join(", ")})`;
    }
    var isCSSFunction = (value) => {
      return typeof value === "string" && value.includes("(") && value.includes(")");
    };
    var gradientTransform = (value, theme) => parseGradient(value, theme != null ? theme : {});
    function isCssVar(value) {
      return /^var\(--.+\)$/.test(value);
    }
    var analyzeCSSValue = (value) => {
      const num = parseFloat(value.toString());
      const unit = value.toString().replace(String(num), "");
      return { unitless: !unit, value: num, unit };
    };
    var wrap = (str) => (value) => `${str}(${value})`;
    var transformFunctions = {
      filter(value) {
        return value !== "auto" ? value : filterTemplate;
      },
      backdropFilter(value) {
        return value !== "auto" ? value : backdropFilterTemplate;
      },
      ring(value) {
        return getRingTemplate(transformFunctions.px(value));
      },
      bgClip(value) {
        return value === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: value };
      },
      transform(value) {
        if (value === "auto")
          return getTransformTemplate();
        if (value === "auto-gpu")
          return getTransformGpuTemplate();
        return value;
      },
      vh(value) {
        return value === "$100vh" ? "var(--chakra-vh)" : value;
      },
      px(value) {
        if (value == null)
          return value;
        const { unitless } = analyzeCSSValue(value);
        return unitless || typeof value === "number" ? `${value}px` : value;
      },
      fraction(value) {
        return !(typeof value === "number") || value > 1 ? value : `${value * 100}%`;
      },
      float(value, theme) {
        const map = { left: "right", right: "left" };
        return theme.direction === "rtl" ? map[value] : value;
      },
      degree(value) {
        if (isCssVar(value) || value == null)
          return value;
        const unitless = typeof value === "string" && !value.endsWith("deg");
        return typeof value === "number" || unitless ? `${value}deg` : value;
      },
      gradient: gradientTransform,
      blur: wrap("blur"),
      opacity: wrap("opacity"),
      brightness: wrap("brightness"),
      contrast: wrap("contrast"),
      dropShadow: wrap("drop-shadow"),
      grayscale: wrap("grayscale"),
      hueRotate: wrap("hue-rotate"),
      invert: wrap("invert"),
      saturate: wrap("saturate"),
      sepia: wrap("sepia"),
      bgImage(value) {
        if (value == null)
          return value;
        const prevent = isCSSFunction(value) || globalSet.has(value);
        return !prevent ? `url(${value})` : value;
      },
      outline(value) {
        const isNoneOrZero = String(value) === "0" || String(value) === "none";
        return value !== null && isNoneOrZero ? { outline: "2px solid transparent", outlineOffset: "2px" } : { outline: value };
      },
      flexDirection(value) {
        var _a;
        const { space: space2, divide: divide2 } = (_a = flexDirectionTemplate[value]) != null ? _a : {};
        const result = { flexDirection: value };
        if (space2)
          result[space2] = 1;
        if (divide2)
          result[divide2] = 1;
        return result;
      }
    };
    var t = {
      borderWidths: toConfig("borderWidths"),
      borderStyles: toConfig("borderStyles"),
      colors: toConfig("colors"),
      borders: toConfig("borders"),
      gradients: toConfig("gradients", transformFunctions.gradient),
      radii: toConfig("radii", transformFunctions.px),
      space: toConfig("space", pipe(transformFunctions.vh, transformFunctions.px)),
      spaceT: toConfig("space", pipe(transformFunctions.vh, transformFunctions.px)),
      degreeT(property) {
        return { property, transform: transformFunctions.degree };
      },
      prop(property, scale, transform2) {
        return {
          property,
          scale,
          ...scale && {
            transform: createTransform({ scale, transform: transform2 })
          }
        };
      },
      propT(property, transform2) {
        return { property, transform: transform2 };
      },
      sizes: toConfig("sizes", pipe(transformFunctions.vh, transformFunctions.px)),
      sizesT: toConfig("sizes", pipe(transformFunctions.vh, transformFunctions.fraction)),
      shadows: toConfig("shadows"),
      logical,
      blur: toConfig("blur", transformFunctions.blur)
    };
    var background = {
      background: t.colors("background"),
      backgroundColor: t.colors("backgroundColor"),
      backgroundImage: t.gradients("backgroundImage"),
      backgroundSize: true,
      backgroundPosition: true,
      backgroundRepeat: true,
      backgroundAttachment: true,
      backgroundClip: { transform: transformFunctions.bgClip },
      bgSize: t.prop("backgroundSize"),
      bgPosition: t.prop("backgroundPosition"),
      bg: t.colors("background"),
      bgColor: t.colors("backgroundColor"),
      bgPos: t.prop("backgroundPosition"),
      bgRepeat: t.prop("backgroundRepeat"),
      bgAttachment: t.prop("backgroundAttachment"),
      bgGradient: t.gradients("backgroundImage"),
      bgClip: { transform: transformFunctions.bgClip }
    };
    Object.assign(background, {
      bgImage: background.backgroundImage,
      bgImg: background.backgroundImage
    });
    var border = {
      border: t.borders("border"),
      borderWidth: t.borderWidths("borderWidth"),
      borderStyle: t.borderStyles("borderStyle"),
      borderColor: t.colors("borderColor"),
      borderRadius: t.radii("borderRadius"),
      borderTop: t.borders("borderTop"),
      borderBlockStart: t.borders("borderBlockStart"),
      borderTopLeftRadius: t.radii("borderTopLeftRadius"),
      borderStartStartRadius: t.logical({
        scale: "radii",
        property: {
          ltr: "borderTopLeftRadius",
          rtl: "borderTopRightRadius"
        }
      }),
      borderEndStartRadius: t.logical({
        scale: "radii",
        property: {
          ltr: "borderBottomLeftRadius",
          rtl: "borderBottomRightRadius"
        }
      }),
      borderTopRightRadius: t.radii("borderTopRightRadius"),
      borderStartEndRadius: t.logical({
        scale: "radii",
        property: {
          ltr: "borderTopRightRadius",
          rtl: "borderTopLeftRadius"
        }
      }),
      borderEndEndRadius: t.logical({
        scale: "radii",
        property: {
          ltr: "borderBottomRightRadius",
          rtl: "borderBottomLeftRadius"
        }
      }),
      borderRight: t.borders("borderRight"),
      borderInlineEnd: t.borders("borderInlineEnd"),
      borderBottom: t.borders("borderBottom"),
      borderBlockEnd: t.borders("borderBlockEnd"),
      borderBottomLeftRadius: t.radii("borderBottomLeftRadius"),
      borderBottomRightRadius: t.radii("borderBottomRightRadius"),
      borderLeft: t.borders("borderLeft"),
      borderInlineStart: {
        property: "borderInlineStart",
        scale: "borders"
      },
      borderInlineStartRadius: t.logical({
        scale: "radii",
        property: {
          ltr: ["borderTopLeftRadius", "borderBottomLeftRadius"],
          rtl: ["borderTopRightRadius", "borderBottomRightRadius"]
        }
      }),
      borderInlineEndRadius: t.logical({
        scale: "radii",
        property: {
          ltr: ["borderTopRightRadius", "borderBottomRightRadius"],
          rtl: ["borderTopLeftRadius", "borderBottomLeftRadius"]
        }
      }),
      borderX: t.borders(["borderLeft", "borderRight"]),
      borderInline: t.borders("borderInline"),
      borderY: t.borders(["borderTop", "borderBottom"]),
      borderBlock: t.borders("borderBlock"),
      borderTopWidth: t.borderWidths("borderTopWidth"),
      borderBlockStartWidth: t.borderWidths("borderBlockStartWidth"),
      borderTopColor: t.colors("borderTopColor"),
      borderBlockStartColor: t.colors("borderBlockStartColor"),
      borderTopStyle: t.borderStyles("borderTopStyle"),
      borderBlockStartStyle: t.borderStyles("borderBlockStartStyle"),
      borderBottomWidth: t.borderWidths("borderBottomWidth"),
      borderBlockEndWidth: t.borderWidths("borderBlockEndWidth"),
      borderBottomColor: t.colors("borderBottomColor"),
      borderBlockEndColor: t.colors("borderBlockEndColor"),
      borderBottomStyle: t.borderStyles("borderBottomStyle"),
      borderBlockEndStyle: t.borderStyles("borderBlockEndStyle"),
      borderLeftWidth: t.borderWidths("borderLeftWidth"),
      borderInlineStartWidth: t.borderWidths("borderInlineStartWidth"),
      borderLeftColor: t.colors("borderLeftColor"),
      borderInlineStartColor: t.colors("borderInlineStartColor"),
      borderLeftStyle: t.borderStyles("borderLeftStyle"),
      borderInlineStartStyle: t.borderStyles("borderInlineStartStyle"),
      borderRightWidth: t.borderWidths("borderRightWidth"),
      borderInlineEndWidth: t.borderWidths("borderInlineEndWidth"),
      borderRightColor: t.colors("borderRightColor"),
      borderInlineEndColor: t.colors("borderInlineEndColor"),
      borderRightStyle: t.borderStyles("borderRightStyle"),
      borderInlineEndStyle: t.borderStyles("borderInlineEndStyle"),
      borderTopRadius: t.radii(["borderTopLeftRadius", "borderTopRightRadius"]),
      borderBottomRadius: t.radii([
        "borderBottomLeftRadius",
        "borderBottomRightRadius"
      ]),
      borderLeftRadius: t.radii(["borderTopLeftRadius", "borderBottomLeftRadius"]),
      borderRightRadius: t.radii([
        "borderTopRightRadius",
        "borderBottomRightRadius"
      ])
    };
    Object.assign(border, {
      rounded: border.borderRadius,
      roundedTop: border.borderTopRadius,
      roundedTopLeft: border.borderTopLeftRadius,
      roundedTopRight: border.borderTopRightRadius,
      roundedTopStart: border.borderStartStartRadius,
      roundedTopEnd: border.borderStartEndRadius,
      roundedBottom: border.borderBottomRadius,
      roundedBottomLeft: border.borderBottomLeftRadius,
      roundedBottomRight: border.borderBottomRightRadius,
      roundedBottomStart: border.borderEndStartRadius,
      roundedBottomEnd: border.borderEndEndRadius,
      roundedLeft: border.borderLeftRadius,
      roundedRight: border.borderRightRadius,
      roundedStart: border.borderInlineStartRadius,
      roundedEnd: border.borderInlineEndRadius,
      borderStart: border.borderInlineStart,
      borderEnd: border.borderInlineEnd,
      borderTopStartRadius: border.borderStartStartRadius,
      borderTopEndRadius: border.borderStartEndRadius,
      borderBottomStartRadius: border.borderEndStartRadius,
      borderBottomEndRadius: border.borderEndEndRadius,
      borderStartRadius: border.borderInlineStartRadius,
      borderEndRadius: border.borderInlineEndRadius,
      borderStartWidth: border.borderInlineStartWidth,
      borderEndWidth: border.borderInlineEndWidth,
      borderStartColor: border.borderInlineStartColor,
      borderEndColor: border.borderInlineEndColor,
      borderStartStyle: border.borderInlineStartStyle,
      borderEndStyle: border.borderInlineEndStyle
    });
    var color = {
      color: t.colors("color"),
      textColor: t.colors("color"),
      fill: t.colors("fill"),
      stroke: t.colors("stroke")
    };
    var effect = {
      boxShadow: t.shadows("boxShadow"),
      mixBlendMode: true,
      blendMode: t.prop("mixBlendMode"),
      backgroundBlendMode: true,
      bgBlendMode: t.prop("backgroundBlendMode"),
      opacity: true
    };
    Object.assign(effect, {
      shadow: effect.boxShadow
    });
    var filter = {
      filter: { transform: transformFunctions.filter },
      blur: t.blur("--chakra-blur"),
      brightness: t.propT("--chakra-brightness", transformFunctions.brightness),
      contrast: t.propT("--chakra-contrast", transformFunctions.contrast),
      hueRotate: t.degreeT("--chakra-hue-rotate"),
      invert: t.propT("--chakra-invert", transformFunctions.invert),
      saturate: t.propT("--chakra-saturate", transformFunctions.saturate),
      dropShadow: t.propT("--chakra-drop-shadow", transformFunctions.dropShadow),
      backdropFilter: { transform: transformFunctions.backdropFilter },
      backdropBlur: t.blur("--chakra-backdrop-blur"),
      backdropBrightness: t.propT(
        "--chakra-backdrop-brightness",
        transformFunctions.brightness
      ),
      backdropContrast: t.propT("--chakra-backdrop-contrast", transformFunctions.contrast),
      backdropHueRotate: t.degreeT("--chakra-backdrop-hue-rotate"),
      backdropInvert: t.propT("--chakra-backdrop-invert", transformFunctions.invert),
      backdropSaturate: t.propT("--chakra-backdrop-saturate", transformFunctions.saturate)
    };
    var flexbox = {
      alignItems: true,
      alignContent: true,
      justifyItems: true,
      justifyContent: true,
      flexWrap: true,
      flexDirection: { transform: transformFunctions.flexDirection },
      flex: true,
      flexFlow: true,
      flexGrow: true,
      flexShrink: true,
      flexBasis: t.sizes("flexBasis"),
      justifySelf: true,
      alignSelf: true,
      order: true,
      placeItems: true,
      placeContent: true,
      placeSelf: true,
      gap: t.space("gap"),
      rowGap: t.space("rowGap"),
      columnGap: t.space("columnGap")
    };
    Object.assign(flexbox, {
      flexDir: flexbox.flexDirection
    });
    var grid = {
      gridGap: t.space("gridGap"),
      gridColumnGap: t.space("gridColumnGap"),
      gridRowGap: t.space("gridRowGap"),
      gridColumn: true,
      gridRow: true,
      gridAutoFlow: true,
      gridAutoColumns: true,
      gridColumnStart: true,
      gridColumnEnd: true,
      gridRowStart: true,
      gridRowEnd: true,
      gridAutoRows: true,
      gridTemplate: true,
      gridTemplateColumns: true,
      gridTemplateRows: true,
      gridTemplateAreas: true,
      gridArea: true
    };
    var interactivity = {
      appearance: true,
      cursor: true,
      resize: true,
      userSelect: true,
      pointerEvents: true,
      outline: { transform: transformFunctions.outline },
      outlineOffset: true,
      outlineColor: t.colors("outlineColor")
    };
    var layout = {
      width: t.sizesT("width"),
      inlineSize: t.sizesT("inlineSize"),
      height: t.sizes("height"),
      blockSize: t.sizes("blockSize"),
      boxSize: t.sizes(["width", "height"]),
      minWidth: t.sizes("minWidth"),
      minInlineSize: t.sizes("minInlineSize"),
      minHeight: t.sizes("minHeight"),
      minBlockSize: t.sizes("minBlockSize"),
      maxWidth: t.sizes("maxWidth"),
      maxInlineSize: t.sizes("maxInlineSize"),
      maxHeight: t.sizes("maxHeight"),
      maxBlockSize: t.sizes("maxBlockSize"),
      overflow: true,
      overflowX: true,
      overflowY: true,
      overscrollBehavior: true,
      overscrollBehaviorX: true,
      overscrollBehaviorY: true,
      display: true,
      aspectRatio: true,
      hideFrom: {
        scale: "breakpoints",
        transform: (value, theme) => {
          var _a, _b, _c;
          const breakpoint = (_c = (_b = (_a = theme.__breakpoints) == null ? void 0 : _a.get(value)) == null ? void 0 : _b.minW) != null ? _c : value;
          const mq = `@media screen and (min-width: ${breakpoint})`;
          return { [mq]: { display: "none" } };
        }
      },
      hideBelow: {
        scale: "breakpoints",
        transform: (value, theme) => {
          var _a, _b, _c;
          const breakpoint = (_c = (_b = (_a = theme.__breakpoints) == null ? void 0 : _a.get(value)) == null ? void 0 : _b._minW) != null ? _c : value;
          const mq = `@media screen and (max-width: ${breakpoint})`;
          return { [mq]: { display: "none" } };
        }
      },
      verticalAlign: true,
      boxSizing: true,
      boxDecorationBreak: true,
      float: t.propT("float", transformFunctions.float),
      objectFit: true,
      objectPosition: true,
      visibility: true,
      isolation: true
    };
    Object.assign(layout, {
      w: layout.width,
      h: layout.height,
      minW: layout.minWidth,
      maxW: layout.maxWidth,
      minH: layout.minHeight,
      maxH: layout.maxHeight,
      overscroll: layout.overscrollBehavior,
      overscrollX: layout.overscrollBehaviorX,
      overscrollY: layout.overscrollBehaviorY
    });
    var list = {
      listStyleType: true,
      listStylePosition: true,
      listStylePos: t.prop("listStylePosition"),
      listStyleImage: true,
      listStyleImg: t.prop("listStyleImage")
    };
    function get(obj, path, fallback, index) {
      const key = typeof path === "string" ? path.split(".") : [path];
      for (index = 0; index < key.length; index += 1) {
        if (!obj)
          break;
        obj = obj[key[index]];
      }
      return obj === void 0 ? fallback : obj;
    }
    var memoize = (fn) => {
      const cache = /* @__PURE__ */ new WeakMap();
      const memoizedFn = (obj, path, fallback, index) => {
        if (typeof obj === "undefined") {
          return fn(obj, path, fallback);
        }
        if (!cache.has(obj)) {
          cache.set(obj, /* @__PURE__ */ new Map());
        }
        const map = cache.get(obj);
        if (map.has(path)) {
          return map.get(path);
        }
        const value = fn(obj, path, fallback, index);
        map.set(path, value);
        return value;
      };
      return memoizedFn;
    };
    var memoizedGet = memoize(get);
    var srOnly = {
      border: "0px",
      clip: "rect(0, 0, 0, 0)",
      width: "1px",
      height: "1px",
      margin: "-1px",
      padding: "0px",
      overflow: "hidden",
      whiteSpace: "nowrap",
      position: "absolute"
    };
    var srFocusable = {
      position: "static",
      width: "auto",
      height: "auto",
      clip: "auto",
      padding: "0",
      margin: "0",
      overflow: "visible",
      whiteSpace: "normal"
    };
    var getWithPriority = (theme, key, styles) => {
      const result = {};
      const obj = memoizedGet(theme, key, {});
      for (const prop in obj) {
        const isInStyles = prop in styles && styles[prop] != null;
        if (!isInStyles)
          result[prop] = obj[prop];
      }
      return result;
    };
    var others = {
      srOnly: {
        transform(value) {
          if (value === true)
            return srOnly;
          if (value === "focusable")
            return srFocusable;
          return {};
        }
      },
      layerStyle: {
        processResult: true,
        transform: (value, theme, styles) => getWithPriority(theme, `layerStyles.${value}`, styles)
      },
      textStyle: {
        processResult: true,
        transform: (value, theme, styles) => getWithPriority(theme, `textStyles.${value}`, styles)
      },
      apply: {
        processResult: true,
        transform: (value, theme, styles) => getWithPriority(theme, value, styles)
      }
    };
    var position = {
      position: true,
      pos: t.prop("position"),
      zIndex: t.prop("zIndex", "zIndices"),
      inset: t.spaceT("inset"),
      insetX: t.spaceT(["left", "right"]),
      insetInline: t.spaceT("insetInline"),
      insetY: t.spaceT(["top", "bottom"]),
      insetBlock: t.spaceT("insetBlock"),
      top: t.spaceT("top"),
      insetBlockStart: t.spaceT("insetBlockStart"),
      bottom: t.spaceT("bottom"),
      insetBlockEnd: t.spaceT("insetBlockEnd"),
      left: t.spaceT("left"),
      insetInlineStart: t.logical({
        scale: "space",
        property: { ltr: "left", rtl: "right" }
      }),
      right: t.spaceT("right"),
      insetInlineEnd: t.logical({
        scale: "space",
        property: { ltr: "right", rtl: "left" }
      })
    };
    Object.assign(position, {
      insetStart: position.insetInlineStart,
      insetEnd: position.insetInlineEnd
    });
    var ring = {
      ring: { transform: transformFunctions.ring },
      ringColor: t.colors("--chakra-ring-color"),
      ringOffset: t.prop("--chakra-ring-offset-width"),
      ringOffsetColor: t.colors("--chakra-ring-offset-color"),
      ringInset: t.prop("--chakra-ring-inset")
    };
    var space = {
      margin: t.spaceT("margin"),
      marginTop: t.spaceT("marginTop"),
      marginBlockStart: t.spaceT("marginBlockStart"),
      marginRight: t.spaceT("marginRight"),
      marginInlineEnd: t.spaceT("marginInlineEnd"),
      marginBottom: t.spaceT("marginBottom"),
      marginBlockEnd: t.spaceT("marginBlockEnd"),
      marginLeft: t.spaceT("marginLeft"),
      marginInlineStart: t.spaceT("marginInlineStart"),
      marginX: t.spaceT(["marginInlineStart", "marginInlineEnd"]),
      marginInline: t.spaceT("marginInline"),
      marginY: t.spaceT(["marginTop", "marginBottom"]),
      marginBlock: t.spaceT("marginBlock"),
      padding: t.space("padding"),
      paddingTop: t.space("paddingTop"),
      paddingBlockStart: t.space("paddingBlockStart"),
      paddingRight: t.space("paddingRight"),
      paddingBottom: t.space("paddingBottom"),
      paddingBlockEnd: t.space("paddingBlockEnd"),
      paddingLeft: t.space("paddingLeft"),
      paddingInlineStart: t.space("paddingInlineStart"),
      paddingInlineEnd: t.space("paddingInlineEnd"),
      paddingX: t.space(["paddingInlineStart", "paddingInlineEnd"]),
      paddingInline: t.space("paddingInline"),
      paddingY: t.space(["paddingTop", "paddingBottom"]),
      paddingBlock: t.space("paddingBlock")
    };
    Object.assign(space, {
      m: space.margin,
      mt: space.marginTop,
      mr: space.marginRight,
      me: space.marginInlineEnd,
      marginEnd: space.marginInlineEnd,
      mb: space.marginBottom,
      ml: space.marginLeft,
      ms: space.marginInlineStart,
      marginStart: space.marginInlineStart,
      mx: space.marginX,
      my: space.marginY,
      p: space.padding,
      pt: space.paddingTop,
      py: space.paddingY,
      px: space.paddingX,
      pb: space.paddingBottom,
      pl: space.paddingLeft,
      ps: space.paddingInlineStart,
      paddingStart: space.paddingInlineStart,
      pr: space.paddingRight,
      pe: space.paddingInlineEnd,
      paddingEnd: space.paddingInlineEnd
    });
    var textDecoration = {
      textDecorationColor: t.colors("textDecorationColor"),
      textDecoration: true,
      textDecor: { property: "textDecoration" },
      textDecorationLine: true,
      textDecorationStyle: true,
      textDecorationThickness: true,
      textUnderlineOffset: true,
      textShadow: t.shadows("textShadow")
    };
    var transform = {
      clipPath: true,
      transform: t.propT("transform", transformFunctions.transform),
      transformOrigin: true,
      translateX: t.spaceT("--chakra-translate-x"),
      translateY: t.spaceT("--chakra-translate-y"),
      skewX: t.degreeT("--chakra-skew-x"),
      skewY: t.degreeT("--chakra-skew-y"),
      scaleX: t.prop("--chakra-scale-x"),
      scaleY: t.prop("--chakra-scale-y"),
      scale: t.prop(["--chakra-scale-x", "--chakra-scale-y"]),
      rotate: t.degreeT("--chakra-rotate")
    };
    var transition = {
      transition: true,
      transitionDelay: true,
      animation: true,
      willChange: true,
      transitionDuration: t.prop("transitionDuration", "transition.duration"),
      transitionProperty: t.prop("transitionProperty", "transition.property"),
      transitionTimingFunction: t.prop(
        "transitionTimingFunction",
        "transition.easing"
      )
    };
    var typography = {
      fontFamily: t.prop("fontFamily", "fonts"),
      fontSize: t.prop("fontSize", "fontSizes", transformFunctions.px),
      fontWeight: t.prop("fontWeight", "fontWeights"),
      lineHeight: t.prop("lineHeight", "lineHeights"),
      letterSpacing: t.prop("letterSpacing", "letterSpacings"),
      textAlign: true,
      fontStyle: true,
      textIndent: true,
      wordBreak: true,
      overflowWrap: true,
      textOverflow: true,
      textTransform: true,
      whiteSpace: true,
      isTruncated: {
        transform(value) {
          if (value === true) {
            return {
              overflow: "hidden",
              textOverflow: "ellipsis",
              whiteSpace: "nowrap"
            };
          }
        }
      },
      noOfLines: {
        static: {
          overflow: "hidden",
          textOverflow: "ellipsis",
          display: "-webkit-box",
          WebkitBoxOrient: "vertical",
          WebkitLineClamp: "var(--chakra-line-clamp)"
        },
        property: "--chakra-line-clamp"
      }
    };
    var scroll = {
      scrollBehavior: true,
      scrollSnapAlign: true,
      scrollSnapStop: true,
      scrollSnapType: true,
      scrollMargin: t.spaceT("scrollMargin"),
      scrollMarginTop: t.spaceT("scrollMarginTop"),
      scrollMarginBottom: t.spaceT("scrollMarginBottom"),
      scrollMarginLeft: t.spaceT("scrollMarginLeft"),
      scrollMarginRight: t.spaceT("scrollMarginRight"),
      scrollMarginX: t.spaceT(["scrollMarginLeft", "scrollMarginRight"]),
      scrollMarginY: t.spaceT(["scrollMarginTop", "scrollMarginBottom"]),
      scrollPadding: t.spaceT("scrollPadding"),
      scrollPaddingTop: t.spaceT("scrollPaddingTop"),
      scrollPaddingBottom: t.spaceT("scrollPaddingBottom"),
      scrollPaddingLeft: t.spaceT("scrollPaddingLeft"),
      scrollPaddingRight: t.spaceT("scrollPaddingRight"),
      scrollPaddingX: t.spaceT(["scrollPaddingLeft", "scrollPaddingRight"]),
      scrollPaddingY: t.spaceT(["scrollPaddingTop", "scrollPaddingBottom"])
    };
    var import_shared_utils2 = require_dist3();
    function resolveReference(operand) {
      if ((0, import_shared_utils2.isObject)(operand) && operand.reference) {
        return operand.reference;
      }
      return String(operand);
    }
    var toExpression = (operator, ...operands) => operands.map(resolveReference).join(` ${operator} `).replace(/calc/g, "");
    var add = (...operands) => `calc(${toExpression("+", ...operands)})`;
    var subtract = (...operands) => `calc(${toExpression("-", ...operands)})`;
    var multiply = (...operands) => `calc(${toExpression("*", ...operands)})`;
    var divide = (...operands) => `calc(${toExpression("/", ...operands)})`;
    var negate = (x) => {
      const value = resolveReference(x);
      if (value != null && !Number.isNaN(parseFloat(value))) {
        return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
      }
      return multiply(value, -1);
    };
    var calc = Object.assign(
      (x) => ({
        add: (...operands) => calc(add(x, ...operands)),
        subtract: (...operands) => calc(subtract(x, ...operands)),
        multiply: (...operands) => calc(multiply(x, ...operands)),
        divide: (...operands) => calc(divide(x, ...operands)),
        negate: () => calc(negate(x)),
        toString: () => x.toString()
      }),
      {
        add,
        subtract,
        multiply,
        divide,
        negate
      }
    );
    function replaceWhiteSpace(value, replaceValue = "-") {
      return value.replace(/\s+/g, replaceValue);
    }
    function escape(value) {
      const valueStr = replaceWhiteSpace(value.toString());
      return escapeSymbol(escapeDot(valueStr));
    }
    function escapeDot(value) {
      if (value.includes("\\."))
        return value;
      const isDecimal = !Number.isInteger(parseFloat(value.toString()));
      return isDecimal ? value.replace(".", `\\.`) : value;
    }
    function escapeSymbol(value) {
      return value.replace(/[!-,/:-@[-^`{-~]/g, "\\$&");
    }
    function addPrefix(value, prefix = "") {
      return [prefix, value].filter(Boolean).join("-");
    }
    function toVarReference(name, fallback) {
      return `var(${name}${fallback ? `, ${fallback}` : ""})`;
    }
    function toVarDefinition(value, prefix = "") {
      return escape(`--${addPrefix(value, prefix)}`);
    }
    function cssVar(name, fallback, cssVarPrefix) {
      const cssVariable = toVarDefinition(name, cssVarPrefix);
      return {
        variable: cssVariable,
        reference: toVarReference(cssVariable, fallback)
      };
    }
    function defineCssVars(scope, keys2) {
      const vars = {};
      for (const key of keys2) {
        if (Array.isArray(key)) {
          const [name, fallback] = key;
          vars[name] = cssVar(`${scope}-${name}`, fallback);
          continue;
        }
        vars[key] = cssVar(`${scope}-${key}`);
      }
      return vars;
    }
    var import_shared_utils3 = require_dist3();
    function getLastItem(array) {
      const length = array == null ? 0 : array.length;
      return length ? array[length - 1] : void 0;
    }
    function analyzeCSSValue2(value) {
      const num = parseFloat(value.toString());
      const unit = value.toString().replace(String(num), "");
      return { unitless: !unit, value: num, unit };
    }
    function px(value) {
      if (value == null)
        return value;
      const { unitless } = analyzeCSSValue2(value);
      return unitless || typeof value === "number" ? `${value}px` : value;
    }
    var sortByBreakpointValue = (a, b) => parseInt(a[1], 10) > parseInt(b[1], 10) ? 1 : -1;
    var sortBps = (breakpoints) => Object.fromEntries(Object.entries(breakpoints).sort(sortByBreakpointValue));
    function normalize(breakpoints) {
      const sorted = sortBps(breakpoints);
      return Object.assign(Object.values(sorted), sorted);
    }
    function keys(breakpoints) {
      const value = Object.keys(sortBps(breakpoints));
      return new Set(value);
    }
    function subtract2(value) {
      var _a;
      if (!value)
        return value;
      value = (_a = px(value)) != null ? _a : value;
      const OFFSET = -0.02;
      return typeof value === "number" ? `${value + OFFSET}` : value.replace(/(\d+\.?\d*)/u, (m) => `${parseFloat(m) + OFFSET}`);
    }
    function toMediaQueryString(min, max) {
      const query = ["@media screen"];
      if (min)
        query.push("and", `(min-width: ${px(min)})`);
      if (max)
        query.push("and", `(max-width: ${px(max)})`);
      return query.join(" ");
    }
    function analyzeBreakpoints(breakpoints) {
      var _a;
      if (!breakpoints)
        return null;
      breakpoints.base = (_a = breakpoints.base) != null ? _a : "0px";
      const normalized = normalize(breakpoints);
      const queries = Object.entries(breakpoints).sort(sortByBreakpointValue).map(([breakpoint, minW], index, entry) => {
        var _a2;
        let [, maxW] = (_a2 = entry[index + 1]) != null ? _a2 : [];
        maxW = parseFloat(maxW) > 0 ? subtract2(maxW) : void 0;
        return {
          _minW: subtract2(minW),
          breakpoint,
          minW,
          maxW,
          maxWQuery: toMediaQueryString(null, maxW),
          minWQuery: toMediaQueryString(minW),
          minMaxQuery: toMediaQueryString(minW, maxW)
        };
      });
      const _keys = keys(breakpoints);
      const _keysArr = Array.from(_keys.values());
      return {
        keys: _keys,
        normalized,
        isResponsive(test) {
          const keys2 = Object.keys(test);
          return keys2.length > 0 && keys2.every((key) => _keys.has(key));
        },
        asObject: sortBps(breakpoints),
        asArray: normalize(breakpoints),
        details: queries,
        get(key) {
          return queries.find((q) => q.breakpoint === key);
        },
        media: [
          null,
          ...normalized.map((minW) => toMediaQueryString(minW)).slice(1)
        ],
        toArrayValue(test) {
          if (!(0, import_shared_utils3.isObject)(test)) {
            throw new Error("toArrayValue: value must be an object");
          }
          const result = _keysArr.map((bp) => {
            var _a2;
            return (_a2 = test[bp]) != null ? _a2 : null;
          });
          while (getLastItem(result) === null) {
            result.pop();
          }
          return result;
        },
        toObjectValue(test) {
          if (!Array.isArray(test)) {
            throw new Error("toObjectValue: value must be an array");
          }
          return test.reduce((acc, value, index) => {
            const key = _keysArr[index];
            if (key != null && value != null)
              acc[key] = value;
            return acc;
          }, {});
        }
      };
    }
    var import_shared_utils4 = require_dist3();
    var state = {
      hover: (str, post) => `${str}:hover ${post}, ${str}[data-hover] ${post}`,
      focus: (str, post) => `${str}:focus ${post}, ${str}[data-focus] ${post}`,
      focusVisible: (str, post) => `${str}:focus-visible ${post}`,
      focusWithin: (str, post) => `${str}:focus-within ${post}`,
      active: (str, post) => `${str}:active ${post}, ${str}[data-active] ${post}`,
      disabled: (str, post) => `${str}:disabled ${post}, ${str}[data-disabled] ${post}`,
      invalid: (str, post) => `${str}:invalid ${post}, ${str}[data-invalid] ${post}`,
      checked: (str, post) => `${str}:checked ${post}, ${str}[data-checked] ${post}`,
      indeterminate: (str, post) => `${str}:indeterminate ${post}, ${str}[aria-checked=mixed] ${post}, ${str}[data-indeterminate] ${post}`,
      readOnly: (str, post) => `${str}:read-only ${post}, ${str}[readonly] ${post}, ${str}[data-read-only] ${post}`,
      expanded: (str, post) => `${str}:read-only ${post}, ${str}[aria-expanded=true] ${post}, ${str}[data-expanded] ${post}`,
      placeholderShown: (str, post) => `${str}:placeholder-shown ${post}`
    };
    var toGroup = (fn) => merge((v) => fn(v, "&"), "[role=group]", "[data-group]", ".group");
    var toPeer = (fn) => merge((v) => fn(v, "~ &"), "[data-peer]", ".peer");
    var merge = (fn, ...selectors) => selectors.map(fn).join(", ");
    var pseudoSelectors = {
      _hover: "&:hover, &[data-hover]",
      _active: "&:active, &[data-active]",
      _focus: "&:focus, &[data-focus]",
      _highlighted: "&[data-highlighted]",
      _focusWithin: "&:focus-within",
      _focusVisible: "&:focus-visible, &[data-focus-visible]",
      _disabled: "&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",
      _readOnly: "&[aria-readonly=true], &[readonly], &[data-readonly]",
      _before: "&::before",
      _after: "&::after",
      _empty: "&:empty",
      _expanded: "&[aria-expanded=true], &[data-expanded]",
      _checked: "&[aria-checked=true], &[data-checked]",
      _grabbed: "&[aria-grabbed=true], &[data-grabbed]",
      _pressed: "&[aria-pressed=true], &[data-pressed]",
      _invalid: "&[aria-invalid=true], &[data-invalid]",
      _valid: "&[data-valid], &[data-state=valid]",
      _loading: "&[data-loading], &[aria-busy=true]",
      _selected: "&[aria-selected=true], &[data-selected]",
      _hidden: "&[hidden], &[data-hidden]",
      _autofill: "&:-webkit-autofill",
      _even: "&:nth-of-type(even)",
      _odd: "&:nth-of-type(odd)",
      _first: "&:first-of-type",
      _firstLetter: "&::first-letter",
      _last: "&:last-of-type",
      _notFirst: "&:not(:first-of-type)",
      _notLast: "&:not(:last-of-type)",
      _visited: "&:visited",
      _activeLink: "&[aria-current=page]",
      _activeStep: "&[aria-current=step]",
      _indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate]",
      _groupHover: toGroup(state.hover),
      _peerHover: toPeer(state.hover),
      _groupFocus: toGroup(state.focus),
      _peerFocus: toPeer(state.focus),
      _groupFocusVisible: toGroup(state.focusVisible),
      _peerFocusVisible: toPeer(state.focusVisible),
      _groupActive: toGroup(state.active),
      _peerActive: toPeer(state.active),
      _groupDisabled: toGroup(state.disabled),
      _peerDisabled: toPeer(state.disabled),
      _groupInvalid: toGroup(state.invalid),
      _peerInvalid: toPeer(state.invalid),
      _groupChecked: toGroup(state.checked),
      _peerChecked: toPeer(state.checked),
      _groupFocusWithin: toGroup(state.focusWithin),
      _peerFocusWithin: toPeer(state.focusWithin),
      _peerPlaceholderShown: toPeer(state.placeholderShown),
      _placeholder: "&::placeholder",
      _placeholderShown: "&:placeholder-shown",
      _fullScreen: "&:fullscreen",
      _selection: "&::selection",
      _rtl: "[dir=rtl] &, &[dir=rtl]",
      _ltr: "[dir=ltr] &, &[dir=ltr]",
      _mediaDark: "@media (prefers-color-scheme: dark)",
      _mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",
      _dark: ".chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]",
      _light: ".chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]",
      _horizontal: "&[data-orientation=horizontal]",
      _vertical: "&[data-orientation=vertical]"
    };
    var pseudoPropNames = Object.keys(
      pseudoSelectors
    );
    var import_lodash = __toESM(require_lodash());
    function tokenToCssVar(token, prefix) {
      return cssVar(String(token).replace(/\./g, "-"), void 0, prefix);
    }
    function createThemeVars(flatTokens, options) {
      let cssVars = {};
      const cssMap = {};
      for (const [token, tokenValue] of Object.entries(flatTokens)) {
        const { isSemantic, value } = tokenValue;
        const { variable, reference } = tokenToCssVar(token, options == null ? void 0 : options.cssVarPrefix);
        if (!isSemantic) {
          if (token.startsWith("space")) {
            const keys2 = token.split(".");
            const [firstKey, ...referenceKeys] = keys2;
            const negativeLookupKey = `${firstKey}.-${referenceKeys.join(".")}`;
            const negativeValue = calc.negate(value);
            const negatedReference = calc.negate(reference);
            cssMap[negativeLookupKey] = {
              value: negativeValue,
              var: variable,
              varRef: negatedReference
            };
          }
          cssVars[variable] = value;
          cssMap[token] = {
            value,
            var: variable,
            varRef: reference
          };
          continue;
        }
        const lookupToken = (maybeToken) => {
          const scale = String(token).split(".")[0];
          const withScale = [scale, maybeToken].join(".");
          const resolvedTokenValue = flatTokens[withScale];
          if (!resolvedTokenValue)
            return maybeToken;
          const { reference: reference2 } = tokenToCssVar(withScale, options == null ? void 0 : options.cssVarPrefix);
          return reference2;
        };
        const normalizedValue = (0, import_shared_utils4.isObject)(value) ? value : { default: value };
        cssVars = (0, import_lodash.default)(
          cssVars,
          Object.entries(normalizedValue).reduce(
            (acc, [conditionAlias, conditionValue]) => {
              var _a, _b;
              if (!conditionValue)
                return acc;
              const tokenReference = lookupToken(`${conditionValue}`);
              if (conditionAlias === "default") {
                acc[variable] = tokenReference;
                return acc;
              }
              const conditionSelector = (_b = (_a = pseudoSelectors) == null ? void 0 : _a[conditionAlias]) != null ? _b : conditionAlias;
              acc[conditionSelector] = { [variable]: tokenReference };
              return acc;
            },
            {}
          )
        );
        cssMap[token] = {
          value: reference,
          var: variable,
          varRef: reference
        };
      }
      return {
        cssVars,
        cssMap
      };
    }
    function omit(object, keysToOmit = []) {
      const clone = Object.assign({}, object);
      for (const key of keysToOmit) {
        if (key in clone) {
          delete clone[key];
        }
      }
      return clone;
    }
    function pick(object, keysToPick) {
      const result = {};
      for (const key of keysToPick) {
        if (key in object) {
          result[key] = object[key];
        }
      }
      return result;
    }
    function isObject5(value) {
      return typeof value === "object" && value != null && !Array.isArray(value);
    }
    function walkObject(target, predicate, options = {}) {
      const { stop, getKey } = options;
      function inner(value, path = []) {
        var _a;
        if (isObject5(value) || Array.isArray(value)) {
          const result = {};
          for (const [prop, child] of Object.entries(value)) {
            const key = (_a = getKey == null ? void 0 : getKey(prop)) != null ? _a : prop;
            const childPath = [...path, key];
            if (stop == null ? void 0 : stop(value, childPath)) {
              return predicate(value, path);
            }
            result[key] = inner(child, childPath);
          }
          return result;
        }
        return predicate(value, path);
      }
      return inner(target);
    }
    var tokens = [
      "colors",
      "borders",
      "borderWidths",
      "borderStyles",
      "fonts",
      "fontSizes",
      "fontWeights",
      "gradients",
      "letterSpacings",
      "lineHeights",
      "radii",
      "space",
      "shadows",
      "sizes",
      "zIndices",
      "transition",
      "blur",
      "breakpoints"
    ];
    function extractTokens(theme) {
      const _tokens = tokens;
      return pick(theme, _tokens);
    }
    function extractSemanticTokens(theme) {
      return theme.semanticTokens;
    }
    function omitVars(rawTheme) {
      const { __cssMap, __cssVars, __breakpoints, ...cleanTheme } = rawTheme;
      return cleanTheme;
    }
    var isSemanticCondition = (key) => pseudoPropNames.includes(key) || "default" === key;
    function flattenTokens({
      tokens: tokens2,
      semanticTokens
    }) {
      const result = {};
      walkObject(tokens2, (value, path) => {
        if (value == null)
          return;
        result[path.join(".")] = { isSemantic: false, value };
      });
      walkObject(
        semanticTokens,
        (value, path) => {
          if (value == null)
            return;
          result[path.join(".")] = { isSemantic: true, value };
        },
        {
          stop: (value) => Object.keys(value).every(isSemanticCondition)
        }
      );
      return result;
    }
    function toCSSVar(rawTheme) {
      var _a;
      const theme = omitVars(rawTheme);
      const tokens2 = extractTokens(theme);
      const semanticTokens = extractSemanticTokens(theme);
      const flatTokens = flattenTokens({ tokens: tokens2, semanticTokens });
      const cssVarPrefix = (_a = theme.config) == null ? void 0 : _a.cssVarPrefix;
      const {
        cssMap,
        cssVars
      } = createThemeVars(flatTokens, { cssVarPrefix });
      const defaultCssVars = {
        "--chakra-ring-inset": "var(--chakra-empty,/*!*/ /*!*/)",
        "--chakra-ring-offset-width": "0px",
        "--chakra-ring-offset-color": "#fff",
        "--chakra-ring-color": "rgba(66, 153, 225, 0.6)",
        "--chakra-ring-offset-shadow": "0 0 #0000",
        "--chakra-ring-shadow": "0 0 #0000",
        "--chakra-space-x-reverse": "0",
        "--chakra-space-y-reverse": "0"
      };
      Object.assign(theme, {
        __cssVars: { ...defaultCssVars, ...cssVars },
        __cssMap: cssMap,
        __breakpoints: analyzeBreakpoints(theme.breakpoints)
      });
      return theme;
    }
    var import_shared_utils6 = require_dist3();
    var import_lodash3 = __toESM(require_lodash());
    var import_lodash2 = __toESM(require_lodash());
    var systemProps = (0, import_lodash2.default)(
      {},
      background,
      border,
      color,
      flexbox,
      layout,
      filter,
      ring,
      interactivity,
      grid,
      others,
      position,
      effect,
      space,
      scroll,
      typography,
      textDecoration,
      transform,
      list,
      transition
    );
    var layoutSystem = Object.assign({}, space, layout, flexbox, grid, position);
    var layoutPropNames = Object.keys(
      layoutSystem
    );
    var propNames = [...Object.keys(systemProps), ...pseudoPropNames];
    var styleProps = { ...systemProps, ...pseudoSelectors };
    var isStyleProp = (prop) => prop in styleProps;
    var import_shared_utils5 = require_dist3();
    var expandResponsive = (styles) => (theme) => {
      if (!theme.__breakpoints)
        return styles;
      const { isResponsive, toArrayValue, media: medias } = theme.__breakpoints;
      const computedStyles = {};
      for (const key in styles) {
        let value = (0, import_shared_utils5.runIfFn)(styles[key], theme);
        if (value == null)
          continue;
        value = (0, import_shared_utils5.isObject)(value) && isResponsive(value) ? toArrayValue(value) : value;
        if (!Array.isArray(value)) {
          computedStyles[key] = value;
          continue;
        }
        const queries = value.slice(0, medias.length).length;
        for (let index = 0; index < queries; index += 1) {
          const media = medias == null ? void 0 : medias[index];
          if (!media) {
            computedStyles[key] = value[index];
            continue;
          }
          computedStyles[media] = computedStyles[media] || {};
          if (value[index] == null) {
            continue;
          }
          computedStyles[media][key] = value[index];
        }
      }
      return computedStyles;
    };
    function splitByComma(value) {
      const chunks = [];
      let chunk = "";
      let inParens = false;
      for (let i = 0; i < value.length; i++) {
        const char = value[i];
        if (char === "(") {
          inParens = true;
          chunk += char;
        } else if (char === ")") {
          inParens = false;
          chunk += char;
        } else if (char === "," && !inParens) {
          chunks.push(chunk);
          chunk = "";
        } else {
          chunk += char;
        }
      }
      chunk = chunk.trim();
      if (chunk) {
        chunks.push(chunk);
      }
      return chunks;
    }
    function isCssVar2(value) {
      return /^var\(--.+\)$/.test(value);
    }
    var isCSSVariableTokenValue = (key, value) => key.startsWith("--") && typeof value === "string" && !isCssVar2(value);
    var resolveTokenValue = (theme, value) => {
      var _a, _b;
      if (value == null)
        return value;
      const getVar = (val) => {
        var _a2, _b2;
        return (_b2 = (_a2 = theme.__cssMap) == null ? void 0 : _a2[val]) == null ? void 0 : _b2.varRef;
      };
      const getValue = (val) => {
        var _a2;
        return (_a2 = getVar(val)) != null ? _a2 : val;
      };
      const [tokenValue, fallbackValue] = splitByComma(value);
      value = (_b = (_a = getVar(tokenValue)) != null ? _a : getValue(fallbackValue)) != null ? _b : getValue(value);
      return value;
    };
    function getCss(options) {
      const { configs = {}, pseudos = {}, theme } = options;
      const css2 = (stylesOrFn, nested = false) => {
        var _a, _b, _c;
        const _styles = (0, import_shared_utils6.runIfFn)(stylesOrFn, theme);
        const styles = expandResponsive(_styles)(theme);
        let computedStyles = {};
        for (let key in styles) {
          const valueOrFn = styles[key];
          let value = (0, import_shared_utils6.runIfFn)(valueOrFn, theme);
          if (key in pseudos) {
            key = pseudos[key];
          }
          if (isCSSVariableTokenValue(key, value)) {
            value = resolveTokenValue(theme, value);
          }
          let config = configs[key];
          if (config === true) {
            config = { property: key };
          }
          if ((0, import_shared_utils6.isObject)(value)) {
            computedStyles[key] = (_a = computedStyles[key]) != null ? _a : {};
            computedStyles[key] = (0, import_lodash3.default)(
              {},
              computedStyles[key],
              css2(value, true)
            );
            continue;
          }
          let rawValue = (_c = (_b = config == null ? void 0 : config.transform) == null ? void 0 : _b.call(config, value, theme, _styles)) != null ? _c : value;
          rawValue = (config == null ? void 0 : config.processResult) ? css2(rawValue, true) : rawValue;
          const configProperty = (0, import_shared_utils6.runIfFn)(config == null ? void 0 : config.property, theme);
          if (!nested && (config == null ? void 0 : config.static)) {
            const staticStyles = (0, import_shared_utils6.runIfFn)(config.static, theme);
            computedStyles = (0, import_lodash3.default)({}, computedStyles, staticStyles);
          }
          if (configProperty && Array.isArray(configProperty)) {
            for (const property of configProperty) {
              computedStyles[property] = rawValue;
            }
            continue;
          }
          if (configProperty) {
            if (configProperty === "&" && (0, import_shared_utils6.isObject)(rawValue)) {
              computedStyles = (0, import_lodash3.default)({}, computedStyles, rawValue);
            } else {
              computedStyles[configProperty] = rawValue;
            }
            continue;
          }
          if ((0, import_shared_utils6.isObject)(rawValue)) {
            computedStyles = (0, import_lodash3.default)({}, computedStyles, rawValue);
            continue;
          }
          computedStyles[key] = rawValue;
        }
        return computedStyles;
      };
      return css2;
    }
    var css = (styles) => (theme) => {
      const cssFn = getCss({
        theme,
        pseudos: pseudoSelectors,
        configs: systemProps
      });
      return cssFn(styles);
    };
    function defineStyle(styles) {
      return styles;
    }
    function defineStyleConfig(config) {
      return config;
    }
    function createMultiStyleConfigHelpers(parts) {
      return {
        definePartsStyle(config) {
          return config;
        },
        defineMultiStyleConfig(config) {
          return { parts, ...config };
        }
      };
    }
    var import_shared_utils7 = require_dist3();
    var import_lodash4 = __toESM(require_lodash());
    function normalize2(value, toArray) {
      if (Array.isArray(value))
        return value;
      if ((0, import_shared_utils7.isObject)(value))
        return toArray(value);
      if (value != null)
        return [value];
    }
    function getNextIndex(values, i) {
      for (let j = i + 1; j < values.length; j++) {
        if (values[j] != null)
          return j;
      }
      return -1;
    }
    function createResolver(theme) {
      const breakpointUtil = theme.__breakpoints;
      return function resolver(config, prop, value, props) {
        var _a, _b;
        if (!breakpointUtil)
          return;
        const result = {};
        const normalized = normalize2(value, breakpointUtil.toArrayValue);
        if (!normalized)
          return result;
        const len = normalized.length;
        const isSingle = len === 1;
        const isMultipart = !!config.parts;
        for (let i = 0; i < len; i++) {
          const key = breakpointUtil.details[i];
          const nextKey = breakpointUtil.details[getNextIndex(normalized, i)];
          const query = toMediaQueryString(key.minW, nextKey == null ? void 0 : nextKey._minW);
          const styles = (0, import_shared_utils7.runIfFn)((_a = config[prop]) == null ? void 0 : _a[normalized[i]], props);
          if (!styles)
            continue;
          if (isMultipart) {
            (_b = config.parts) == null ? void 0 : _b.forEach((part) => {
              (0, import_lodash4.default)(result, {
                [part]: isSingle ? styles[part] : { [query]: styles[part] }
              });
            });
            continue;
          }
          if (!isMultipart) {
            if (isSingle)
              (0, import_lodash4.default)(result, styles);
            else
              result[query] = styles;
            continue;
          }
          result[query] = styles;
        }
        return result;
      };
    }
    function resolveStyleConfig(config) {
      return (props) => {
        var _a;
        const { variant, size, theme } = props;
        const recipe = createResolver(theme);
        return (0, import_lodash4.default)(
          {},
          (0, import_shared_utils7.runIfFn)((_a = config.baseStyle) != null ? _a : {}, props),
          recipe(config, "sizes", size, props),
          recipe(config, "variants", variant, props)
        );
      };
    }
    function getCSSVar(theme, scale, value) {
      var _a, _b, _c;
      return (_c = (_b = (_a = theme.__cssMap) == null ? void 0 : _a[`${scale}.${value}`]) == null ? void 0 : _b.varRef) != null ? _c : value;
    }
    function omitThemingProps(props) {
      return omit(props, ["styleConfig", "size", "variant", "colorScheme"]);
    }
  }
});

// ../../node_modules/@emotion/sheet/dist/emotion-sheet.cjs.dev.js
var require_emotion_sheet_cjs_dev = __commonJS({
  "../../node_modules/@emotion/sheet/dist/emotion-sheet.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function sheetForTag(tag) {
      if (tag.sheet) {
        return tag.sheet;
      }
      for (var i = 0; i < document.styleSheets.length; i++) {
        if (document.styleSheets[i].ownerNode === tag) {
          return document.styleSheets[i];
        }
      }
    }
    function createStyleElement(options) {
      var tag = document.createElement("style");
      tag.setAttribute("data-emotion", options.key);
      if (options.nonce !== void 0) {
        tag.setAttribute("nonce", options.nonce);
      }
      tag.appendChild(document.createTextNode(""));
      tag.setAttribute("data-s", "");
      return tag;
    }
    var StyleSheet = function() {
      function StyleSheet2(options) {
        var _this = this;
        this._insertTag = function(tag) {
          var before;
          if (_this.tags.length === 0) {
            if (_this.insertionPoint) {
              before = _this.insertionPoint.nextSibling;
            } else if (_this.prepend) {
              before = _this.container.firstChild;
            } else {
              before = _this.before;
            }
          } else {
            before = _this.tags[_this.tags.length - 1].nextSibling;
          }
          _this.container.insertBefore(tag, before);
          _this.tags.push(tag);
        };
        this.isSpeedy = options.speedy === void 0 ? false : options.speedy;
        this.tags = [];
        this.ctr = 0;
        this.nonce = options.nonce;
        this.key = options.key;
        this.container = options.container;
        this.prepend = options.prepend;
        this.insertionPoint = options.insertionPoint;
        this.before = null;
      }
      var _proto = StyleSheet2.prototype;
      _proto.hydrate = function hydrate(nodes) {
        nodes.forEach(this._insertTag);
      };
      _proto.insert = function insert(rule) {
        if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
          this._insertTag(createStyleElement(this));
        }
        var tag = this.tags[this.tags.length - 1];
        if (true) {
          var isImportRule = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
          if (isImportRule && this._alreadyInsertedOrderInsensitiveRule) {
            console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
          }
          this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule;
        }
        if (this.isSpeedy) {
          var sheet = sheetForTag(tag);
          try {
            sheet.insertRule(rule, sheet.cssRules.length);
          } catch (e) {
            if (!/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {
              console.error('There was a problem inserting the following rule: "' + rule + '"', e);
            }
          }
        } else {
          tag.appendChild(document.createTextNode(rule));
        }
        this.ctr++;
      };
      _proto.flush = function flush() {
        this.tags.forEach(function(tag) {
          return tag.parentNode && tag.parentNode.removeChild(tag);
        });
        this.tags = [];
        this.ctr = 0;
        if (true) {
          this._alreadyInsertedOrderInsensitiveRule = false;
        }
      };
      return StyleSheet2;
    }();
    exports.StyleSheet = StyleSheet;
  }
});

// ../../node_modules/@emotion/sheet/dist/emotion-sheet.cjs.js
var require_emotion_sheet_cjs = __commonJS({
  "../../node_modules/@emotion/sheet/dist/emotion-sheet.cjs.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_emotion_sheet_cjs_dev();
    }
  }
});

// ../../node_modules/stylis/dist/umd/stylis.js
var require_stylis = __commonJS({
  "../../node_modules/stylis/dist/umd/stylis.js"(exports, module) {
    (function(e, r) {
      typeof exports === "object" && typeof module !== "undefined" ? r(exports) : typeof define === "function" && define.amd ? define(["exports"], r) : (e = e || self, r(e.stylis = {}));
    })(exports, function(e) {
      "use strict";
      var r = "-ms-";
      var a = "-moz-";
      var c = "-webkit-";
      var n = "comm";
      var t = "rule";
      var s = "decl";
      var i = "@page";
      var u = "@media";
      var o = "@import";
      var f = "@charset";
      var l = "@viewport";
      var p = "@supports";
      var h = "@document";
      var v = "@namespace";
      var d = "@keyframes";
      var b = "@font-face";
      var w = "@counter-style";
      var m = "@font-feature-values";
      var g = "@layer";
      var k = Math.abs;
      var $ = String.fromCharCode;
      var x = Object.assign;
      function E(e2, r2) {
        return M(e2, 0) ^ 45 ? (((r2 << 2 ^ M(e2, 0)) << 2 ^ M(e2, 1)) << 2 ^ M(e2, 2)) << 2 ^ M(e2, 3) : 0;
      }
      function y(e2) {
        return e2.trim();
      }
      function T(e2, r2) {
        return (e2 = r2.exec(e2)) ? e2[0] : e2;
      }
      function A(e2, r2, a2) {
        return e2.replace(r2, a2);
      }
      function O(e2, r2) {
        return e2.indexOf(r2);
      }
      function M(e2, r2) {
        return e2.charCodeAt(r2) | 0;
      }
      function C(e2, r2, a2) {
        return e2.slice(r2, a2);
      }
      function R(e2) {
        return e2.length;
      }
      function S(e2) {
        return e2.length;
      }
      function z(e2, r2) {
        return r2.push(e2), e2;
      }
      function N(e2, r2) {
        return e2.map(r2).join("");
      }
      e.line = 1;
      e.column = 1;
      e.length = 0;
      e.position = 0;
      e.character = 0;
      e.characters = "";
      function P(r2, a2, c2, n2, t2, s2, i2) {
        return { value: r2, root: a2, parent: c2, type: n2, props: t2, children: s2, line: e.line, column: e.column, length: i2, return: "" };
      }
      function j(e2, r2) {
        return x(P("", null, null, "", null, null, 0), e2, { length: -e2.length }, r2);
      }
      function U() {
        return e.character;
      }
      function _() {
        e.character = e.position > 0 ? M(e.characters, --e.position) : 0;
        if (e.column--, e.character === 10)
          e.column = 1, e.line--;
        return e.character;
      }
      function F() {
        e.character = e.position < e.length ? M(e.characters, e.position++) : 0;
        if (e.column++, e.character === 10)
          e.column = 1, e.line++;
        return e.character;
      }
      function I() {
        return M(e.characters, e.position);
      }
      function L() {
        return e.position;
      }
      function D(r2, a2) {
        return C(e.characters, r2, a2);
      }
      function Y(e2) {
        switch (e2) {
          case 0:
          case 9:
          case 10:
          case 13:
          case 32:
            return 5;
          case 33:
          case 43:
          case 44:
          case 47:
          case 62:
          case 64:
          case 126:
          case 59:
          case 123:
          case 125:
            return 4;
          case 58:
            return 3;
          case 34:
          case 39:
          case 40:
          case 91:
            return 2;
          case 41:
          case 93:
            return 1;
        }
        return 0;
      }
      function K(r2) {
        return e.line = e.column = 1, e.length = R(e.characters = r2), e.position = 0, [];
      }
      function V(r2) {
        return e.characters = "", r2;
      }
      function W(r2) {
        return y(D(e.position - 1, q(r2 === 91 ? r2 + 2 : r2 === 40 ? r2 + 1 : r2)));
      }
      function B(e2) {
        return V(H(K(e2)));
      }
      function G(r2) {
        while (e.character = I())
          if (e.character < 33)
            F();
          else
            break;
        return Y(r2) > 2 || Y(e.character) > 3 ? "" : " ";
      }
      function H(r2) {
        while (F())
          switch (Y(e.character)) {
            case 0:
              z(Q(e.position - 1), r2);
              break;
            case 2:
              z(W(e.character), r2);
              break;
            default:
              z($(e.character), r2);
          }
        return r2;
      }
      function Z(r2, a2) {
        while (--a2 && F())
          if (e.character < 48 || e.character > 102 || e.character > 57 && e.character < 65 || e.character > 70 && e.character < 97)
            break;
        return D(r2, L() + (a2 < 6 && I() == 32 && F() == 32));
      }
      function q(r2) {
        while (F())
          switch (e.character) {
            case r2:
              return e.position;
            case 34:
            case 39:
              if (r2 !== 34 && r2 !== 39)
                q(e.character);
              break;
            case 40:
              if (r2 === 41)
                q(r2);
              break;
            case 92:
              F();
              break;
          }
        return e.position;
      }
      function J(r2, a2) {
        while (F())
          if (r2 + e.character === 47 + 10)
            break;
          else if (r2 + e.character === 42 + 42 && I() === 47)
            break;
        return "/*" + D(a2, e.position - 1) + "*" + $(r2 === 47 ? r2 : F());
      }
      function Q(r2) {
        while (!Y(I()))
          F();
        return D(r2, e.position);
      }
      function X(e2) {
        return V(ee("", null, null, null, [""], e2 = K(e2), 0, [0], e2));
      }
      function ee(e2, r2, a2, c2, n2, t2, s2, i2, u2) {
        var o2 = 0;
        var f2 = 0;
        var l2 = s2;
        var p2 = 0;
        var h2 = 0;
        var v2 = 0;
        var d2 = 1;
        var b2 = 1;
        var w2 = 1;
        var m2 = 0;
        var g2 = "";
        var k2 = n2;
        var x2 = t2;
        var E2 = c2;
        var y2 = g2;
        while (b2)
          switch (v2 = m2, m2 = F()) {
            case 40:
              if (v2 != 108 && M(y2, l2 - 1) == 58) {
                if (O(y2 += A(W(m2), "&", "&\f"), "&\f") != -1)
                  w2 = -1;
                break;
              }
            case 34:
            case 39:
            case 91:
              y2 += W(m2);
              break;
            case 9:
            case 10:
            case 13:
            case 32:
              y2 += G(v2);
              break;
            case 92:
              y2 += Z(L() - 1, 7);
              continue;
            case 47:
              switch (I()) {
                case 42:
                case 47:
                  z(ae(J(F(), L()), r2, a2), u2);
                  break;
                default:
                  y2 += "/";
              }
              break;
            case 123 * d2:
              i2[o2++] = R(y2) * w2;
            case 125 * d2:
            case 59:
            case 0:
              switch (m2) {
                case 0:
                case 125:
                  b2 = 0;
                case 59 + f2:
                  if (w2 == -1)
                    y2 = A(y2, /\f/g, "");
                  if (h2 > 0 && R(y2) - l2)
                    z(h2 > 32 ? ce(y2 + ";", c2, a2, l2 - 1) : ce(A(y2, " ", "") + ";", c2, a2, l2 - 2), u2);
                  break;
                case 59:
                  y2 += ";";
                default:
                  z(E2 = re(y2, r2, a2, o2, f2, n2, i2, g2, k2 = [], x2 = [], l2), t2);
                  if (m2 === 123)
                    if (f2 === 0)
                      ee(y2, r2, E2, E2, k2, t2, l2, i2, x2);
                    else
                      switch (p2 === 99 && M(y2, 3) === 110 ? 100 : p2) {
                        case 100:
                        case 108:
                        case 109:
                        case 115:
                          ee(e2, E2, E2, c2 && z(re(e2, E2, E2, 0, 0, n2, i2, g2, n2, k2 = [], l2), x2), n2, x2, l2, i2, c2 ? k2 : x2);
                          break;
                        default:
                          ee(y2, E2, E2, E2, [""], x2, 0, i2, x2);
                      }
              }
              o2 = f2 = h2 = 0, d2 = w2 = 1, g2 = y2 = "", l2 = s2;
              break;
            case 58:
              l2 = 1 + R(y2), h2 = v2;
            default:
              if (d2 < 1) {
                if (m2 == 123)
                  --d2;
                else if (m2 == 125 && d2++ == 0 && _() == 125)
                  continue;
              }
              switch (y2 += $(m2), m2 * d2) {
                case 38:
                  w2 = f2 > 0 ? 1 : (y2 += "\f", -1);
                  break;
                case 44:
                  i2[o2++] = (R(y2) - 1) * w2, w2 = 1;
                  break;
                case 64:
                  if (I() === 45)
                    y2 += W(F());
                  p2 = I(), f2 = l2 = R(g2 = y2 += Q(L())), m2++;
                  break;
                case 45:
                  if (v2 === 45 && R(y2) == 2)
                    d2 = 0;
              }
          }
        return t2;
      }
      function re(e2, r2, a2, c2, n2, s2, i2, u2, o2, f2, l2) {
        var p2 = n2 - 1;
        var h2 = n2 === 0 ? s2 : [""];
        var v2 = S(h2);
        for (var d2 = 0, b2 = 0, w2 = 0; d2 < c2; ++d2)
          for (var m2 = 0, g2 = C(e2, p2 + 1, p2 = k(b2 = i2[d2])), $2 = e2; m2 < v2; ++m2)
            if ($2 = y(b2 > 0 ? h2[m2] + " " + g2 : A(g2, /&\f/g, h2[m2])))
              o2[w2++] = $2;
        return P(e2, r2, a2, n2 === 0 ? t : u2, o2, f2, l2);
      }
      function ae(e2, r2, a2) {
        return P(e2, r2, a2, n, $(U()), C(e2, 2, -2), 0);
      }
      function ce(e2, r2, a2, c2) {
        return P(e2, r2, a2, s, C(e2, 0, c2), C(e2, c2 + 1, -1), c2);
      }
      function ne(e2, n2, t2) {
        switch (E(e2, n2)) {
          case 5103:
            return c + "print-" + e2 + e2;
          case 5737:
          case 4201:
          case 3177:
          case 3433:
          case 1641:
          case 4457:
          case 2921:
          case 5572:
          case 6356:
          case 5844:
          case 3191:
          case 6645:
          case 3005:
          case 6391:
          case 5879:
          case 5623:
          case 6135:
          case 4599:
          case 4855:
          case 4215:
          case 6389:
          case 5109:
          case 5365:
          case 5621:
          case 3829:
            return c + e2 + e2;
          case 4789:
            return a + e2 + e2;
          case 5349:
          case 4246:
          case 4810:
          case 6968:
          case 2756:
            return c + e2 + a + e2 + r + e2 + e2;
          case 5936:
            switch (M(e2, n2 + 11)) {
              case 114:
                return c + e2 + r + A(e2, /[svh]\w+-[tblr]{2}/, "tb") + e2;
              case 108:
                return c + e2 + r + A(e2, /[svh]\w+-[tblr]{2}/, "tb-rl") + e2;
              case 45:
                return c + e2 + r + A(e2, /[svh]\w+-[tblr]{2}/, "lr") + e2;
            }
          case 6828:
          case 4268:
          case 2903:
            return c + e2 + r + e2 + e2;
          case 6165:
            return c + e2 + r + "flex-" + e2 + e2;
          case 5187:
            return c + e2 + A(e2, /(\w+).+(:[^]+)/, c + "box-$1$2" + r + "flex-$1$2") + e2;
          case 5443:
            return c + e2 + r + "flex-item-" + A(e2, /flex-|-self/g, "") + (!T(e2, /flex-|baseline/) ? r + "grid-row-" + A(e2, /flex-|-self/g, "") : "") + e2;
          case 4675:
            return c + e2 + r + "flex-line-pack" + A(e2, /align-content|flex-|-self/g, "") + e2;
          case 5548:
            return c + e2 + r + A(e2, "shrink", "negative") + e2;
          case 5292:
            return c + e2 + r + A(e2, "basis", "preferred-size") + e2;
          case 6060:
            return c + "box-" + A(e2, "-grow", "") + c + e2 + r + A(e2, "grow", "positive") + e2;
          case 4554:
            return c + A(e2, /([^-])(transform)/g, "$1" + c + "$2") + e2;
          case 6187:
            return A(A(A(e2, /(zoom-|grab)/, c + "$1"), /(image-set)/, c + "$1"), e2, "") + e2;
          case 5495:
          case 3959:
            return A(e2, /(image-set\([^]*)/, c + "$1$`$1");
          case 4968:
            return A(A(e2, /(.+:)(flex-)?(.*)/, c + "box-pack:$3" + r + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + c + e2 + e2;
          case 4200:
            if (!T(e2, /flex-|baseline/))
              return r + "grid-column-align" + C(e2, n2) + e2;
            break;
          case 2592:
          case 3360:
            return r + A(e2, "template-", "") + e2;
          case 4384:
          case 3616:
            if (t2 && t2.some(function(e3, r2) {
              return n2 = r2, T(e3.props, /grid-\w+-end/);
            })) {
              return ~O(e2 + (t2 = t2[n2].value), "span") ? e2 : r + A(e2, "-start", "") + e2 + r + "grid-row-span:" + (~O(t2, "span") ? T(t2, /\d+/) : +T(t2, /\d+/) - +T(e2, /\d+/)) + ";";
            }
            return r + A(e2, "-start", "") + e2;
          case 4896:
          case 4128:
            return t2 && t2.some(function(e3) {
              return T(e3.props, /grid-\w+-start/);
            }) ? e2 : r + A(A(e2, "-end", "-span"), "span ", "") + e2;
          case 4095:
          case 3583:
          case 4068:
          case 2532:
            return A(e2, /(.+)-inline(.+)/, c + "$1$2") + e2;
          case 8116:
          case 7059:
          case 5753:
          case 5535:
          case 5445:
          case 5701:
          case 4933:
          case 4677:
          case 5533:
          case 5789:
          case 5021:
          case 4765:
            if (R(e2) - 1 - n2 > 6)
              switch (M(e2, n2 + 1)) {
                case 109:
                  if (M(e2, n2 + 4) !== 45)
                    break;
                case 102:
                  return A(e2, /(.+:)(.+)-([^]+)/, "$1" + c + "$2-$3$1" + a + (M(e2, n2 + 3) == 108 ? "$3" : "$2-$3")) + e2;
                case 115:
                  return ~O(e2, "stretch") ? ne(A(e2, "stretch", "fill-available"), n2, t2) + e2 : e2;
              }
            break;
          case 5152:
          case 5920:
            return A(e2, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(a2, c2, n3, t3, s2, i2, u2) {
              return r + c2 + ":" + n3 + u2 + (t3 ? r + c2 + "-span:" + (s2 ? i2 : +i2 - +n3) + u2 : "") + e2;
            });
          case 4949:
            if (M(e2, n2 + 6) === 121)
              return A(e2, ":", ":" + c) + e2;
            break;
          case 6444:
            switch (M(e2, M(e2, 14) === 45 ? 18 : 11)) {
              case 120:
                return A(e2, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + c + (M(e2, 14) === 45 ? "inline-" : "") + "box$3$1" + c + "$2$3$1" + r + "$2box$3") + e2;
              case 100:
                return A(e2, ":", ":" + r) + e2;
            }
            break;
          case 5719:
          case 2647:
          case 2135:
          case 3927:
          case 2391:
            return A(e2, "scroll-", "scroll-snap-") + e2;
        }
        return e2;
      }
      function te(e2, r2) {
        var a2 = "";
        var c2 = S(e2);
        for (var n2 = 0; n2 < c2; n2++)
          a2 += r2(e2[n2], n2, e2, r2) || "";
        return a2;
      }
      function se(e2, r2, a2, c2) {
        switch (e2.type) {
          case g:
            if (e2.children.length)
              break;
          case o:
          case s:
            return e2.return = e2.return || e2.value;
          case n:
            return "";
          case d:
            return e2.return = e2.value + "{" + te(e2.children, c2) + "}";
          case t:
            e2.value = e2.props.join(",");
        }
        return R(a2 = te(e2.children, c2)) ? e2.return = e2.value + "{" + a2 + "}" : "";
      }
      function ie(e2) {
        var r2 = S(e2);
        return function(a2, c2, n2, t2) {
          var s2 = "";
          for (var i2 = 0; i2 < r2; i2++)
            s2 += e2[i2](a2, c2, n2, t2) || "";
          return s2;
        };
      }
      function ue(e2) {
        return function(r2) {
          if (!r2.root) {
            if (r2 = r2.return)
              e2(r2);
          }
        };
      }
      function oe(e2, n2, i2, u2) {
        if (e2.length > -1) {
          if (!e2.return)
            switch (e2.type) {
              case s:
                e2.return = ne(e2.value, e2.length, i2);
                return;
              case d:
                return te([j(e2, { value: A(e2.value, "@", "@" + c) })], u2);
              case t:
                if (e2.length)
                  return N(e2.props, function(n3) {
                    switch (T(n3, /(::plac\w+|:read-\w+)/)) {
                      case ":read-only":
                      case ":read-write":
                        return te([j(e2, { props: [A(n3, /:(read-\w+)/, ":" + a + "$1")] })], u2);
                      case "::placeholder":
                        return te([j(e2, { props: [A(n3, /:(plac\w+)/, ":" + c + "input-$1")] }), j(e2, { props: [A(n3, /:(plac\w+)/, ":" + a + "$1")] }), j(e2, { props: [A(n3, /:(plac\w+)/, r + "input-$1")] })], u2);
                    }
                    return "";
                  });
            }
        }
      }
      function fe(e2) {
        switch (e2.type) {
          case t:
            e2.props = e2.props.map(function(r2) {
              return N(B(r2), function(r3, a2, c2) {
                switch (M(r3, 0)) {
                  case 12:
                    return C(r3, 1, R(r3));
                  case 0:
                  case 40:
                  case 43:
                  case 62:
                  case 126:
                    return r3;
                  case 58:
                    if (c2[++a2] === "global")
                      c2[a2] = "", c2[++a2] = "\f" + C(c2[a2], a2 = 1, -1);
                  case 32:
                    return a2 === 1 ? "" : r3;
                  default:
                    switch (a2) {
                      case 0:
                        e2 = r3;
                        return S(c2) > 1 ? "" : r3;
                      case (a2 = S(c2) - 1):
                      case 2:
                        return a2 === 2 ? r3 + e2 + e2 : r3 + e2;
                      default:
                        return r3;
                    }
                }
              });
            });
        }
      }
      e.CHARSET = f;
      e.COMMENT = n;
      e.COUNTER_STYLE = w;
      e.DECLARATION = s;
      e.DOCUMENT = h;
      e.FONT_FACE = b;
      e.FONT_FEATURE_VALUES = m;
      e.IMPORT = o;
      e.KEYFRAMES = d;
      e.LAYER = g;
      e.MEDIA = u;
      e.MOZ = a;
      e.MS = r;
      e.NAMESPACE = v;
      e.PAGE = i;
      e.RULESET = t;
      e.SUPPORTS = p;
      e.VIEWPORT = l;
      e.WEBKIT = c;
      e.abs = k;
      e.alloc = K;
      e.append = z;
      e.assign = x;
      e.caret = L;
      e.char = U;
      e.charat = M;
      e.combine = N;
      e.comment = ae;
      e.commenter = J;
      e.compile = X;
      e.copy = j;
      e.dealloc = V;
      e.declaration = ce;
      e.delimit = W;
      e.delimiter = q;
      e.escaping = Z;
      e.from = $;
      e.hash = E;
      e.identifier = Q;
      e.indexof = O;
      e.match = T;
      e.middleware = ie;
      e.namespace = fe;
      e.next = F;
      e.node = P;
      e.parse = ee;
      e.peek = I;
      e.prefix = ne;
      e.prefixer = oe;
      e.prev = _;
      e.replace = A;
      e.ruleset = re;
      e.rulesheet = ue;
      e.serialize = te;
      e.sizeof = S;
      e.slice = D;
      e.stringify = se;
      e.strlen = R;
      e.substr = C;
      e.token = Y;
      e.tokenize = B;
      e.tokenizer = H;
      e.trim = y;
      e.whitespace = G;
      Object.defineProperty(e, "__esModule", { value: true });
    });
  }
});

// ../../node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.cjs.dev.js
var require_emotion_weak_memoize_cjs_dev = __commonJS({
  "../../node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var weakMemoize = function weakMemoize2(func) {
      var cache = /* @__PURE__ */ new WeakMap();
      return function(arg) {
        if (cache.has(arg)) {
          return cache.get(arg);
        }
        var ret = func(arg);
        cache.set(arg, ret);
        return ret;
      };
    };
    exports["default"] = weakMemoize;
  }
});

// ../../node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.cjs.js
var require_emotion_weak_memoize_cjs = __commonJS({
  "../../node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.cjs.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_emotion_weak_memoize_cjs_dev();
    }
  }
});

// ../../node_modules/@emotion/memoize/dist/emotion-memoize.cjs.dev.js
var require_emotion_memoize_cjs_dev = __commonJS({
  "../../node_modules/@emotion/memoize/dist/emotion-memoize.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function memoize(fn) {
      var cache = /* @__PURE__ */ Object.create(null);
      return function(arg) {
        if (cache[arg] === void 0)
          cache[arg] = fn(arg);
        return cache[arg];
      };
    }
    exports["default"] = memoize;
  }
});

// ../../node_modules/@emotion/memoize/dist/emotion-memoize.cjs.js
var require_emotion_memoize_cjs = __commonJS({
  "../../node_modules/@emotion/memoize/dist/emotion-memoize.cjs.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_emotion_memoize_cjs_dev();
    }
  }
});

// ../../node_modules/@emotion/cache/dist/emotion-cache.cjs.dev.js
var require_emotion_cache_cjs_dev = __commonJS({
  "../../node_modules/@emotion/cache/dist/emotion-cache.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sheet = require_emotion_sheet_cjs();
    var stylis = require_stylis();
    var weakMemoize = require_emotion_weak_memoize_cjs();
    var memoize = require_emotion_memoize_cjs();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var weakMemoize__default = _interopDefault(weakMemoize);
    var memoize__default = _interopDefault(memoize);
    var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
      var previous = 0;
      var character = 0;
      while (true) {
        previous = character;
        character = stylis.peek();
        if (previous === 38 && character === 12) {
          points[index] = 1;
        }
        if (stylis.token(character)) {
          break;
        }
        stylis.next();
      }
      return stylis.slice(begin, stylis.position);
    };
    var toRules = function toRules2(parsed, points) {
      var index = -1;
      var character = 44;
      do {
        switch (stylis.token(character)) {
          case 0:
            if (character === 38 && stylis.peek() === 12) {
              points[index] = 1;
            }
            parsed[index] += identifierWithPointTracking(stylis.position - 1, points, index);
            break;
          case 2:
            parsed[index] += stylis.delimit(character);
            break;
          case 4:
            if (character === 44) {
              parsed[++index] = stylis.peek() === 58 ? "&\f" : "";
              points[index] = parsed[index].length;
              break;
            }
          default:
            parsed[index] += stylis.from(character);
        }
      } while (character = stylis.next());
      return parsed;
    };
    var getRules = function getRules2(value, points) {
      return stylis.dealloc(toRules(stylis.alloc(value), points));
    };
    var fixedElements = /* @__PURE__ */ new WeakMap();
    var compat = function compat2(element) {
      if (element.type !== "rule" || !element.parent || element.length < 1) {
        return;
      }
      var value = element.value, parent = element.parent;
      var isImplicitRule = element.column === parent.column && element.line === parent.line;
      while (parent.type !== "rule") {
        parent = parent.parent;
        if (!parent)
          return;
      }
      if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
        return;
      }
      if (isImplicitRule) {
        return;
      }
      fixedElements.set(element, true);
      var points = [];
      var rules = getRules(value, points);
      var parentRules = parent.props;
      for (var i = 0, k = 0; i < rules.length; i++) {
        for (var j = 0; j < parentRules.length; j++, k++) {
          element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
        }
      }
    };
    var removeLabel = function removeLabel2(element) {
      if (element.type === "decl") {
        var value = element.value;
        if (value.charCodeAt(0) === 108 && value.charCodeAt(2) === 98) {
          element["return"] = "";
          element.value = "";
        }
      }
    };
    var ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
    var isIgnoringComment = function isIgnoringComment2(element) {
      return element.type === "comm" && element.children.indexOf(ignoreFlag) > -1;
    };
    var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm2(cache) {
      return function(element, index, children) {
        if (element.type !== "rule" || cache.compat)
          return;
        var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
        if (unsafePseudoClasses) {
          var isNested = !!element.parent;
          var commentContainer = isNested ? element.parent.children : children;
          for (var i = commentContainer.length - 1; i >= 0; i--) {
            var node = commentContainer[i];
            if (node.line < element.line) {
              break;
            }
            if (node.column < element.column) {
              if (isIgnoringComment(node)) {
                return;
              }
              break;
            }
          }
          unsafePseudoClasses.forEach(function(unsafePseudoClass) {
            console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
          });
        }
      };
    };
    var isImportRule = function isImportRule2(element) {
      return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
    };
    var isPrependedWithRegularRules = function isPrependedWithRegularRules2(index, children) {
      for (var i = index - 1; i >= 0; i--) {
        if (!isImportRule(children[i])) {
          return true;
        }
      }
      return false;
    };
    var nullifyElement = function nullifyElement2(element) {
      element.type = "";
      element.value = "";
      element["return"] = "";
      element.children = "";
      element.props = "";
    };
    var incorrectImportAlarm = function incorrectImportAlarm2(element, index, children) {
      if (!isImportRule(element)) {
        return;
      }
      if (element.parent) {
        console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
        nullifyElement(element);
      } else if (isPrependedWithRegularRules(index, children)) {
        console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
        nullifyElement(element);
      }
    };
    function prefix(value, length) {
      switch (stylis.hash(value, length)) {
        case 5103:
          return stylis.WEBKIT + "print-" + value + value;
        case 5737:
        case 4201:
        case 3177:
        case 3433:
        case 1641:
        case 4457:
        case 2921:
        case 5572:
        case 6356:
        case 5844:
        case 3191:
        case 6645:
        case 3005:
        case 6391:
        case 5879:
        case 5623:
        case 6135:
        case 4599:
        case 4855:
        case 4215:
        case 6389:
        case 5109:
        case 5365:
        case 5621:
        case 3829:
          return stylis.WEBKIT + value + value;
        case 5349:
        case 4246:
        case 4810:
        case 6968:
        case 2756:
          return stylis.WEBKIT + value + stylis.MOZ + value + stylis.MS + value + value;
        case 6828:
        case 4268:
          return stylis.WEBKIT + value + stylis.MS + value + value;
        case 6165:
          return stylis.WEBKIT + value + stylis.MS + "flex-" + value + value;
        case 5187:
          return stylis.WEBKIT + value + stylis.replace(value, /(\w+).+(:[^]+)/, stylis.WEBKIT + "box-$1$2" + stylis.MS + "flex-$1$2") + value;
        case 5443:
          return stylis.WEBKIT + value + stylis.MS + "flex-item-" + stylis.replace(value, /flex-|-self/, "") + value;
        case 4675:
          return stylis.WEBKIT + value + stylis.MS + "flex-line-pack" + stylis.replace(value, /align-content|flex-|-self/, "") + value;
        case 5548:
          return stylis.WEBKIT + value + stylis.MS + stylis.replace(value, "shrink", "negative") + value;
        case 5292:
          return stylis.WEBKIT + value + stylis.MS + stylis.replace(value, "basis", "preferred-size") + value;
        case 6060:
          return stylis.WEBKIT + "box-" + stylis.replace(value, "-grow", "") + stylis.WEBKIT + value + stylis.MS + stylis.replace(value, "grow", "positive") + value;
        case 4554:
          return stylis.WEBKIT + stylis.replace(value, /([^-])(transform)/g, "$1" + stylis.WEBKIT + "$2") + value;
        case 6187:
          return stylis.replace(stylis.replace(stylis.replace(value, /(zoom-|grab)/, stylis.WEBKIT + "$1"), /(image-set)/, stylis.WEBKIT + "$1"), value, "") + value;
        case 5495:
        case 3959:
          return stylis.replace(value, /(image-set\([^]*)/, stylis.WEBKIT + "$1$`$1");
        case 4968:
          return stylis.replace(stylis.replace(value, /(.+:)(flex-)?(.*)/, stylis.WEBKIT + "box-pack:$3" + stylis.MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + stylis.WEBKIT + value + value;
        case 4095:
        case 3583:
        case 4068:
        case 2532:
          return stylis.replace(value, /(.+)-inline(.+)/, stylis.WEBKIT + "$1$2") + value;
        case 8116:
        case 7059:
        case 5753:
        case 5535:
        case 5445:
        case 5701:
        case 4933:
        case 4677:
        case 5533:
        case 5789:
        case 5021:
        case 4765:
          if (stylis.strlen(value) - 1 - length > 6)
            switch (stylis.charat(value, length + 1)) {
              case 109:
                if (stylis.charat(value, length + 4) !== 45)
                  break;
              case 102:
                return stylis.replace(value, /(.+:)(.+)-([^]+)/, "$1" + stylis.WEBKIT + "$2-$3$1" + stylis.MOZ + (stylis.charat(value, length + 3) == 108 ? "$3" : "$2-$3")) + value;
              case 115:
                return ~stylis.indexof(value, "stretch") ? prefix(stylis.replace(value, "stretch", "fill-available"), length) + value : value;
            }
          break;
        case 4949:
          if (stylis.charat(value, length + 1) !== 115)
            break;
        case 6444:
          switch (stylis.charat(value, stylis.strlen(value) - 3 - (~stylis.indexof(value, "!important") && 10))) {
            case 107:
              return stylis.replace(value, ":", ":" + stylis.WEBKIT) + value;
            case 101:
              return stylis.replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + stylis.WEBKIT + (stylis.charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + stylis.WEBKIT + "$2$3$1" + stylis.MS + "$2box$3") + value;
          }
          break;
        case 5936:
          switch (stylis.charat(value, length + 11)) {
            case 114:
              return stylis.WEBKIT + value + stylis.MS + stylis.replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
            case 108:
              return stylis.WEBKIT + value + stylis.MS + stylis.replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
            case 45:
              return stylis.WEBKIT + value + stylis.MS + stylis.replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
          }
          return stylis.WEBKIT + value + stylis.MS + value + value;
      }
      return value;
    }
    var prefixer = function prefixer2(element, index, children, callback) {
      if (element.length > -1) {
        if (!element["return"])
          switch (element.type) {
            case stylis.DECLARATION:
              element["return"] = prefix(element.value, element.length);
              break;
            case stylis.KEYFRAMES:
              return stylis.serialize([stylis.copy(element, {
                value: stylis.replace(element.value, "@", "@" + stylis.WEBKIT)
              })], callback);
            case stylis.RULESET:
              if (element.length)
                return stylis.combine(element.props, function(value) {
                  switch (stylis.match(value, /(::plac\w+|:read-\w+)/)) {
                    case ":read-only":
                    case ":read-write":
                      return stylis.serialize([stylis.copy(element, {
                        props: [stylis.replace(value, /:(read-\w+)/, ":" + stylis.MOZ + "$1")]
                      })], callback);
                    case "::placeholder":
                      return stylis.serialize([stylis.copy(element, {
                        props: [stylis.replace(value, /:(plac\w+)/, ":" + stylis.WEBKIT + "input-$1")]
                      }), stylis.copy(element, {
                        props: [stylis.replace(value, /:(plac\w+)/, ":" + stylis.MOZ + "$1")]
                      }), stylis.copy(element, {
                        props: [stylis.replace(value, /:(plac\w+)/, stylis.MS + "input-$1")]
                      })], callback);
                  }
                  return "";
                });
          }
      }
    };
    var isBrowser = typeof document !== "undefined";
    var getServerStylisCache = isBrowser ? void 0 : weakMemoize__default["default"](function() {
      return memoize__default["default"](function() {
        var cache = {};
        return function(name) {
          return cache[name];
        };
      });
    });
    var defaultStylisPlugins = [prefixer];
    var createCache = function createCache2(options) {
      var key = options.key;
      if (!key) {
        throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
      }
      if (isBrowser && key === "css") {
        var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
        Array.prototype.forEach.call(ssrStyles, function(node) {
          var dataEmotionAttribute = node.getAttribute("data-emotion");
          if (dataEmotionAttribute.indexOf(" ") === -1) {
            return;
          }
          document.head.appendChild(node);
          node.setAttribute("data-s", "");
        });
      }
      var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
      if (true) {
        if (/[^a-z-]/.test(key)) {
          throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
        }
      }
      var inserted = {};
      var container;
      var nodesToHydrate = [];
      if (isBrowser) {
        container = options.container || document.head;
        Array.prototype.forEach.call(
          document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
          function(node) {
            var attrib = node.getAttribute("data-emotion").split(" ");
            for (var i = 1; i < attrib.length; i++) {
              inserted[attrib[i]] = true;
            }
            nodesToHydrate.push(node);
          }
        );
      }
      var _insert;
      var omnipresentPlugins = [compat, removeLabel];
      if (true) {
        omnipresentPlugins.push(createUnsafeSelectorsAlarm({
          get compat() {
            return cache.compat;
          }
        }), incorrectImportAlarm);
      }
      if (isBrowser) {
        var currentSheet;
        var finalizingPlugins = [stylis.stringify, true ? function(element) {
          if (!element.root) {
            if (element["return"]) {
              currentSheet.insert(element["return"]);
            } else if (element.value && element.type !== stylis.COMMENT) {
              currentSheet.insert(element.value + "{}");
            }
          }
        } : stylis.rulesheet(function(rule) {
          currentSheet.insert(rule);
        })];
        var serializer = stylis.middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
        var stylis$1 = function stylis$12(styles) {
          return stylis.serialize(stylis.compile(styles), serializer);
        };
        _insert = function insert(selector, serialized, sheet2, shouldCache) {
          currentSheet = sheet2;
          if (serialized.map !== void 0) {
            currentSheet = {
              insert: function insert2(rule) {
                sheet2.insert(rule + serialized.map);
              }
            };
          }
          stylis$1(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
          if (shouldCache) {
            cache.inserted[serialized.name] = true;
          }
        };
      } else {
        var _finalizingPlugins = [stylis.stringify];
        var _serializer = stylis.middleware(omnipresentPlugins.concat(stylisPlugins, _finalizingPlugins));
        var _stylis = function _stylis2(styles) {
          return stylis.serialize(stylis.compile(styles), _serializer);
        };
        var serverStylisCache = getServerStylisCache(stylisPlugins)(key);
        var getRules2 = function getRules3(selector, serialized) {
          var name = serialized.name;
          if (serverStylisCache[name] === void 0) {
            serverStylisCache[name] = _stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
          }
          return serverStylisCache[name];
        };
        _insert = function _insert2(selector, serialized, sheet2, shouldCache) {
          var name = serialized.name;
          var rules = getRules2(selector, serialized);
          if (cache.compat === void 0) {
            if (shouldCache) {
              cache.inserted[name] = true;
            }
            if (serialized.map !== void 0) {
              return rules + serialized.map;
            }
            return rules;
          } else {
            if (shouldCache) {
              cache.inserted[name] = rules;
            } else {
              return rules;
            }
          }
        };
      }
      var cache = {
        key,
        sheet: new sheet.StyleSheet({
          key,
          container,
          nonce: options.nonce,
          speedy: options.speedy,
          prepend: options.prepend,
          insertionPoint: options.insertionPoint
        }),
        nonce: options.nonce,
        inserted,
        registered: {},
        insert: _insert
      };
      cache.sheet.hydrate(nodesToHydrate);
      return cache;
    };
    exports["default"] = createCache;
  }
});

// ../../node_modules/@emotion/cache/dist/emotion-cache.cjs.js
var require_emotion_cache_cjs = __commonJS({
  "../../node_modules/@emotion/cache/dist/emotion-cache.cjs.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_emotion_cache_cjs_dev();
    }
  }
});

// ../../node_modules/@emotion/react/node_modules/@babel/runtime/helpers/extends.js
var require_extends = __commonJS({
  "../../node_modules/@emotion/react/node_modules/@babel/runtime/helpers/extends.js"(exports, module) {
    function _extends() {
      module.exports = _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _extends.apply(this, arguments);
    }
    module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.dev.js
var require_emotion_react_isolated_hnrs_cjs_dev = __commonJS({
  "../../node_modules/@emotion/react/_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var hoistNonReactStatics$1 = require_hoist_non_react_statics_cjs();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var hoistNonReactStatics__default = _interopDefault(hoistNonReactStatics$1);
    var hoistNonReactStatics = function(targetComponent, sourceComponent) {
      return hoistNonReactStatics__default["default"](targetComponent, sourceComponent);
    };
    exports["default"] = hoistNonReactStatics;
  }
});

// ../../node_modules/@emotion/utils/dist/emotion-utils.cjs.dev.js
var require_emotion_utils_cjs_dev = __commonJS({
  "../../node_modules/@emotion/utils/dist/emotion-utils.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var isBrowser = typeof document !== "undefined";
    function getRegisteredStyles(registered, registeredStyles, classNames) {
      var rawClassName = "";
      classNames.split(" ").forEach(function(className) {
        if (registered[className] !== void 0) {
          registeredStyles.push(registered[className] + ";");
        } else {
          rawClassName += className + " ";
        }
      });
      return rawClassName;
    }
    var registerStyles = function registerStyles2(cache, serialized, isStringTag) {
      var className = cache.key + "-" + serialized.name;
      if ((isStringTag === false || isBrowser === false && cache.compat !== void 0) && cache.registered[className] === void 0) {
        cache.registered[className] = serialized.styles;
      }
    };
    var insertStyles = function insertStyles2(cache, serialized, isStringTag) {
      registerStyles(cache, serialized, isStringTag);
      var className = cache.key + "-" + serialized.name;
      if (cache.inserted[serialized.name] === void 0) {
        var stylesForSSR = "";
        var current = serialized;
        do {
          var maybeStyles = cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
          if (!isBrowser && maybeStyles !== void 0) {
            stylesForSSR += maybeStyles;
          }
          current = current.next;
        } while (current !== void 0);
        if (!isBrowser && stylesForSSR.length !== 0) {
          return stylesForSSR;
        }
      }
    };
    exports.getRegisteredStyles = getRegisteredStyles;
    exports.insertStyles = insertStyles;
    exports.registerStyles = registerStyles;
  }
});

// ../../node_modules/@emotion/utils/dist/emotion-utils.cjs.js
var require_emotion_utils_cjs = __commonJS({
  "../../node_modules/@emotion/utils/dist/emotion-utils.cjs.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_emotion_utils_cjs_dev();
    }
  }
});

// ../../node_modules/@emotion/hash/dist/emotion-hash.cjs.dev.js
var require_emotion_hash_cjs_dev = __commonJS({
  "../../node_modules/@emotion/hash/dist/emotion-hash.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function murmur2(str) {
      var h = 0;
      var k, i = 0, len = str.length;
      for (; len >= 4; ++i, len -= 4) {
        k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
        k = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
        k ^= k >>> 24;
        h = (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
      }
      switch (len) {
        case 3:
          h ^= (str.charCodeAt(i + 2) & 255) << 16;
        case 2:
          h ^= (str.charCodeAt(i + 1) & 255) << 8;
        case 1:
          h ^= str.charCodeAt(i) & 255;
          h = (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
      }
      h ^= h >>> 13;
      h = (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
      return ((h ^ h >>> 15) >>> 0).toString(36);
    }
    exports["default"] = murmur2;
  }
});

// ../../node_modules/@emotion/hash/dist/emotion-hash.cjs.js
var require_emotion_hash_cjs = __commonJS({
  "../../node_modules/@emotion/hash/dist/emotion-hash.cjs.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_emotion_hash_cjs_dev();
    }
  }
});

// ../../node_modules/@emotion/unitless/dist/emotion-unitless.cjs.dev.js
var require_emotion_unitless_cjs_dev = __commonJS({
  "../../node_modules/@emotion/unitless/dist/emotion-unitless.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var unitlessKeys = {
      animationIterationCount: 1,
      aspectRatio: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    };
    exports["default"] = unitlessKeys;
  }
});

// ../../node_modules/@emotion/unitless/dist/emotion-unitless.cjs.js
var require_emotion_unitless_cjs = __commonJS({
  "../../node_modules/@emotion/unitless/dist/emotion-unitless.cjs.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_emotion_unitless_cjs_dev();
    }
  }
});

// ../../node_modules/@emotion/serialize/dist/emotion-serialize.cjs.dev.js
var require_emotion_serialize_cjs_dev = __commonJS({
  "../../node_modules/@emotion/serialize/dist/emotion-serialize.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var hashString = require_emotion_hash_cjs();
    var unitless = require_emotion_unitless_cjs();
    var memoize = require_emotion_memoize_cjs();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var hashString__default = _interopDefault(hashString);
    var unitless__default = _interopDefault(unitless);
    var memoize__default = _interopDefault(memoize);
    var ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
    var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
    var hyphenateRegex = /[A-Z]|^ms/g;
    var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
    var isCustomProperty = function isCustomProperty2(property) {
      return property.charCodeAt(1) === 45;
    };
    var isProcessableValue = function isProcessableValue2(value) {
      return value != null && typeof value !== "boolean";
    };
    var processStyleName = memoize__default["default"](function(styleName) {
      return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
    });
    var processStyleValue = function processStyleValue2(key, value) {
      switch (key) {
        case "animation":
        case "animationName": {
          if (typeof value === "string") {
            return value.replace(animationRegex, function(match, p1, p2) {
              cursor = {
                name: p1,
                styles: p2,
                next: cursor
              };
              return p1;
            });
          }
        }
      }
      if (unitless__default["default"][key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
        return value + "px";
      }
      return value;
    };
    if (true) {
      contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
      contentValues = ["normal", "none", "initial", "inherit", "unset"];
      oldProcessStyleValue = processStyleValue;
      msPattern = /^-ms-/;
      hyphenPattern = /-(.)/g;
      hyphenatedCache = {};
      processStyleValue = function processStyleValue2(key, value) {
        if (key === "content") {
          if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) {
            throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
          }
        }
        var processed = oldProcessStyleValue(key, value);
        if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === void 0) {
          hyphenatedCache[key] = true;
          console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
            return _char.toUpperCase();
          }) + "?");
        }
        return processed;
      };
    }
    var contentValuePattern;
    var contentValues;
    var oldProcessStyleValue;
    var msPattern;
    var hyphenPattern;
    var hyphenatedCache;
    var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
    function handleInterpolation(mergedProps, registered, interpolation) {
      if (interpolation == null) {
        return "";
      }
      if (interpolation.__emotion_styles !== void 0) {
        if (interpolation.toString() === "NO_COMPONENT_SELECTOR") {
          throw new Error(noComponentSelectorMessage);
        }
        return interpolation;
      }
      switch (typeof interpolation) {
        case "boolean": {
          return "";
        }
        case "object": {
          if (interpolation.anim === 1) {
            cursor = {
              name: interpolation.name,
              styles: interpolation.styles,
              next: cursor
            };
            return interpolation.name;
          }
          if (interpolation.styles !== void 0) {
            var next = interpolation.next;
            if (next !== void 0) {
              while (next !== void 0) {
                cursor = {
                  name: next.name,
                  styles: next.styles,
                  next: cursor
                };
                next = next.next;
              }
            }
            var styles = interpolation.styles + ";";
            if (interpolation.map !== void 0) {
              styles += interpolation.map;
            }
            return styles;
          }
          return createStringFromObject(mergedProps, registered, interpolation);
        }
        case "function": {
          if (mergedProps !== void 0) {
            var previousCursor = cursor;
            var result = interpolation(mergedProps);
            cursor = previousCursor;
            return handleInterpolation(mergedProps, registered, result);
          } else if (true) {
            console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
          }
          break;
        }
        case "string":
          if (true) {
            var matched = [];
            var replaced = interpolation.replace(animationRegex, function(match, p1, p2) {
              var fakeVarName = "animation" + matched.length;
              matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, "") + "`");
              return "${" + fakeVarName + "}";
            });
            if (matched.length) {
              console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, ["`" + replaced + "`"]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\n" + ("css`" + replaced + "`"));
            }
          }
          break;
      }
      if (registered == null) {
        return interpolation;
      }
      var cached = registered[interpolation];
      return cached !== void 0 ? cached : interpolation;
    }
    function createStringFromObject(mergedProps, registered, obj) {
      var string = "";
      if (Array.isArray(obj)) {
        for (var i = 0; i < obj.length; i++) {
          string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
        }
      } else {
        for (var _key in obj) {
          var value = obj[_key];
          if (typeof value !== "object") {
            if (registered != null && registered[value] !== void 0) {
              string += _key + "{" + registered[value] + "}";
            } else if (isProcessableValue(value)) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
            }
          } else {
            if (_key === "NO_COMPONENT_SELECTOR" && true) {
              throw new Error(noComponentSelectorMessage);
            }
            if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
              for (var _i = 0; _i < value.length; _i++) {
                if (isProcessableValue(value[_i])) {
                  string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
                }
              }
            } else {
              var interpolated = handleInterpolation(mergedProps, registered, value);
              switch (_key) {
                case "animation":
                case "animationName": {
                  string += processStyleName(_key) + ":" + interpolated + ";";
                  break;
                }
                default: {
                  if (_key === "undefined") {
                    console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
                  }
                  string += _key + "{" + interpolated + "}";
                }
              }
            }
          }
        }
      }
      return string;
    }
    var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
    var sourceMapPattern;
    if (true) {
      sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
    }
    var cursor;
    var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
      if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
        return args[0];
      }
      var stringMode = true;
      var styles = "";
      cursor = void 0;
      var strings = args[0];
      if (strings == null || strings.raw === void 0) {
        stringMode = false;
        styles += handleInterpolation(mergedProps, registered, strings);
      } else {
        if (strings[0] === void 0) {
          console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
        }
        styles += strings[0];
      }
      for (var i = 1; i < args.length; i++) {
        styles += handleInterpolation(mergedProps, registered, args[i]);
        if (stringMode) {
          if (strings[i] === void 0) {
            console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
          }
          styles += strings[i];
        }
      }
      var sourceMap;
      if (true) {
        styles = styles.replace(sourceMapPattern, function(match2) {
          sourceMap = match2;
          return "";
        });
      }
      labelPattern.lastIndex = 0;
      var identifierName = "";
      var match;
      while ((match = labelPattern.exec(styles)) !== null) {
        identifierName += "-" + match[1];
      }
      var name = hashString__default["default"](styles) + identifierName;
      if (true) {
        return {
          name,
          styles,
          map: sourceMap,
          next: cursor,
          toString: function toString() {
            return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
          }
        };
      }
      return {
        name,
        styles,
        next: cursor
      };
    };
    exports.serializeStyles = serializeStyles;
  }
});

// ../../node_modules/@emotion/serialize/dist/emotion-serialize.cjs.js
var require_emotion_serialize_cjs = __commonJS({
  "../../node_modules/@emotion/serialize/dist/emotion-serialize.cjs.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_emotion_serialize_cjs_dev();
    }
  }
});

// ../../node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.cjs.dev.js
var require_emotion_use_insertion_effect_with_fallbacks_cjs_dev = __commonJS({
  "../../node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespace(React);
    var isBrowser = typeof document !== "undefined";
    var syncFallback = function syncFallback2(create) {
      return create();
    };
    var useInsertionEffect = React__namespace["useInsertionEffect"] ? React__namespace["useInsertionEffect"] : false;
    var useInsertionEffectAlwaysWithSyncFallback = !isBrowser ? syncFallback : useInsertionEffect || syncFallback;
    var useInsertionEffectWithLayoutFallback = useInsertionEffect || React__namespace.useLayoutEffect;
    exports.useInsertionEffectAlwaysWithSyncFallback = useInsertionEffectAlwaysWithSyncFallback;
    exports.useInsertionEffectWithLayoutFallback = useInsertionEffectWithLayoutFallback;
  }
});

// ../../node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.cjs.js
var require_emotion_use_insertion_effect_with_fallbacks_cjs = __commonJS({
  "../../node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.cjs.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_emotion_use_insertion_effect_with_fallbacks_cjs_dev();
    }
  }
});

// ../../node_modules/@emotion/react/dist/emotion-element-48d2c2e4.cjs.dev.js
var require_emotion_element_48d2c2e4_cjs_dev = __commonJS({
  "../../node_modules/@emotion/react/dist/emotion-element-48d2c2e4.cjs.dev.js"(exports) {
    "use strict";
    var React = require_react();
    var createCache = require_emotion_cache_cjs();
    var _extends = require_extends();
    var weakMemoize = require_emotion_weak_memoize_cjs();
    var _isolatedHnrs_dist_emotionReact_isolatedHnrs = require_emotion_react_isolated_hnrs_cjs_dev();
    var utils = require_emotion_utils_cjs();
    var serialize = require_emotion_serialize_cjs();
    var useInsertionEffectWithFallbacks = require_emotion_use_insertion_effect_with_fallbacks_cjs();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespace(React);
    var createCache__default = _interopDefault(createCache);
    var weakMemoize__default = _interopDefault(weakMemoize);
    var isBrowser = typeof document !== "undefined";
    var hasOwnProperty = {}.hasOwnProperty;
    var EmotionCacheContext = React__namespace.createContext(
      typeof HTMLElement !== "undefined" ? createCache__default["default"]({
        key: "css"
      }) : null
    );
    if (true) {
      EmotionCacheContext.displayName = "EmotionCacheContext";
    }
    var CacheProvider = EmotionCacheContext.Provider;
    var __unsafe_useEmotionCache = function useEmotionCache() {
      return React.useContext(EmotionCacheContext);
    };
    exports.withEmotionCache = function withEmotionCache(func) {
      return React.forwardRef(function(props, ref) {
        var cache = React.useContext(EmotionCacheContext);
        return func(props, cache, ref);
      });
    };
    if (!isBrowser) {
      exports.withEmotionCache = function withEmotionCache(func) {
        return function(props) {
          var cache = React.useContext(EmotionCacheContext);
          if (cache === null) {
            cache = createCache__default["default"]({
              key: "css"
            });
            return React__namespace.createElement(EmotionCacheContext.Provider, {
              value: cache
            }, func(props, cache));
          } else {
            return func(props, cache);
          }
        };
      };
    }
    var ThemeContext = React__namespace.createContext({});
    if (true) {
      ThemeContext.displayName = "EmotionThemeContext";
    }
    var useTheme = function useTheme2() {
      return React__namespace.useContext(ThemeContext);
    };
    var getTheme = function getTheme2(outerTheme, theme) {
      if (typeof theme === "function") {
        var mergedTheme = theme(outerTheme);
        if (mergedTheme == null || typeof mergedTheme !== "object" || Array.isArray(mergedTheme)) {
          throw new Error("[ThemeProvider] Please return an object from your theme function, i.e. theme={() => ({})}!");
        }
        return mergedTheme;
      }
      if (theme == null || typeof theme !== "object" || Array.isArray(theme)) {
        throw new Error("[ThemeProvider] Please make your theme prop a plain object");
      }
      return _extends({}, outerTheme, theme);
    };
    var createCacheWithTheme = weakMemoize__default["default"](function(outerTheme) {
      return weakMemoize__default["default"](function(theme) {
        return getTheme(outerTheme, theme);
      });
    });
    var ThemeProvider = function ThemeProvider2(props) {
      var theme = React__namespace.useContext(ThemeContext);
      if (props.theme !== theme) {
        theme = createCacheWithTheme(theme)(props.theme);
      }
      return React__namespace.createElement(ThemeContext.Provider, {
        value: theme
      }, props.children);
    };
    function withTheme(Component) {
      var componentName = Component.displayName || Component.name || "Component";
      var render = function render2(props, ref) {
        var theme = React__namespace.useContext(ThemeContext);
        return React__namespace.createElement(Component, _extends({
          theme,
          ref
        }, props));
      };
      var WithTheme = React__namespace.forwardRef(render);
      WithTheme.displayName = "WithTheme(" + componentName + ")";
      return _isolatedHnrs_dist_emotionReact_isolatedHnrs["default"](WithTheme, Component);
    }
    var getLastPart = function getLastPart2(functionName) {
      var parts = functionName.split(".");
      return parts[parts.length - 1];
    };
    var getFunctionNameFromStackTraceLine = function getFunctionNameFromStackTraceLine2(line) {
      var match = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(line);
      if (match)
        return getLastPart(match[1]);
      match = /^([A-Za-z0-9$.]+)@/.exec(line);
      if (match)
        return getLastPart(match[1]);
      return void 0;
    };
    var internalReactFunctionNames = /* @__PURE__ */ new Set(["renderWithHooks", "processChild", "finishClassComponent", "renderToString"]);
    var sanitizeIdentifier = function sanitizeIdentifier2(identifier) {
      return identifier.replace(/\$/g, "-");
    };
    var getLabelFromStackTrace = function getLabelFromStackTrace2(stackTrace) {
      if (!stackTrace)
        return void 0;
      var lines = stackTrace.split("\n");
      for (var i = 0; i < lines.length; i++) {
        var functionName = getFunctionNameFromStackTraceLine(lines[i]);
        if (!functionName)
          continue;
        if (internalReactFunctionNames.has(functionName))
          break;
        if (/^[A-Z]/.test(functionName))
          return sanitizeIdentifier(functionName);
      }
      return void 0;
    };
    var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
    var labelPropName = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__";
    var createEmotionProps = function createEmotionProps2(type, props) {
      if (typeof props.css === "string" && props.css.indexOf(":") !== -1) {
        throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + props.css + "`");
      }
      var newProps = {};
      for (var key in props) {
        if (hasOwnProperty.call(props, key)) {
          newProps[key] = props[key];
        }
      }
      newProps[typePropName] = type;
      if (!!props.css && (typeof props.css !== "object" || typeof props.css.name !== "string" || props.css.name.indexOf("-") === -1)) {
        var label = getLabelFromStackTrace(new Error().stack);
        if (label)
          newProps[labelPropName] = label;
      }
      return newProps;
    };
    var Insertion = function Insertion2(_ref) {
      var cache = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
      utils.registerStyles(cache, serialized, isStringTag);
      var rules = useInsertionEffectWithFallbacks.useInsertionEffectAlwaysWithSyncFallback(function() {
        return utils.insertStyles(cache, serialized, isStringTag);
      });
      if (!isBrowser && rules !== void 0) {
        var _ref2;
        var serializedNames = serialized.name;
        var next = serialized.next;
        while (next !== void 0) {
          serializedNames += " " + next.name;
          next = next.next;
        }
        return React__namespace.createElement("style", (_ref2 = {}, _ref2["data-emotion"] = cache.key + " " + serializedNames, _ref2.dangerouslySetInnerHTML = {
          __html: rules
        }, _ref2.nonce = cache.sheet.nonce, _ref2));
      }
      return null;
    };
    var Emotion = exports.withEmotionCache(function(props, cache, ref) {
      var cssProp = props.css;
      if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
        cssProp = cache.registered[cssProp];
      }
      var WrappedComponent = props[typePropName];
      var registeredStyles = [cssProp];
      var className = "";
      if (typeof props.className === "string") {
        className = utils.getRegisteredStyles(cache.registered, registeredStyles, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serialize.serializeStyles(registeredStyles, void 0, React__namespace.useContext(ThemeContext));
      if (serialized.name.indexOf("-") === -1) {
        var labelFromStack = props[labelPropName];
        if (labelFromStack) {
          serialized = serialize.serializeStyles([serialized, "label:" + labelFromStack + ";"]);
        }
      }
      className += cache.key + "-" + serialized.name;
      var newProps = {};
      for (var key in props) {
        if (hasOwnProperty.call(props, key) && key !== "css" && key !== typePropName && key !== labelPropName) {
          newProps[key] = props[key];
        }
      }
      newProps.ref = ref;
      newProps.className = className;
      return React__namespace.createElement(React__namespace.Fragment, null, React__namespace.createElement(Insertion, {
        cache,
        serialized,
        isStringTag: typeof WrappedComponent === "string"
      }), React__namespace.createElement(WrappedComponent, newProps));
    });
    if (true) {
      Emotion.displayName = "EmotionCssPropInternal";
    }
    var Emotion$1 = Emotion;
    exports.CacheProvider = CacheProvider;
    exports.Emotion = Emotion$1;
    exports.ThemeContext = ThemeContext;
    exports.ThemeProvider = ThemeProvider;
    exports.__unsafe_useEmotionCache = __unsafe_useEmotionCache;
    exports.createEmotionProps = createEmotionProps;
    exports.hasOwnProperty = hasOwnProperty;
    exports.isBrowser = isBrowser;
    exports.useTheme = useTheme;
    exports.withTheme = withTheme;
  }
});

// ../../node_modules/@emotion/react/dist/emotion-react.cjs.dev.js
var require_emotion_react_cjs_dev = __commonJS({
  "../../node_modules/@emotion/react/dist/emotion-react.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var emotionElement = require_emotion_element_48d2c2e4_cjs_dev();
    var React = require_react();
    var utils = require_emotion_utils_cjs();
    var useInsertionEffectWithFallbacks = require_emotion_use_insertion_effect_with_fallbacks_cjs();
    var serialize = require_emotion_serialize_cjs();
    require_emotion_cache_cjs();
    require_extends();
    require_emotion_weak_memoize_cjs();
    require_emotion_react_isolated_hnrs_cjs_dev();
    require_hoist_non_react_statics_cjs();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespace(React);
    var pkg = {
      name: "@emotion/react",
      version: "11.11.0",
      main: "dist/emotion-react.cjs.js",
      module: "dist/emotion-react.esm.js",
      browser: {
        "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
      },
      exports: {
        ".": {
          module: {
            worker: "./dist/emotion-react.worker.esm.js",
            browser: "./dist/emotion-react.browser.esm.js",
            "default": "./dist/emotion-react.esm.js"
          },
          "import": "./dist/emotion-react.cjs.mjs",
          "default": "./dist/emotion-react.cjs.js"
        },
        "./jsx-runtime": {
          module: {
            worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
            browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
            "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
          },
          "import": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
          "default": "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
        },
        "./_isolated-hnrs": {
          module: {
            worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
            browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
            "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
          },
          "import": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
          "default": "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
        },
        "./jsx-dev-runtime": {
          module: {
            worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
            browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
            "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
          },
          "import": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
          "default": "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
        },
        "./package.json": "./package.json",
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": {
          types: {
            "import": "./macro.d.mts",
            "default": "./macro.d.ts"
          },
          "default": "./macro.js"
        }
      },
      types: "types/index.d.ts",
      files: [
        "src",
        "dist",
        "jsx-runtime",
        "jsx-dev-runtime",
        "_isolated-hnrs",
        "types/*.d.ts",
        "macro.*"
      ],
      sideEffects: false,
      author: "Emotion Contributors",
      license: "MIT",
      scripts: {
        "test:typescript": "dtslint types"
      },
      dependencies: {
        "@babel/runtime": "^7.18.3",
        "@emotion/babel-plugin": "^11.11.0",
        "@emotion/cache": "^11.11.0",
        "@emotion/serialize": "^1.1.2",
        "@emotion/use-insertion-effect-with-fallbacks": "^1.0.1",
        "@emotion/utils": "^1.2.1",
        "@emotion/weak-memoize": "^0.3.1",
        "hoist-non-react-statics": "^3.3.1"
      },
      peerDependencies: {
        react: ">=16.8.0"
      },
      peerDependenciesMeta: {
        "@types/react": {
          optional: true
        }
      },
      devDependencies: {
        "@definitelytyped/dtslint": "0.0.112",
        "@emotion/css": "11.11.0",
        "@emotion/css-prettifier": "1.1.3",
        "@emotion/server": "11.11.0",
        "@emotion/styled": "11.11.0",
        "html-tag-names": "^1.1.2",
        react: "16.14.0",
        "svg-tag-names": "^1.1.1",
        typescript: "^4.5.5"
      },
      repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
      publishConfig: {
        access: "public"
      },
      "umd:main": "dist/emotion-react.umd.min.js",
      preconstruct: {
        entrypoints: [
          "./index.js",
          "./jsx-runtime.js",
          "./jsx-dev-runtime.js",
          "./_isolated-hnrs.js"
        ],
        umdName: "emotionReact",
        exports: {
          envConditions: [
            "browser",
            "worker"
          ],
          extra: {
            "./types/css-prop": "./types/css-prop.d.ts",
            "./macro": {
              types: {
                "import": "./macro.d.mts",
                "default": "./macro.d.ts"
              },
              "default": "./macro.js"
            }
          }
        }
      }
    };
    var jsx = function jsx2(type, props) {
      var args = arguments;
      if (props == null || !emotionElement.hasOwnProperty.call(props, "css")) {
        return React__namespace.createElement.apply(void 0, args);
      }
      var argsLength = args.length;
      var createElementArgArray = new Array(argsLength);
      createElementArgArray[0] = emotionElement.Emotion;
      createElementArgArray[1] = emotionElement.createEmotionProps(type, props);
      for (var i = 2; i < argsLength; i++) {
        createElementArgArray[i] = args[i];
      }
      return React__namespace.createElement.apply(null, createElementArgArray);
    };
    var warnedAboutCssPropForGlobal = false;
    var Global = emotionElement.withEmotionCache(function(props, cache) {
      if (!warnedAboutCssPropForGlobal && (props.className || props.css)) {
        console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?");
        warnedAboutCssPropForGlobal = true;
      }
      var styles = props.styles;
      var serialized = serialize.serializeStyles([styles], void 0, React__namespace.useContext(emotionElement.ThemeContext));
      if (!emotionElement.isBrowser) {
        var _ref;
        var serializedNames = serialized.name;
        var serializedStyles = serialized.styles;
        var next = serialized.next;
        while (next !== void 0) {
          serializedNames += " " + next.name;
          serializedStyles += next.styles;
          next = next.next;
        }
        var shouldCache = cache.compat === true;
        var rules = cache.insert("", {
          name: serializedNames,
          styles: serializedStyles
        }, cache.sheet, shouldCache);
        if (shouldCache) {
          return null;
        }
        return React__namespace.createElement("style", (_ref = {}, _ref["data-emotion"] = cache.key + "-global " + serializedNames, _ref.dangerouslySetInnerHTML = {
          __html: rules
        }, _ref.nonce = cache.sheet.nonce, _ref));
      }
      var sheetRef = React__namespace.useRef();
      useInsertionEffectWithFallbacks.useInsertionEffectWithLayoutFallback(function() {
        var key = cache.key + "-global";
        var sheet = new cache.sheet.constructor({
          key,
          nonce: cache.sheet.nonce,
          container: cache.sheet.container,
          speedy: cache.sheet.isSpeedy
        });
        var rehydrating = false;
        var node = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
        if (cache.sheet.tags.length) {
          sheet.before = cache.sheet.tags[0];
        }
        if (node !== null) {
          rehydrating = true;
          node.setAttribute("data-emotion", key);
          sheet.hydrate([node]);
        }
        sheetRef.current = [sheet, rehydrating];
        return function() {
          sheet.flush();
        };
      }, [cache]);
      useInsertionEffectWithFallbacks.useInsertionEffectWithLayoutFallback(function() {
        var sheetRefCurrent = sheetRef.current;
        var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
        if (rehydrating) {
          sheetRefCurrent[1] = false;
          return;
        }
        if (serialized.next !== void 0) {
          utils.insertStyles(cache, serialized.next, true);
        }
        if (sheet.tags.length) {
          var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
          sheet.before = element;
          sheet.flush();
        }
        cache.insert("", serialized, sheet, false);
      }, [cache, serialized.name]);
      return null;
    });
    if (true) {
      Global.displayName = "EmotionGlobal";
    }
    function css() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return serialize.serializeStyles(args);
    }
    var keyframes2 = function keyframes3() {
      var insertable = css.apply(void 0, arguments);
      var name = "animation-" + insertable.name;
      return {
        name,
        styles: "@keyframes " + name + "{" + insertable.styles + "}",
        anim: 1,
        toString: function toString() {
          return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
        }
      };
    };
    var classnames = function classnames2(args) {
      var len = args.length;
      var i = 0;
      var cls = "";
      for (; i < len; i++) {
        var arg = args[i];
        if (arg == null)
          continue;
        var toAdd = void 0;
        switch (typeof arg) {
          case "boolean":
            break;
          case "object": {
            if (Array.isArray(arg)) {
              toAdd = classnames2(arg);
            } else {
              if (arg.styles !== void 0 && arg.name !== void 0) {
                console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component.");
              }
              toAdd = "";
              for (var k in arg) {
                if (arg[k] && k) {
                  toAdd && (toAdd += " ");
                  toAdd += k;
                }
              }
            }
            break;
          }
          default: {
            toAdd = arg;
          }
        }
        if (toAdd) {
          cls && (cls += " ");
          cls += toAdd;
        }
      }
      return cls;
    };
    function merge(registered, css2, className) {
      var registeredStyles = [];
      var rawClassName = utils.getRegisteredStyles(registered, registeredStyles, className);
      if (registeredStyles.length < 2) {
        return className;
      }
      return rawClassName + css2(registeredStyles);
    }
    var Insertion = function Insertion2(_ref) {
      var cache = _ref.cache, serializedArr = _ref.serializedArr;
      var rules = useInsertionEffectWithFallbacks.useInsertionEffectAlwaysWithSyncFallback(function() {
        var rules2 = "";
        for (var i = 0; i < serializedArr.length; i++) {
          var res = utils.insertStyles(cache, serializedArr[i], false);
          if (!emotionElement.isBrowser && res !== void 0) {
            rules2 += res;
          }
        }
        if (!emotionElement.isBrowser) {
          return rules2;
        }
      });
      if (!emotionElement.isBrowser && rules.length !== 0) {
        var _ref2;
        return React__namespace.createElement("style", (_ref2 = {}, _ref2["data-emotion"] = cache.key + " " + serializedArr.map(function(serialized) {
          return serialized.name;
        }).join(" "), _ref2.dangerouslySetInnerHTML = {
          __html: rules
        }, _ref2.nonce = cache.sheet.nonce, _ref2));
      }
      return null;
    };
    var ClassNames = emotionElement.withEmotionCache(function(props, cache) {
      var hasRendered = false;
      var serializedArr = [];
      var css2 = function css3() {
        if (hasRendered && true) {
          throw new Error("css can only be used during render");
        }
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var serialized = serialize.serializeStyles(args, cache.registered);
        serializedArr.push(serialized);
        utils.registerStyles(cache, serialized, false);
        return cache.key + "-" + serialized.name;
      };
      var cx = function cx2() {
        if (hasRendered && true) {
          throw new Error("cx can only be used during render");
        }
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return merge(cache.registered, css2, classnames(args));
      };
      var content = {
        css: css2,
        cx,
        theme: React__namespace.useContext(emotionElement.ThemeContext)
      };
      var ele = props.children(content);
      hasRendered = true;
      return React__namespace.createElement(React__namespace.Fragment, null, React__namespace.createElement(Insertion, {
        cache,
        serializedArr
      }), ele);
    });
    if (true) {
      ClassNames.displayName = "EmotionClassNames";
    }
    if (true) {
      isBrowser = typeof document !== "undefined";
      isTestEnv = typeof jest !== "undefined" || typeof vi !== "undefined";
      if (isBrowser && !isTestEnv) {
        globalContext = typeof globalThis !== "undefined" ? globalThis : isBrowser ? window : global;
        globalKey = "__EMOTION_REACT_" + pkg.version.split(".")[0] + "__";
        if (globalContext[globalKey]) {
          console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used.");
        }
        globalContext[globalKey] = true;
      }
    }
    var isBrowser;
    var isTestEnv;
    var globalContext;
    var globalKey;
    exports.CacheProvider = emotionElement.CacheProvider;
    exports.ThemeContext = emotionElement.ThemeContext;
    exports.ThemeProvider = emotionElement.ThemeProvider;
    exports.__unsafe_useEmotionCache = emotionElement.__unsafe_useEmotionCache;
    exports.useTheme = emotionElement.useTheme;
    Object.defineProperty(exports, "withEmotionCache", {
      enumerable: true,
      get: function() {
        return emotionElement.withEmotionCache;
      }
    });
    exports.withTheme = emotionElement.withTheme;
    exports.ClassNames = ClassNames;
    exports.Global = Global;
    exports.createElement = jsx;
    exports.css = css;
    exports.jsx = jsx;
    exports.keyframes = keyframes2;
  }
});

// ../../node_modules/@emotion/react/dist/emotion-react.cjs.js
var require_emotion_react_cjs = __commonJS({
  "../../node_modules/@emotion/react/dist/emotion-react.cjs.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_emotion_react_cjs_dev();
    }
  }
});

// ../../node_modules/framesync/dist/framesync.cjs.js
var require_framesync_cjs = __commonJS({
  "../../node_modules/framesync/dist/framesync.cjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaultTimestep = 1 / 60 * 1e3;
    var getCurrentTime = typeof performance !== "undefined" ? () => performance.now() : () => Date.now();
    var onNextFrame = typeof window !== "undefined" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);
    function createRenderStep(runNextFrame2) {
      let toRun = [];
      let toRunNextFrame = [];
      let numToRun = 0;
      let isProcessing2 = false;
      let flushNextFrame = false;
      const toKeepAlive = /* @__PURE__ */ new WeakSet();
      const step = {
        schedule: (callback, keepAlive = false, immediate = false) => {
          const addToCurrentFrame = immediate && isProcessing2;
          const buffer = addToCurrentFrame ? toRun : toRunNextFrame;
          if (keepAlive)
            toKeepAlive.add(callback);
          if (buffer.indexOf(callback) === -1) {
            buffer.push(callback);
            if (addToCurrentFrame && isProcessing2)
              numToRun = toRun.length;
          }
          return callback;
        },
        cancel: (callback) => {
          const index = toRunNextFrame.indexOf(callback);
          if (index !== -1)
            toRunNextFrame.splice(index, 1);
          toKeepAlive.delete(callback);
        },
        process: (frameData) => {
          if (isProcessing2) {
            flushNextFrame = true;
            return;
          }
          isProcessing2 = true;
          [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
          toRunNextFrame.length = 0;
          numToRun = toRun.length;
          if (numToRun) {
            for (let i = 0; i < numToRun; i++) {
              const callback = toRun[i];
              callback(frameData);
              if (toKeepAlive.has(callback)) {
                step.schedule(callback);
                runNextFrame2();
              }
            }
          }
          isProcessing2 = false;
          if (flushNextFrame) {
            flushNextFrame = false;
            step.process(frameData);
          }
        }
      };
      return step;
    }
    var maxElapsed = 40;
    var useDefaultElapsed = true;
    var runNextFrame = false;
    var isProcessing = false;
    var frame = {
      delta: 0,
      timestamp: 0
    };
    var stepsOrder = [
      "read",
      "update",
      "preRender",
      "render",
      "postRender"
    ];
    var steps = stepsOrder.reduce((acc, key) => {
      acc[key] = createRenderStep(() => runNextFrame = true);
      return acc;
    }, {});
    var sync = stepsOrder.reduce((acc, key) => {
      const step = steps[key];
      acc[key] = (process2, keepAlive = false, immediate = false) => {
        if (!runNextFrame)
          startLoop();
        return step.schedule(process2, keepAlive, immediate);
      };
      return acc;
    }, {});
    var cancelSync = stepsOrder.reduce((acc, key) => {
      acc[key] = steps[key].cancel;
      return acc;
    }, {});
    var flushSync = stepsOrder.reduce((acc, key) => {
      acc[key] = () => steps[key].process(frame);
      return acc;
    }, {});
    var processStep = (stepId) => steps[stepId].process(frame);
    var processFrame = (timestamp) => {
      runNextFrame = false;
      frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
      frame.timestamp = timestamp;
      isProcessing = true;
      stepsOrder.forEach(processStep);
      isProcessing = false;
      if (runNextFrame) {
        useDefaultElapsed = false;
        onNextFrame(processFrame);
      }
    };
    var startLoop = () => {
      runNextFrame = true;
      useDefaultElapsed = true;
      if (!isProcessing)
        onNextFrame(processFrame);
    };
    var getFrameData = () => frame;
    exports.cancelSync = cancelSync;
    exports.default = sync;
    exports.flushSync = flushSync;
    exports.getFrameData = getFrameData;
  }
});

// ../../node_modules/@chakra-ui/utils/dist/index.js
var require_dist5 = __commonJS({
  "../../node_modules/@chakra-ui/utils/dist/index.js"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var __publicField = (obj, key, value) => {
      __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    var src_exports = {};
    __export(src_exports, {
      PanSession: () => PanSession,
      __DEV__: () => __DEV__,
      __TEST__: () => __TEST__,
      addDomEvent: () => addDomEvent,
      addItem: () => addItem,
      addPointerEvent: () => addPointerEvent,
      analyzeBreakpoints: () => analyzeBreakpoints,
      ariaAttr: () => ariaAttr,
      arrayToObjectNotation: () => arrayToObjectNotation,
      breakpoints: () => breakpoints,
      callAll: () => callAll,
      callAllHandlers: () => callAllHandlers,
      canUseDOM: () => canUseDOM,
      chunk: () => chunk,
      clampValue: () => clampValue,
      closest: () => closest,
      compose: () => compose,
      contains: () => contains,
      countDecimalPlaces: () => countDecimalPlaces,
      cx: () => cx,
      dataAttr: () => dataAttr,
      detectBrowser: () => detectBrowser,
      detectDeviceType: () => detectDeviceType,
      detectOS: () => detectOS,
      detectTouch: () => detectTouch,
      determineLazyBehavior: () => determineLazyBehavior,
      distance: () => distance,
      error: () => error,
      extractEventInfo: () => extractEventInfo,
      filterUndefined: () => filterUndefined,
      flatten: () => flatten,
      focus: () => focus,
      focusNextTabbable: () => focusNextTabbable,
      focusPreviousTabbable: () => focusPreviousTabbable,
      fromEntries: () => fromEntries,
      get: () => get,
      getActiveElement: () => getActiveElement,
      getAllFocusable: () => getAllFocusable,
      getAllTabbable: () => getAllTabbable,
      getCSSVar: () => getCSSVar,
      getEventWindow: () => getEventWindow,
      getFirstFocusable: () => getFirstFocusable,
      getFirstItem: () => getFirstItem,
      getFirstTabbableIn: () => getFirstTabbableIn,
      getLastItem: () => getLastItem,
      getLastTabbableIn: () => getLastTabbableIn,
      getNextIndex: () => getNextIndex,
      getNextItem: () => getNextItem,
      getNextItemFromSearch: () => getNextItemFromSearch,
      getNextTabbable: () => getNextTabbable,
      getOwnerDocument: () => getOwnerDocument,
      getOwnerWindow: () => getOwnerWindow,
      getPointerEventName: () => getPointerEventName,
      getPrevIndex: () => getPrevIndex,
      getPrevItem: () => getPrevItem,
      getPreviousTabbable: () => getPreviousTabbable,
      getRelatedTarget: () => getRelatedTarget,
      getViewportPointFromEvent: () => getViewportPointFromEvent,
      getWithDefault: () => getWithDefault,
      hasDisplayNone: () => hasDisplayNone,
      hasFocusWithin: () => hasFocusWithin,
      hasNegativeTabIndex: () => hasNegativeTabIndex,
      hasTabIndex: () => hasTabIndex,
      isActiveElement: () => isActiveElement,
      isArray: () => isArray,
      isBrowser: () => isBrowser,
      isContentEditable: () => isContentEditable,
      isCssVar: () => isCssVar,
      isCustomBreakpoint: () => isCustomBreakpoint,
      isDefined: () => isDefined,
      isDisabled: () => isDisabled,
      isElement: () => isElement,
      isEmpty: () => isEmpty,
      isEmptyArray: () => isEmptyArray,
      isEmptyObject: () => isEmptyObject,
      isFocusable: () => isFocusable,
      isFunction: () => isFunction,
      isHTMLElement: () => isHTMLElement,
      isHidden: () => isHidden,
      isInputElement: () => isInputElement,
      isInputEvent: () => isInputEvent,
      isMouseEvent: () => isMouseEvent,
      isMultiTouchEvent: () => isMultiTouchEvent,
      isNotEmptyObject: () => isNotEmptyObject,
      isNotNumber: () => isNotNumber,
      isNull: () => isNull,
      isNumber: () => isNumber,
      isNumeric: () => isNumeric,
      isObject: () => isObject,
      isRefObject: () => isRefObject,
      isResponsiveObjectLike: () => isResponsiveObjectLike,
      isRightClick: () => isRightClick,
      isString: () => isString,
      isTabbable: () => isTabbable,
      isTouchEvent: () => isTouchEvent,
      isUndefined: () => isUndefined,
      mapResponsive: () => mapResponsive,
      maxSafeInteger: () => maxSafeInteger,
      memoize: () => memoize,
      memoizedGet: () => memoizedGet,
      mergeWith: () => import_lodash.default,
      minSafeInteger: () => minSafeInteger,
      noop: () => noop,
      normalizeEventKey: () => normalizeEventKey,
      objectFilter: () => objectFilter,
      objectKeys: () => objectKeys,
      objectToArrayNotation: () => objectToArrayNotation,
      omit: () => omit,
      once: () => once,
      percentToValue: () => percentToValue,
      pick: () => pick,
      pipe: () => pipe,
      px: () => px,
      removeIndex: () => removeIndex,
      removeItem: () => removeItem,
      roundValueToStep: () => roundValueToStep,
      runIfFn: () => runIfFn,
      split: () => split,
      toMediaQueryString: () => toMediaQueryString,
      toPrecision: () => toPrecision,
      valueToPercent: () => valueToPercent,
      walkObject: () => walkObject,
      warn: () => warn,
      wrapPointerEventHandler: () => wrapPointerEventHandler
    });
    module.exports = __toCommonJS2(src_exports);
    __reExport(src_exports, (init_css_box_model_esm(), __toCommonJS(css_box_model_esm_exports)), module.exports);
    function getFirstItem(array) {
      return array != null && array.length ? array[0] : void 0;
    }
    function getLastItem(array) {
      const length = array == null ? 0 : array.length;
      return length ? array[length - 1] : void 0;
    }
    function getPrevItem(index, array, loop = true) {
      const prevIndex = getPrevIndex(index, array.length, loop);
      return array[prevIndex];
    }
    function getNextItem(index, array, loop = true) {
      const nextIndex = getNextIndex(index, array.length, 1, loop);
      return array[nextIndex];
    }
    function removeIndex(array, index) {
      return array.filter((_, idx) => idx !== index);
    }
    function addItem(array, item) {
      return [...array, item];
    }
    function removeItem(array, item) {
      return array.filter((eachItem) => eachItem !== item);
    }
    function getNextIndex(currentIndex, length, step = 1, loop = true) {
      const lastIndex = length - 1;
      if (currentIndex === -1) {
        return step > 0 ? 0 : lastIndex;
      }
      const nextIndex = currentIndex + step;
      if (nextIndex < 0) {
        return loop ? lastIndex : 0;
      }
      if (nextIndex >= length) {
        if (loop)
          return 0;
        return currentIndex > length ? length : currentIndex;
      }
      return nextIndex;
    }
    function getPrevIndex(index, count, loop = true) {
      return getNextIndex(index, count, -1, loop);
    }
    function chunk(array, size) {
      return array.reduce((rows, currentValue, index) => {
        if (index % size === 0) {
          rows.push([currentValue]);
        } else {
          rows[rows.length - 1].push(currentValue);
        }
        return rows;
      }, []);
    }
    function getNextItemFromSearch(items, searchString, itemToString, currentItem) {
      if (searchString == null) {
        return currentItem;
      }
      if (!currentItem) {
        const foundItem = items.find(
          (item) => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase())
        );
        return foundItem;
      }
      const matchingItems = items.filter(
        (item) => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase())
      );
      if (matchingItems.length > 0) {
        let nextIndex;
        if (matchingItems.includes(currentItem)) {
          const currentIndex = matchingItems.indexOf(currentItem);
          nextIndex = currentIndex + 1;
          if (nextIndex === matchingItems.length) {
            nextIndex = 0;
          }
          return matchingItems[nextIndex];
        }
        nextIndex = items.indexOf(matchingItems[0]);
        return items[nextIndex];
      }
      return currentItem;
    }
    function isNumber(value) {
      return typeof value === "number";
    }
    function isNotNumber(value) {
      return typeof value !== "number" || Number.isNaN(value) || !Number.isFinite(value);
    }
    function isNumeric(value) {
      return value != null && value - parseFloat(value) + 1 >= 0;
    }
    function isArray(value) {
      return Array.isArray(value);
    }
    function isEmptyArray(value) {
      return isArray(value) && value.length === 0;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isDefined(value) {
      return typeof value !== "undefined" && value !== void 0;
    }
    function isUndefined(value) {
      return typeof value === "undefined" || value === void 0;
    }
    function isObject(value) {
      const type = typeof value;
      return value != null && (type === "object" || type === "function") && !isArray(value);
    }
    function isEmptyObject(value) {
      return isObject(value) && Object.keys(value).length === 0;
    }
    function isNotEmptyObject(value) {
      return value && !isEmptyObject(value);
    }
    function isNull(value) {
      return value == null;
    }
    function isString(value) {
      return Object.prototype.toString.call(value) === "[object String]";
    }
    function isCssVar(value) {
      return /^var\(--.+\)$/.test(value);
    }
    function isEmpty(value) {
      if (isArray(value))
        return isEmptyArray(value);
      if (isObject(value))
        return isEmptyObject(value);
      if (value == null || value === "")
        return true;
      return false;
    }
    var __DEV__ = true;
    var __TEST__ = false;
    function isRefObject(val) {
      return "current" in val;
    }
    function isInputEvent(value) {
      return value && isObject(value) && isObject(value.target);
    }
    var import_lodash = __toESM(require_lodash());
    function omit(object, keys2) {
      const result = {};
      Object.keys(object).forEach((key) => {
        if (keys2.includes(key))
          return;
        result[key] = object[key];
      });
      return result;
    }
    function pick(object, keys2) {
      const result = {};
      keys2.forEach((key) => {
        if (key in object) {
          result[key] = object[key];
        }
      });
      return result;
    }
    function split(object, keys2) {
      const picked = {};
      const omitted = {};
      Object.keys(object).forEach((key) => {
        if (keys2.includes(key)) {
          picked[key] = object[key];
        } else {
          omitted[key] = object[key];
        }
      });
      return [picked, omitted];
    }
    function get(obj, path, fallback, index) {
      const key = typeof path === "string" ? path.split(".") : [path];
      for (index = 0; index < key.length; index += 1) {
        if (!obj)
          break;
        obj = obj[key[index]];
      }
      return obj === void 0 ? fallback : obj;
    }
    var memoize = (fn) => {
      const cache = /* @__PURE__ */ new WeakMap();
      const memoizedFn = (obj, path, fallback, index) => {
        if (typeof obj === "undefined") {
          return fn(obj, path, fallback);
        }
        if (!cache.has(obj)) {
          cache.set(obj, /* @__PURE__ */ new Map());
        }
        const map = cache.get(obj);
        if (map.has(path)) {
          return map.get(path);
        }
        const value = fn(obj, path, fallback, index);
        map.set(path, value);
        return value;
      };
      return memoizedFn;
    };
    var memoizedGet = memoize(get);
    function getWithDefault(path, scale) {
      return memoizedGet(scale, path, path);
    }
    function objectFilter(object, fn) {
      const result = {};
      Object.keys(object).forEach((key) => {
        const value = object[key];
        const shouldPass = fn(value, key, object);
        if (shouldPass) {
          result[key] = value;
        }
      });
      return result;
    }
    var filterUndefined = (object) => objectFilter(object, (val) => val !== null && val !== void 0);
    var objectKeys = (obj) => Object.keys(obj);
    var fromEntries = (entries) => entries.reduce((carry, [key, value]) => {
      carry[key] = value;
      return carry;
    }, {});
    var getCSSVar = (theme, scale, value) => {
      var _a, _b, _c;
      return (_c = (_b = (_a = theme.__cssMap) == null ? void 0 : _a[`${scale}.${value}`]) == null ? void 0 : _b.varRef) != null ? _c : value;
    };
    function analyzeCSSValue(value) {
      const num = parseFloat(value.toString());
      const unit = value.toString().replace(String(num), "");
      return { unitless: !unit, value: num, unit };
    }
    function px(value) {
      if (value == null)
        return value;
      const { unitless } = analyzeCSSValue(value);
      return unitless || isNumber(value) ? `${value}px` : value;
    }
    var sortByBreakpointValue = (a, b) => parseInt(a[1], 10) > parseInt(b[1], 10) ? 1 : -1;
    var sortBps = (breakpoints2) => fromEntries(Object.entries(breakpoints2).sort(sortByBreakpointValue));
    function normalize(breakpoints2) {
      const sorted = sortBps(breakpoints2);
      return Object.assign(Object.values(sorted), sorted);
    }
    function keys(breakpoints2) {
      const value = Object.keys(sortBps(breakpoints2));
      return new Set(value);
    }
    function subtract(value) {
      var _a;
      if (!value)
        return value;
      value = (_a = px(value)) != null ? _a : value;
      const factor = value.endsWith("px") ? -0.02 : -0.01;
      return isNumber(value) ? `${value + factor}` : value.replace(/(\d+\.?\d*)/u, (m) => `${parseFloat(m) + factor}`);
    }
    function toMediaQueryString(min, max) {
      const query = ["@media screen"];
      if (min)
        query.push("and", `(min-width: ${px(min)})`);
      if (max)
        query.push("and", `(max-width: ${px(max)})`);
      return query.join(" ");
    }
    function analyzeBreakpoints(breakpoints2) {
      var _a;
      if (!breakpoints2)
        return null;
      breakpoints2.base = (_a = breakpoints2.base) != null ? _a : "0px";
      const normalized = normalize(breakpoints2);
      const queries = Object.entries(breakpoints2).sort(sortByBreakpointValue).map(([breakpoint, minW], index, entry) => {
        var _a2;
        let [, maxW] = (_a2 = entry[index + 1]) != null ? _a2 : [];
        maxW = parseFloat(maxW) > 0 ? subtract(maxW) : void 0;
        return {
          _minW: subtract(minW),
          breakpoint,
          minW,
          maxW,
          maxWQuery: toMediaQueryString(null, maxW),
          minWQuery: toMediaQueryString(minW),
          minMaxQuery: toMediaQueryString(minW, maxW)
        };
      });
      const _keys = keys(breakpoints2);
      const _keysArr = Array.from(_keys.values());
      return {
        keys: _keys,
        normalized,
        isResponsive(test) {
          const keys2 = Object.keys(test);
          return keys2.length > 0 && keys2.every((key) => _keys.has(key));
        },
        asObject: sortBps(breakpoints2),
        asArray: normalize(breakpoints2),
        details: queries,
        media: [
          null,
          ...normalized.map((minW) => toMediaQueryString(minW)).slice(1)
        ],
        toArrayValue(test) {
          if (!isObject(test)) {
            throw new Error("toArrayValue: value must be an object");
          }
          const result = _keysArr.map((bp) => {
            var _a2;
            return (_a2 = test[bp]) != null ? _a2 : null;
          });
          while (getLastItem(result) === null) {
            result.pop();
          }
          return result;
        },
        toObjectValue(test) {
          if (!Array.isArray(test)) {
            throw new Error("toObjectValue: value must be an array");
          }
          return test.reduce((acc, value, index) => {
            const key = _keysArr[index];
            if (key != null && value != null)
              acc[key] = value;
            return acc;
          }, {});
        }
      };
    }
    function isElement(el) {
      return el != null && typeof el == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
    }
    function isHTMLElement(el) {
      var _a;
      if (!isElement(el)) {
        return false;
      }
      const win = (_a = el.ownerDocument.defaultView) != null ? _a : window;
      return el instanceof win.HTMLElement;
    }
    function getOwnerWindow(node) {
      var _a, _b;
      return isElement(node) ? (_b = (_a = getOwnerDocument(node)) == null ? void 0 : _a.defaultView) != null ? _b : window : window;
    }
    function getOwnerDocument(node) {
      var _a;
      return isElement(node) ? (_a = node.ownerDocument) != null ? _a : document : document;
    }
    function getEventWindow(event) {
      var _a;
      return (_a = event.view) != null ? _a : window;
    }
    function canUseDOM() {
      return !!(typeof window !== "undefined" && window.document && window.document.createElement);
    }
    var isBrowser = canUseDOM();
    var dataAttr = (condition) => condition ? "" : void 0;
    var ariaAttr = (condition) => condition ? true : void 0;
    var cx = (...classNames) => classNames.filter(Boolean).join(" ");
    function getActiveElement(node) {
      const doc = getOwnerDocument(node);
      return doc == null ? void 0 : doc.activeElement;
    }
    function contains(parent, child) {
      if (!parent)
        return false;
      return parent === child || parent.contains(child);
    }
    function addDomEvent(target, eventName, handler, options) {
      target.addEventListener(eventName, handler, options);
      return () => {
        target.removeEventListener(eventName, handler, options);
      };
    }
    function normalizeEventKey(event) {
      const { key, keyCode } = event;
      const isArrowKey = keyCode >= 37 && keyCode <= 40 && key.indexOf("Arrow") !== 0;
      const eventKey = isArrowKey ? `Arrow${key}` : key;
      return eventKey;
    }
    function getRelatedTarget(event) {
      var _a, _b;
      const target = (_a = event.target) != null ? _a : event.currentTarget;
      const activeElement = getActiveElement(target);
      return (_b = event.relatedTarget) != null ? _b : activeElement;
    }
    function isRightClick(event) {
      return event.button !== 0;
    }
    var hasDisplayNone = (element) => window.getComputedStyle(element).display === "none";
    var hasTabIndex = (element) => element.hasAttribute("tabindex");
    var hasNegativeTabIndex = (element) => hasTabIndex(element) && element.tabIndex === -1;
    function isDisabled(element) {
      return Boolean(element.getAttribute("disabled")) === true || Boolean(element.getAttribute("aria-disabled")) === true;
    }
    function isInputElement(element) {
      return isHTMLElement(element) && element.localName === "input" && "select" in element;
    }
    function isActiveElement(element) {
      const doc = isHTMLElement(element) ? getOwnerDocument(element) : document;
      return doc.activeElement === element;
    }
    function hasFocusWithin(element) {
      if (!document.activeElement)
        return false;
      return element.contains(document.activeElement);
    }
    function isHidden(element) {
      if (element.parentElement && isHidden(element.parentElement))
        return true;
      return element.hidden;
    }
    function isContentEditable(element) {
      const value = element.getAttribute("contenteditable");
      return value !== "false" && value != null;
    }
    function isFocusable(element) {
      if (!isHTMLElement(element) || isHidden(element) || isDisabled(element)) {
        return false;
      }
      const { localName } = element;
      const focusableTags = ["input", "select", "textarea", "button"];
      if (focusableTags.indexOf(localName) >= 0)
        return true;
      const others = {
        a: () => element.hasAttribute("href"),
        audio: () => element.hasAttribute("controls"),
        video: () => element.hasAttribute("controls")
      };
      if (localName in others) {
        return others[localName]();
      }
      if (isContentEditable(element))
        return true;
      return hasTabIndex(element);
    }
    function isTabbable(element) {
      if (!element)
        return false;
      return isHTMLElement(element) && isFocusable(element) && !hasNegativeTabIndex(element);
    }
    var focusableElList = [
      "input:not(:disabled):not([disabled])",
      "select:not(:disabled):not([disabled])",
      "textarea:not(:disabled):not([disabled])",
      "embed",
      "iframe",
      "object",
      "a[href]",
      "area[href]",
      "button:not(:disabled):not([disabled])",
      "[tabindex]",
      "audio[controls]",
      "video[controls]",
      "*[tabindex]:not([aria-disabled])",
      "*[contenteditable]"
    ];
    var focusableElSelector = focusableElList.join();
    var isVisible = (el) => el.offsetWidth > 0 && el.offsetHeight > 0;
    function getAllFocusable(container) {
      const focusableEls = Array.from(
        container.querySelectorAll(focusableElSelector)
      );
      focusableEls.unshift(container);
      return focusableEls.filter((el) => isFocusable(el) && isVisible(el));
    }
    function getFirstFocusable(container) {
      const allFocusable = getAllFocusable(container);
      return allFocusable.length ? allFocusable[0] : null;
    }
    function getAllTabbable(container, fallbackToFocusable) {
      const allFocusable = Array.from(
        container.querySelectorAll(focusableElSelector)
      );
      const allTabbable = allFocusable.filter(isTabbable);
      if (isTabbable(container)) {
        allTabbable.unshift(container);
      }
      if (!allTabbable.length && fallbackToFocusable) {
        return allFocusable;
      }
      return allTabbable;
    }
    function getFirstTabbableIn(container, fallbackToFocusable) {
      const [first] = getAllTabbable(container, fallbackToFocusable);
      return first || null;
    }
    function getLastTabbableIn(container, fallbackToFocusable) {
      const allTabbable = getAllTabbable(container, fallbackToFocusable);
      return allTabbable[allTabbable.length - 1] || null;
    }
    function getNextTabbable(container, fallbackToFocusable) {
      const allFocusable = getAllFocusable(container);
      const index = allFocusable.indexOf(document.activeElement);
      const slice = allFocusable.slice(index + 1);
      return slice.find(isTabbable) || allFocusable.find(isTabbable) || (fallbackToFocusable ? slice[0] : null);
    }
    function getPreviousTabbable(container, fallbackToFocusable) {
      const allFocusable = getAllFocusable(container).reverse();
      const index = allFocusable.indexOf(document.activeElement);
      const slice = allFocusable.slice(index + 1);
      return slice.find(isTabbable) || allFocusable.find(isTabbable) || (fallbackToFocusable ? slice[0] : null);
    }
    function focusNextTabbable(container, fallbackToFocusable) {
      const nextTabbable = getNextTabbable(container, fallbackToFocusable);
      if (nextTabbable && isHTMLElement(nextTabbable)) {
        nextTabbable.focus();
      }
    }
    function focusPreviousTabbable(container, fallbackToFocusable) {
      const previousTabbable = getPreviousTabbable(container, fallbackToFocusable);
      if (previousTabbable && isHTMLElement(previousTabbable)) {
        previousTabbable.focus();
      }
    }
    function matches(element, selectors) {
      if ("matches" in element)
        return element.matches(selectors);
      if ("msMatchesSelector" in element)
        return element.msMatchesSelector(selectors);
      return element.webkitMatchesSelector(selectors);
    }
    function closest(element, selectors) {
      if ("closest" in element)
        return element.closest(selectors);
      do {
        if (matches(element, selectors))
          return element;
        element = element.parentElement || element.parentNode;
      } while (element !== null && element.nodeType === 1);
      return null;
    }
    function runIfFn(valueOrFn, ...args) {
      return isFunction(valueOrFn) ? valueOrFn(...args) : valueOrFn;
    }
    function callAllHandlers(...fns) {
      return function func(event) {
        fns.some((fn) => {
          fn == null ? void 0 : fn(event);
          return event == null ? void 0 : event.defaultPrevented;
        });
      };
    }
    function callAll(...fns) {
      return function mergedFn(arg) {
        fns.forEach((fn) => {
          fn == null ? void 0 : fn(arg);
        });
      };
    }
    var compose = (fn1, ...fns) => fns.reduce(
      (f1, f2) => (...args) => f1(f2(...args)),
      fn1
    );
    function once(fn) {
      let result;
      return function func(...args) {
        if (fn) {
          result = fn.apply(this, args);
          fn = null;
        }
        return result;
      };
    }
    var noop = () => {
    };
    var warn = once((options) => () => {
      const { condition, message } = options;
      if (condition && __DEV__) {
        console.warn(message);
      }
    });
    var error = once((options) => () => {
      const { condition, message } = options;
      if (condition && __DEV__) {
        console.error(message);
      }
    });
    var pipe = (...fns) => (v) => fns.reduce((a, b) => b(a), v);
    var distance1D = (a, b) => Math.abs(a - b);
    var isPoint = (point) => "x" in point && "y" in point;
    function distance(a, b) {
      if (isNumber(a) && isNumber(b)) {
        return distance1D(a, b);
      }
      if (isPoint(a) && isPoint(b)) {
        const xDelta = distance1D(a.x, b.x);
        const yDelta = distance1D(a.y, b.y);
        return Math.sqrt(xDelta ** 2 + yDelta ** 2);
      }
      return 0;
    }
    function focus(element, options = {}) {
      const {
        isActive = isActiveElement,
        nextTick,
        preventScroll = true,
        selectTextIfInput = true
      } = options;
      if (!element || isActive(element))
        return -1;
      function triggerFocus() {
        if (!element) {
          warn({
            condition: true,
            message: "[chakra-ui]: can't call focus() on `null` or `undefined` element"
          });
          return;
        }
        if (supportsPreventScroll()) {
          element.focus({ preventScroll });
        } else {
          element.focus();
          if (preventScroll) {
            const scrollableElements = getScrollableElements(element);
            restoreScrollPosition(scrollableElements);
          }
        }
        if (selectTextIfInput) {
          if (isInputElement(element)) {
            element.select();
          } else if ("setSelectionRange" in element) {
            const el = element;
            el.setSelectionRange(el.value.length, el.value.length);
          }
        }
      }
      if (nextTick) {
        return requestAnimationFrame(triggerFocus);
      }
      triggerFocus();
      return -1;
    }
    var supportsPreventScrollCached = null;
    function supportsPreventScroll() {
      if (supportsPreventScrollCached == null) {
        supportsPreventScrollCached = false;
        try {
          const div = document.createElement("div");
          div.focus({
            get preventScroll() {
              supportsPreventScrollCached = true;
              return true;
            }
          });
        } catch (e) {
        }
      }
      return supportsPreventScrollCached;
    }
    function getScrollableElements(element) {
      var _a;
      const doc = getOwnerDocument(element);
      const win = (_a = doc.defaultView) != null ? _a : window;
      let parent = element.parentNode;
      const scrollableElements = [];
      const rootScrollingElement = doc.scrollingElement || doc.documentElement;
      while (parent instanceof win.HTMLElement && parent !== rootScrollingElement) {
        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) {
          scrollableElements.push({
            element: parent,
            scrollTop: parent.scrollTop,
            scrollLeft: parent.scrollLeft
          });
        }
        parent = parent.parentNode;
      }
      if (rootScrollingElement instanceof win.HTMLElement) {
        scrollableElements.push({
          element: rootScrollingElement,
          scrollTop: rootScrollingElement.scrollTop,
          scrollLeft: rootScrollingElement.scrollLeft
        });
      }
      return scrollableElements;
    }
    function restoreScrollPosition(scrollableElements) {
      for (const { element, scrollTop, scrollLeft } of scrollableElements) {
        element.scrollTop = scrollTop;
        element.scrollLeft = scrollLeft;
      }
    }
    function flatten(target, maxDepth = Infinity) {
      if (!isObject(target) && !Array.isArray(target) || !maxDepth) {
        return target;
      }
      return Object.entries(target).reduce((result, [key, value]) => {
        if (isObject(value) || isArray(value)) {
          Object.entries(flatten(value, maxDepth - 1)).forEach(
            ([childKey, childValue]) => {
              result[`${key}.${childKey}`] = childValue;
            }
          );
        } else {
          result[key] = value;
        }
        return result;
      }, {});
    }
    function determineLazyBehavior(options) {
      const {
        hasBeenSelected,
        isLazy,
        isSelected,
        lazyBehavior = "unmount"
      } = options;
      if (!isLazy)
        return true;
      if (isSelected)
        return true;
      if (lazyBehavior === "keepMounted" && hasBeenSelected)
        return true;
      return false;
    }
    var minSafeInteger = Number.MIN_SAFE_INTEGER || -9007199254740991;
    var maxSafeInteger = Number.MAX_SAFE_INTEGER || 9007199254740991;
    function toNumber(value) {
      const num = parseFloat(value);
      return isNotNumber(num) ? 0 : num;
    }
    function toPrecision(value, precision) {
      let nextValue = toNumber(value);
      const scaleFactor = 10 ** (precision != null ? precision : 10);
      nextValue = Math.round(nextValue * scaleFactor) / scaleFactor;
      return precision ? nextValue.toFixed(precision) : nextValue.toString();
    }
    function countDecimalPlaces(value) {
      if (!Number.isFinite(value))
        return 0;
      let e = 1;
      let p = 0;
      while (Math.round(value * e) / e !== value) {
        e *= 10;
        p += 1;
      }
      return p;
    }
    function valueToPercent(value, min, max) {
      return (value - min) * 100 / (max - min);
    }
    function percentToValue(percent, min, max) {
      return (max - min) * percent + min;
    }
    function roundValueToStep(value, from, step) {
      const nextValue = Math.round((value - from) / step) * step + from;
      const precision = countDecimalPlaces(step);
      return toPrecision(nextValue, precision);
    }
    function clampValue(value, min, max) {
      if (value == null)
        return value;
      warn({
        condition: max < min,
        message: "clamp: max cannot be less than min"
      });
      return Math.min(Math.max(value, min), max);
    }
    var import_framesync = __toESM(require_framesync_cjs());
    function isMouseEvent(event) {
      const win = getEventWindow(event);
      if (typeof win.PointerEvent !== "undefined" && event instanceof win.PointerEvent) {
        return !!(event.pointerType === "mouse");
      }
      return event instanceof win.MouseEvent;
    }
    function isTouchEvent(event) {
      const hasTouches = !!event.touches;
      return hasTouches;
    }
    function filterPrimaryPointer(eventHandler) {
      return (event) => {
        const win = getEventWindow(event);
        const isMouseEvent2 = event instanceof win.MouseEvent;
        const isPrimaryPointer = !isMouseEvent2 || isMouseEvent2 && event.button === 0;
        if (isPrimaryPointer) {
          eventHandler(event);
        }
      };
    }
    var defaultPagePoint = { pageX: 0, pageY: 0 };
    function pointFromTouch(e, pointType = "page") {
      const primaryTouch = e.touches[0] || e.changedTouches[0];
      const point = primaryTouch || defaultPagePoint;
      return {
        x: point[`${pointType}X`],
        y: point[`${pointType}Y`]
      };
    }
    function pointFromMouse(point, pointType = "page") {
      return {
        x: point[`${pointType}X`],
        y: point[`${pointType}Y`]
      };
    }
    function extractEventInfo(event, pointType = "page") {
      return {
        point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)
      };
    }
    function getViewportPointFromEvent(event) {
      return extractEventInfo(event, "client");
    }
    var wrapPointerEventHandler = (handler, shouldFilterPrimaryPointer = false) => {
      const listener = (event) => handler(event, extractEventInfo(event));
      return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;
    };
    var supportsPointerEvents = () => isBrowser && window.onpointerdown === null;
    var supportsTouchEvents = () => isBrowser && window.ontouchstart === null;
    var supportsMouseEvents = () => isBrowser && window.onmousedown === null;
    var mouseEventNames = {
      pointerdown: "mousedown",
      pointermove: "mousemove",
      pointerup: "mouseup",
      pointercancel: "mousecancel",
      pointerover: "mouseover",
      pointerout: "mouseout",
      pointerenter: "mouseenter",
      pointerleave: "mouseleave"
    };
    var touchEventNames = {
      pointerdown: "touchstart",
      pointermove: "touchmove",
      pointerup: "touchend",
      pointercancel: "touchcancel"
    };
    function getPointerEventName(name) {
      if (supportsPointerEvents()) {
        return name;
      }
      if (supportsTouchEvents()) {
        return touchEventNames[name];
      }
      if (supportsMouseEvents()) {
        return mouseEventNames[name];
      }
      return name;
    }
    function addPointerEvent(target, eventName, handler, options) {
      return addDomEvent(
        target,
        getPointerEventName(eventName),
        wrapPointerEventHandler(handler, eventName === "pointerdown"),
        options
      );
    }
    function isMultiTouchEvent(event) {
      return isTouchEvent(event) && event.touches.length > 1;
    }
    var PanSession = class {
      constructor(event, handlers, threshold) {
        __publicField(this, "history", []);
        __publicField(this, "startEvent", null);
        __publicField(this, "lastEvent", null);
        __publicField(this, "lastEventInfo", null);
        __publicField(this, "handlers", {});
        __publicField(this, "removeListeners", noop);
        __publicField(this, "threshold", 3);
        __publicField(this, "win");
        __publicField(this, "updatePoint", () => {
          if (!(this.lastEvent && this.lastEventInfo))
            return;
          const info2 = getPanInfo(this.lastEventInfo, this.history);
          const isPanStarted = this.startEvent !== null;
          const isDistancePastThreshold = distance(info2.offset, { x: 0, y: 0 }) >= this.threshold;
          if (!isPanStarted && !isDistancePastThreshold)
            return;
          const { timestamp: timestamp2 } = (0, import_framesync.getFrameData)();
          this.history.push({ ...info2.point, timestamp: timestamp2 });
          const { onStart, onMove } = this.handlers;
          if (!isPanStarted) {
            onStart == null ? void 0 : onStart(this.lastEvent, info2);
            this.startEvent = this.lastEvent;
          }
          onMove == null ? void 0 : onMove(this.lastEvent, info2);
        });
        __publicField(this, "onPointerMove", (event2, info2) => {
          this.lastEvent = event2;
          this.lastEventInfo = info2;
          if (isMouseEvent(event2) && event2.buttons === 0) {
            this.onPointerUp(event2, info2);
            return;
          }
          import_framesync.default.update(this.updatePoint, true);
        });
        __publicField(this, "onPointerUp", (event2, info2) => {
          const panInfo = getPanInfo(info2, this.history);
          const { onEnd, onSessionEnd } = this.handlers;
          onSessionEnd == null ? void 0 : onSessionEnd(event2, panInfo);
          this.end();
          if (!onEnd || !this.startEvent)
            return;
          onEnd == null ? void 0 : onEnd(event2, panInfo);
        });
        this.win = getEventWindow(event);
        if (isMultiTouchEvent(event))
          return;
        this.handlers = handlers;
        if (threshold) {
          this.threshold = threshold;
        }
        event.stopPropagation();
        event.preventDefault();
        const info = extractEventInfo(event);
        const { timestamp } = (0, import_framesync.getFrameData)();
        this.history = [{ ...info.point, timestamp }];
        const { onSessionStart } = handlers;
        onSessionStart == null ? void 0 : onSessionStart(event, getPanInfo(info, this.history));
        this.removeListeners = pipe(
          addPointerEvent(this.win, "pointermove", this.onPointerMove),
          addPointerEvent(this.win, "pointerup", this.onPointerUp),
          addPointerEvent(this.win, "pointercancel", this.onPointerUp)
        );
      }
      updateHandlers(handlers) {
        this.handlers = handlers;
      }
      end() {
        var _a;
        (_a = this.removeListeners) == null ? void 0 : _a.call(this);
        import_framesync.cancelSync.update(this.updatePoint);
      }
    };
    function subtractPoint(a, b) {
      return { x: a.x - b.x, y: a.y - b.y };
    }
    function startPanPoint(history) {
      return history[0];
    }
    function lastPanPoint(history) {
      return history[history.length - 1];
    }
    function getPanInfo(info, history) {
      return {
        point: info.point,
        delta: subtractPoint(info.point, lastPanPoint(history)),
        offset: subtractPoint(info.point, startPanPoint(history)),
        velocity: getVelocity(history, 0.1)
      };
    }
    function lastDevicePoint(history) {
      return history[history.length - 1];
    }
    var toMilliseconds = (seconds) => seconds * 1e3;
    function getVelocity(history, timeDelta) {
      if (history.length < 2) {
        return { x: 0, y: 0 };
      }
      let i = history.length - 1;
      let timestampedPoint = null;
      const lastPoint = lastDevicePoint(history);
      while (i >= 0) {
        timestampedPoint = history[i];
        if (lastPoint.timestamp - timestampedPoint.timestamp > toMilliseconds(timeDelta)) {
          break;
        }
        i--;
      }
      if (!timestampedPoint) {
        return { x: 0, y: 0 };
      }
      const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;
      if (time === 0) {
        return { x: 0, y: 0 };
      }
      const currentVelocity = {
        x: (lastPoint.x - timestampedPoint.x) / time,
        y: (lastPoint.y - timestampedPoint.y) / time
      };
      if (currentVelocity.x === Infinity) {
        currentVelocity.x = 0;
      }
      if (currentVelocity.y === Infinity) {
        currentVelocity.y = 0;
      }
      return currentVelocity;
    }
    var breakpoints = Object.freeze([
      "base",
      "sm",
      "md",
      "lg",
      "xl",
      "2xl"
    ]);
    function mapResponsive(prop, mapper) {
      if (isArray(prop)) {
        return prop.map((item) => {
          if (item === null) {
            return null;
          }
          return mapper(item);
        });
      }
      if (isObject(prop)) {
        return objectKeys(prop).reduce((result, key) => {
          result[key] = mapper(prop[key]);
          return result;
        }, {});
      }
      if (prop != null) {
        return mapper(prop);
      }
      return null;
    }
    function objectToArrayNotation(obj, bps = breakpoints) {
      const result = bps.map((br) => {
        var _a;
        return (_a = obj[br]) != null ? _a : null;
      });
      while (getLastItem(result) === null) {
        result.pop();
      }
      return result;
    }
    function arrayToObjectNotation(values, bps = breakpoints) {
      const result = {};
      values.forEach((value, index) => {
        const key = bps[index];
        if (value == null)
          return;
        result[key] = value;
      });
      return result;
    }
    function isResponsiveObjectLike(obj, bps = breakpoints) {
      const keys2 = Object.keys(obj);
      return keys2.length > 0 && keys2.every((key) => bps.includes(key));
    }
    var isCustomBreakpoint = (maybeBreakpoint) => Number.isNaN(Number(maybeBreakpoint));
    function getUserAgentBrowser(navigator2) {
      const { userAgent: ua, vendor } = navigator2;
      const android = /(android)/i.test(ua);
      switch (true) {
        case /CriOS/.test(ua):
          return "Chrome for iOS";
        case /Edg\//.test(ua):
          return "Edge";
        case (android && /Silk\//.test(ua)):
          return "Silk";
        case (/Chrome/.test(ua) && /Google Inc/.test(vendor)):
          return "Chrome";
        case /Firefox\/\d+\.\d+$/.test(ua):
          return "Firefox";
        case android:
          return "AOSP";
        case /MSIE|Trident/.test(ua):
          return "IE";
        case (/Safari/.test(navigator2.userAgent) && /Apple Computer/.test(ua)):
          return "Safari";
        case /AppleWebKit/.test(ua):
          return "WebKit";
        default:
          return null;
      }
    }
    function getUserAgentOS(navigator2) {
      const { userAgent: ua, platform } = navigator2;
      switch (true) {
        case /Android/.test(ua):
          return "Android";
        case /iPhone|iPad|iPod/.test(platform):
          return "iOS";
        case /Win/.test(platform):
          return "Windows";
        case /Mac/.test(platform):
          return "Mac";
        case /CrOS/.test(ua):
          return "Chrome OS";
        case /Firefox/.test(ua):
          return "Firefox OS";
        default:
          return null;
      }
    }
    function detectDeviceType(navigator2) {
      const { userAgent: ua } = navigator2;
      if (/(tablet)|(iPad)|(Nexus 9)/i.test(ua))
        return "tablet";
      if (/(mobi)/i.test(ua))
        return "phone";
      return "desktop";
    }
    function detectOS(os) {
      if (!isBrowser)
        return false;
      return getUserAgentOS(window.navigator) === os;
    }
    function detectBrowser(browser) {
      if (!isBrowser)
        return false;
      return getUserAgentBrowser(window.navigator) === browser;
    }
    function detectTouch() {
      if (!isBrowser)
        return false;
      return window.ontouchstart === null && window.ontouchmove === null && window.ontouchend === null;
    }
    function walkObject(target, predicate) {
      function inner(value, path = []) {
        if (isArray(value)) {
          return value.map((item, index) => inner(item, [...path, String(index)]));
        }
        if (isObject(value)) {
          return fromEntries(
            Object.entries(value).map(([key, child]) => [
              key,
              inner(child, [...path, key])
            ])
          );
        }
        return predicate(value, path);
      }
      return inner(target);
    }
  }
});

// ../../node_modules/@chakra-ui/react-utils/dist/index.js
var require_dist6 = __commonJS({
  "../../node_modules/@chakra-ui/react-utils/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      assignRef: () => assignRef,
      createContext: () => createContext,
      getValidChildren: () => getValidChildren,
      mergeRefs: () => mergeRefs
    });
    module.exports = __toCommonJS2(src_exports);
    var import_utils = require_dist5();
    function assignRef(ref, value) {
      if (ref == null)
        return;
      if ((0, import_utils.isFunction)(ref)) {
        ref(value);
        return;
      }
      try {
        ref.current = value;
      } catch (error) {
        throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);
      }
    }
    function mergeRefs(...refs) {
      return (node) => {
        refs.forEach((ref) => assignRef(ref, node));
      };
    }
    var import_react = require_react();
    function createContext(options = {}) {
      const {
        strict = true,
        errorMessage = "useContext: `context` is undefined. Seems you forgot to wrap component within the Provider",
        name
      } = options;
      const Context = (0, import_react.createContext)(void 0);
      Context.displayName = name;
      function useContext() {
        var _a;
        const context = (0, import_react.useContext)(Context);
        if (!context && strict) {
          const error = new Error(errorMessage);
          error.name = "ContextError";
          (_a = Error.captureStackTrace) == null ? void 0 : _a.call(Error, error, useContext);
          throw error;
        }
        return context;
      }
      return [
        Context.Provider,
        useContext,
        Context
      ];
    }
    var import_react2 = require_react();
    function getValidChildren(children) {
      return import_react2.Children.toArray(children).filter(
        (child) => (0, import_react2.isValidElement)(child)
      );
    }
  }
});

// ../../node_modules/@chakra-ui/object-utils/dist/index.js
var require_dist7 = __commonJS({
  "../../node_modules/@chakra-ui/object-utils/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      assignAfter: () => assignAfter,
      compact: () => compact,
      omit: () => omit,
      pick: () => pick,
      split: () => split,
      walkObject: () => walkObject
    });
    module.exports = __toCommonJS2(src_exports);
    function assignAfter(target, ...sources) {
      if (target == null) {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      const result = { ...target };
      for (const nextSource of sources) {
        if (nextSource == null)
          continue;
        for (const nextKey in nextSource) {
          if (!Object.prototype.hasOwnProperty.call(nextSource, nextKey))
            continue;
          if (nextKey in result)
            delete result[nextKey];
          result[nextKey] = nextSource[nextKey];
        }
      }
      return result;
    }
    function compact(object) {
      const clone = Object.assign({}, object);
      for (let key in clone) {
        if (clone[key] === void 0)
          delete clone[key];
      }
      return clone;
    }
    function omit(object, keysToOmit = []) {
      const clone = Object.assign({}, object);
      for (const key of keysToOmit) {
        if (key in clone) {
          delete clone[key];
        }
      }
      return clone;
    }
    function pick(object, keysToPick) {
      const result = {};
      for (const key of keysToPick) {
        if (key in object) {
          result[key] = object[key];
        }
      }
      return result;
    }
    function split(object, keys) {
      const picked = {};
      const omitted = {};
      for (const [key, value] of Object.entries(object)) {
        if (keys.includes(key))
          picked[key] = value;
        else
          omitted[key] = value;
      }
      return [picked, omitted];
    }
    function isObject(value) {
      return typeof value === "object" && value != null && !Array.isArray(value);
    }
    function walkObject(target, predicate, options = {}) {
      const { stop, getKey } = options;
      function inner(value, path = []) {
        var _a;
        if (isObject(value) || Array.isArray(value)) {
          const result = {};
          for (const [prop, child] of Object.entries(value)) {
            const key = (_a = getKey == null ? void 0 : getKey(prop)) != null ? _a : prop;
            const childPath = [...path, key];
            if (stop == null ? void 0 : stop(value, childPath)) {
              return predicate(value, path);
            }
            result[key] = inner(child, childPath);
          }
          return result;
        }
        return predicate(value, path);
      }
      return inner(target);
    }
  }
});

// ../../node_modules/@emotion/styled/node_modules/@babel/runtime/helpers/extends.js
var require_extends2 = __commonJS({
  "../../node_modules/@emotion/styled/node_modules/@babel/runtime/helpers/extends.js"(exports, module) {
    function _extends() {
      module.exports = _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _extends.apply(this, arguments);
    }
    module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.cjs.dev.js
var require_emotion_is_prop_valid_cjs_dev = __commonJS({
  "../../node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var memoize = require_emotion_memoize_cjs();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var memoize__default = _interopDefault(memoize);
    var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
    var isPropValid = memoize__default["default"](
      function(prop) {
        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
      }
    );
    exports["default"] = isPropValid;
  }
});

// ../../node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.cjs.js
var require_emotion_is_prop_valid_cjs = __commonJS({
  "../../node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.cjs.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_emotion_is_prop_valid_cjs_dev();
    }
  }
});

// ../../node_modules/@emotion/styled/base/dist/emotion-styled-base.cjs.dev.js
var require_emotion_styled_base_cjs_dev = __commonJS({
  "../../node_modules/@emotion/styled/base/dist/emotion-styled-base.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _extends = require_extends2();
    var React = require_react();
    var isPropValid = require_emotion_is_prop_valid_cjs();
    var react = require_emotion_react_cjs();
    var utils = require_emotion_utils_cjs();
    var serialize = require_emotion_serialize_cjs();
    var useInsertionEffectWithFallbacks = require_emotion_use_insertion_effect_with_fallbacks_cjs();
    function _interopDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespace(React);
    var isPropValid__default = _interopDefault(isPropValid);
    var testOmitPropsOnStringTag = isPropValid__default["default"];
    var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
      return key !== "theme";
    };
    var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
      return typeof tag === "string" && tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
    };
    var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
      var shouldForwardProp;
      if (options) {
        var optionsShouldForwardProp = options.shouldForwardProp;
        shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
          return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
        } : optionsShouldForwardProp;
      }
      if (typeof shouldForwardProp !== "function" && isReal) {
        shouldForwardProp = tag.__emotion_forwardProp;
      }
      return shouldForwardProp;
    };
    var ILLEGAL_ESCAPE_SEQUENCE_ERROR = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`;
    var isBrowser = typeof document !== "undefined";
    var Insertion = function Insertion2(_ref) {
      var cache = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
      utils.registerStyles(cache, serialized, isStringTag);
      var rules = useInsertionEffectWithFallbacks.useInsertionEffectAlwaysWithSyncFallback(function() {
        return utils.insertStyles(cache, serialized, isStringTag);
      });
      if (!isBrowser && rules !== void 0) {
        var _ref2;
        var serializedNames = serialized.name;
        var next = serialized.next;
        while (next !== void 0) {
          serializedNames += " " + next.name;
          next = next.next;
        }
        return React__namespace.createElement("style", (_ref2 = {}, _ref2["data-emotion"] = cache.key + " " + serializedNames, _ref2.dangerouslySetInnerHTML = {
          __html: rules
        }, _ref2.nonce = cache.sheet.nonce, _ref2));
      }
      return null;
    };
    var createStyled = function createStyled2(tag, options) {
      if (true) {
        if (tag === void 0) {
          throw new Error("You are trying to create a styled element with an undefined component.\nYou may have forgotten to import it.");
        }
      }
      var isReal = tag.__emotion_real === tag;
      var baseTag = isReal && tag.__emotion_base || tag;
      var identifierName;
      var targetClassName;
      if (options !== void 0) {
        identifierName = options.label;
        targetClassName = options.target;
      }
      var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
      var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
      var shouldUseAs = !defaultShouldForwardProp("as");
      return function() {
        var args = arguments;
        var styles = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
        if (identifierName !== void 0) {
          styles.push("label:" + identifierName + ";");
        }
        if (args[0] == null || args[0].raw === void 0) {
          styles.push.apply(styles, args);
        } else {
          if (args[0][0] === void 0) {
            console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
          }
          styles.push(args[0][0]);
          var len = args.length;
          var i = 1;
          for (; i < len; i++) {
            if (args[0][i] === void 0) {
              console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
            }
            styles.push(args[i], args[0][i]);
          }
        }
        var Styled = react.withEmotionCache(function(props, cache, ref) {
          var FinalTag = shouldUseAs && props.as || baseTag;
          var className = "";
          var classInterpolations = [];
          var mergedProps = props;
          if (props.theme == null) {
            mergedProps = {};
            for (var key in props) {
              mergedProps[key] = props[key];
            }
            mergedProps.theme = React__namespace.useContext(react.ThemeContext);
          }
          if (typeof props.className === "string") {
            className = utils.getRegisteredStyles(cache.registered, classInterpolations, props.className);
          } else if (props.className != null) {
            className = props.className + " ";
          }
          var serialized = serialize.serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
          className += cache.key + "-" + serialized.name;
          if (targetClassName !== void 0) {
            className += " " + targetClassName;
          }
          var finalShouldForwardProp = shouldUseAs && shouldForwardProp === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
          var newProps = {};
          for (var _key in props) {
            if (shouldUseAs && _key === "as")
              continue;
            if (finalShouldForwardProp(_key)) {
              newProps[_key] = props[_key];
            }
          }
          newProps.className = className;
          newProps.ref = ref;
          return React__namespace.createElement(React__namespace.Fragment, null, React__namespace.createElement(Insertion, {
            cache,
            serialized,
            isStringTag: typeof FinalTag === "string"
          }), React__namespace.createElement(FinalTag, newProps));
        });
        Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
        Styled.defaultProps = tag.defaultProps;
        Styled.__emotion_real = Styled;
        Styled.__emotion_base = baseTag;
        Styled.__emotion_styles = styles;
        Styled.__emotion_forwardProp = shouldForwardProp;
        Object.defineProperty(Styled, "toString", {
          value: function value() {
            if (targetClassName === void 0 && true) {
              return "NO_COMPONENT_SELECTOR";
            }
            return "." + targetClassName;
          }
        });
        Styled.withComponent = function(nextTag, nextOptions) {
          return createStyled2(nextTag, _extends({}, options, nextOptions, {
            shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
          })).apply(void 0, styles);
        };
        return Styled;
      };
    };
    exports["default"] = createStyled;
  }
});

// ../../node_modules/@emotion/styled/dist/emotion-styled.cjs.dev.js
var require_emotion_styled_cjs_dev = __commonJS({
  "../../node_modules/@emotion/styled/dist/emotion-styled.cjs.dev.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base_dist_emotionStyledBase = require_emotion_styled_base_cjs_dev();
    require_extends2();
    require_react();
    require_emotion_is_prop_valid_cjs();
    require_emotion_react_cjs();
    require_emotion_utils_cjs();
    require_emotion_serialize_cjs();
    require_emotion_use_insertion_effect_with_fallbacks_cjs();
    var tags = [
      "a",
      "abbr",
      "address",
      "area",
      "article",
      "aside",
      "audio",
      "b",
      "base",
      "bdi",
      "bdo",
      "big",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "col",
      "colgroup",
      "data",
      "datalist",
      "dd",
      "del",
      "details",
      "dfn",
      "dialog",
      "div",
      "dl",
      "dt",
      "em",
      "embed",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hgroup",
      "hr",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "keygen",
      "label",
      "legend",
      "li",
      "link",
      "main",
      "map",
      "mark",
      "marquee",
      "menu",
      "menuitem",
      "meta",
      "meter",
      "nav",
      "noscript",
      "object",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "param",
      "picture",
      "pre",
      "progress",
      "q",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "script",
      "section",
      "select",
      "small",
      "source",
      "span",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "title",
      "tr",
      "track",
      "u",
      "ul",
      "var",
      "video",
      "wbr",
      "circle",
      "clipPath",
      "defs",
      "ellipse",
      "foreignObject",
      "g",
      "image",
      "line",
      "linearGradient",
      "mask",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialGradient",
      "rect",
      "stop",
      "svg",
      "text",
      "tspan"
    ];
    var newStyled = base_dist_emotionStyledBase["default"].bind();
    tags.forEach(function(tagName) {
      newStyled[tagName] = newStyled(tagName);
    });
    exports["default"] = newStyled;
  }
});

// ../../node_modules/@emotion/styled/dist/emotion-styled.cjs.js
var require_emotion_styled_cjs = __commonJS({
  "../../node_modules/@emotion/styled/dist/emotion-styled.cjs.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_emotion_styled_cjs_dev();
    }
  }
});

// ../../node_modules/@chakra-ui/anatomy/dist/index.js
var require_dist8 = __commonJS({
  "../../node_modules/@chakra-ui/anatomy/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      accordionAnatomy: () => accordionAnatomy,
      alertAnatomy: () => alertAnatomy,
      anatomy: () => anatomy2,
      avatarAnatomy: () => avatarAnatomy,
      breadcrumbAnatomy: () => breadcrumbAnatomy,
      buttonAnatomy: () => buttonAnatomy,
      cardAnatomy: () => cardAnatomy,
      checkboxAnatomy: () => checkboxAnatomy,
      circularProgressAnatomy: () => circularProgressAnatomy,
      drawerAnatomy: () => drawerAnatomy,
      editableAnatomy: () => editableAnatomy,
      formAnatomy: () => formAnatomy,
      formErrorAnatomy: () => formErrorAnatomy,
      inputAnatomy: () => inputAnatomy,
      listAnatomy: () => listAnatomy,
      menuAnatomy: () => menuAnatomy,
      modalAnatomy: () => modalAnatomy,
      numberInputAnatomy: () => numberInputAnatomy,
      pinInputAnatomy: () => pinInputAnatomy,
      popoverAnatomy: () => popoverAnatomy,
      progressAnatomy: () => progressAnatomy,
      radioAnatomy: () => radioAnatomy,
      selectAnatomy: () => selectAnatomy,
      sliderAnatomy: () => sliderAnatomy,
      statAnatomy: () => statAnatomy,
      switchAnatomy: () => switchAnatomy,
      tableAnatomy: () => tableAnatomy,
      tabsAnatomy: () => tabsAnatomy,
      tagAnatomy: () => tagAnatomy
    });
    module.exports = __toCommonJS2(src_exports);
    function anatomy2(name, map = {}) {
      let called = false;
      function assert() {
        if (!called) {
          called = true;
          return;
        }
        throw new Error(
          "[anatomy] .part(...) should only be called once. Did you mean to use .extend(...) ?"
        );
      }
      function parts(...values) {
        assert();
        for (const part of values) {
          ;
          map[part] = toPart(part);
        }
        return anatomy2(name, map);
      }
      function extend(...parts2) {
        for (const part of parts2) {
          if (part in map)
            continue;
          map[part] = toPart(part);
        }
        return anatomy2(name, map);
      }
      function selectors() {
        const value = Object.fromEntries(
          Object.entries(map).map(([key, part]) => [key, part.selector])
        );
        return value;
      }
      function classnames() {
        const value = Object.fromEntries(
          Object.entries(map).map(([key, part]) => [key, part.className])
        );
        return value;
      }
      function toPart(part) {
        const el = ["container", "root"].includes(part != null ? part : "") ? [name] : [name, part];
        const attr = el.filter(Boolean).join("__");
        const className = `chakra-${attr}`;
        const partObj = {
          className,
          selector: `.${className}`,
          toString: () => part
        };
        return partObj;
      }
      const __type = {};
      return {
        parts,
        toPart,
        extend,
        selectors,
        classnames,
        get keys() {
          return Object.keys(map);
        },
        __type
      };
    }
    var accordionAnatomy = anatomy2("accordion").parts("root", "container", "button", "panel").extend("icon");
    var alertAnatomy = anatomy2("alert").parts("title", "description", "container").extend("icon", "spinner");
    var avatarAnatomy = anatomy2("avatar").parts("label", "badge", "container").extend("excessLabel", "group");
    var breadcrumbAnatomy = anatomy2("breadcrumb").parts("link", "item", "container").extend("separator");
    var buttonAnatomy = anatomy2("button").parts();
    var checkboxAnatomy = anatomy2("checkbox").parts("control", "icon", "container").extend("label");
    var circularProgressAnatomy = anatomy2("progress").parts("track", "filledTrack").extend("label");
    var drawerAnatomy = anatomy2("drawer").parts("overlay", "dialogContainer", "dialog").extend("header", "closeButton", "body", "footer");
    var editableAnatomy = anatomy2("editable").parts(
      "preview",
      "input",
      "textarea"
    );
    var formAnatomy = anatomy2("form").parts(
      "container",
      "requiredIndicator",
      "helperText"
    );
    var formErrorAnatomy = anatomy2("formError").parts("text", "icon");
    var inputAnatomy = anatomy2("input").parts("addon", "field", "element");
    var listAnatomy = anatomy2("list").parts("container", "item", "icon");
    var menuAnatomy = anatomy2("menu").parts("button", "list", "item").extend("groupTitle", "command", "divider");
    var modalAnatomy = anatomy2("modal").parts("overlay", "dialogContainer", "dialog").extend("header", "closeButton", "body", "footer");
    var numberInputAnatomy = anatomy2("numberinput").parts(
      "root",
      "field",
      "stepperGroup",
      "stepper"
    );
    var pinInputAnatomy = anatomy2("pininput").parts("field");
    var popoverAnatomy = anatomy2("popover").parts("content", "header", "body", "footer").extend("popper", "arrow", "closeButton");
    var progressAnatomy = anatomy2("progress").parts(
      "label",
      "filledTrack",
      "track"
    );
    var radioAnatomy = anatomy2("radio").parts(
      "container",
      "control",
      "label"
    );
    var selectAnatomy = anatomy2("select").parts("field", "icon");
    var sliderAnatomy = anatomy2("slider").parts(
      "container",
      "track",
      "thumb",
      "filledTrack",
      "mark"
    );
    var statAnatomy = anatomy2("stat").parts(
      "container",
      "label",
      "helpText",
      "number",
      "icon"
    );
    var switchAnatomy = anatomy2("switch").parts(
      "container",
      "track",
      "thumb"
    );
    var tableAnatomy = anatomy2("table").parts(
      "table",
      "thead",
      "tbody",
      "tr",
      "th",
      "td",
      "tfoot",
      "caption"
    );
    var tabsAnatomy = anatomy2("tabs").parts(
      "root",
      "tab",
      "tablist",
      "tabpanel",
      "tabpanels",
      "indicator"
    );
    var tagAnatomy = anatomy2("tag").parts(
      "container",
      "label",
      "closeButton"
    );
    var cardAnatomy = anatomy2("card").parts(
      "container",
      "header",
      "body",
      "footer"
    );
  }
});

// ../../node_modules/color2k/dist/index.exports.require.cjs.js
var require_index_exports_require_cjs = __commonJS({
  "../../node_modules/color2k/dist/index.exports.require.cjs.js"(exports) {
    "use strict";
    function guard(low, high, value) {
      return Math.min(Math.max(low, value), high);
    }
    var ColorError = class extends Error {
      constructor(color) {
        super(`Failed to parse color: "${color}"`);
      }
    };
    var ColorError$1 = ColorError;
    function parseToRgba(color) {
      if (typeof color !== "string")
        throw new ColorError$1(color);
      if (color.trim().toLowerCase() === "transparent")
        return [0, 0, 0, 0];
      let normalizedColor = color.trim();
      normalizedColor = namedColorRegex.test(color) ? nameToHex(color) : color;
      const reducedHexMatch = reducedHexRegex.exec(normalizedColor);
      if (reducedHexMatch) {
        const arr = Array.from(reducedHexMatch).slice(1);
        return [...arr.slice(0, 3).map((x) => parseInt(r(x, 2), 16)), parseInt(r(arr[3] || "f", 2), 16) / 255];
      }
      const hexMatch = hexRegex.exec(normalizedColor);
      if (hexMatch) {
        const arr = Array.from(hexMatch).slice(1);
        return [...arr.slice(0, 3).map((x) => parseInt(x, 16)), parseInt(arr[3] || "ff", 16) / 255];
      }
      const rgbaMatch = rgbaRegex.exec(normalizedColor);
      if (rgbaMatch) {
        const arr = Array.from(rgbaMatch).slice(1);
        return [...arr.slice(0, 3).map((x) => parseInt(x, 10)), parseFloat(arr[3] || "1")];
      }
      const hslaMatch = hslaRegex.exec(normalizedColor);
      if (hslaMatch) {
        const [h, s, l, a] = Array.from(hslaMatch).slice(1).map(parseFloat);
        if (guard(0, 100, s) !== s)
          throw new ColorError$1(color);
        if (guard(0, 100, l) !== l)
          throw new ColorError$1(color);
        return [...hslToRgb(h, s, l), Number.isNaN(a) ? 1 : a];
      }
      throw new ColorError$1(color);
    }
    function hash(str) {
      let hash2 = 5381;
      let i = str.length;
      while (i) {
        hash2 = hash2 * 33 ^ str.charCodeAt(--i);
      }
      return (hash2 >>> 0) % 2341;
    }
    var colorToInt = (x) => parseInt(x.replace(/_/g, ""), 36);
    var compressedColorMap = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((acc, next) => {
      const key = colorToInt(next.substring(0, 3));
      const hex = colorToInt(next.substring(3)).toString(16);
      let prefix = "";
      for (let i = 0; i < 6 - hex.length; i++) {
        prefix += "0";
      }
      acc[key] = `${prefix}${hex}`;
      return acc;
    }, {});
    function nameToHex(color) {
      const normalizedColorName = color.toLowerCase().trim();
      const result = compressedColorMap[hash(normalizedColorName)];
      if (!result)
        throw new ColorError$1(color);
      return `#${result}`;
    }
    var r = (str, amount) => Array.from(Array(amount)).map(() => str).join("");
    var reducedHexRegex = new RegExp(`^#${r("([a-f0-9])", 3)}([a-f0-9])?$`, "i");
    var hexRegex = new RegExp(`^#${r("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i");
    var rgbaRegex = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${r(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i");
    var hslaRegex = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i;
    var namedColorRegex = /^[a-z]+$/i;
    var roundColor = (color) => {
      return Math.round(color * 255);
    };
    var hslToRgb = (hue, saturation, lightness) => {
      let l = lightness / 100;
      if (saturation === 0) {
        return [l, l, l].map(roundColor);
      }
      const huePrime = (hue % 360 + 360) % 360 / 60;
      const chroma = (1 - Math.abs(2 * l - 1)) * (saturation / 100);
      const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
      let red = 0;
      let green = 0;
      let blue = 0;
      if (huePrime >= 0 && huePrime < 1) {
        red = chroma;
        green = secondComponent;
      } else if (huePrime >= 1 && huePrime < 2) {
        red = secondComponent;
        green = chroma;
      } else if (huePrime >= 2 && huePrime < 3) {
        green = chroma;
        blue = secondComponent;
      } else if (huePrime >= 3 && huePrime < 4) {
        green = secondComponent;
        blue = chroma;
      } else if (huePrime >= 4 && huePrime < 5) {
        red = secondComponent;
        blue = chroma;
      } else if (huePrime >= 5 && huePrime < 6) {
        red = chroma;
        blue = secondComponent;
      }
      const lightnessModification = l - chroma / 2;
      const finalRed = red + lightnessModification;
      const finalGreen = green + lightnessModification;
      const finalBlue = blue + lightnessModification;
      return [finalRed, finalGreen, finalBlue].map(roundColor);
    };
    function parseToHsla(color) {
      const [red, green, blue, alpha] = parseToRgba(color).map((value, index) => index === 3 ? value : value / 255);
      const max = Math.max(red, green, blue);
      const min = Math.min(red, green, blue);
      const lightness = (max + min) / 2;
      if (max === min)
        return [0, 0, lightness, alpha];
      const delta = max - min;
      const saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);
      const hue = 60 * (red === max ? (green - blue) / delta + (green < blue ? 6 : 0) : green === max ? (blue - red) / delta + 2 : (red - green) / delta + 4);
      return [hue, saturation, lightness, alpha];
    }
    function hsla(hue, saturation, lightness, alpha) {
      return `hsla(${(hue % 360).toFixed()}, ${guard(0, 100, saturation * 100).toFixed()}%, ${guard(0, 100, lightness * 100).toFixed()}%, ${parseFloat(guard(0, 1, alpha).toFixed(3))})`;
    }
    function adjustHue(color, degrees) {
      const [h, s, l, a] = parseToHsla(color);
      return hsla(h + degrees, s, l, a);
    }
    function darken(color, amount) {
      const [hue, saturation, lightness, alpha] = parseToHsla(color);
      return hsla(hue, saturation, lightness - amount, alpha);
    }
    function desaturate(color, amount) {
      const [h, s, l, a] = parseToHsla(color);
      return hsla(h, s - amount, l, a);
    }
    function getLuminance(color) {
      if (color === "transparent")
        return 0;
      function f(x) {
        const channel = x / 255;
        return channel <= 0.03928 ? channel / 12.92 : Math.pow((channel + 0.055) / 1.055, 2.4);
      }
      const [r2, g, b] = parseToRgba(color);
      return 0.2126 * f(r2) + 0.7152 * f(g) + 0.0722 * f(b);
    }
    function getContrast(color1, color2) {
      const luminance1 = getLuminance(color1);
      const luminance2 = getLuminance(color2);
      return luminance1 > luminance2 ? (luminance1 + 0.05) / (luminance2 + 0.05) : (luminance2 + 0.05) / (luminance1 + 0.05);
    }
    function rgba(red, green, blue, alpha) {
      return `rgba(${guard(0, 255, red).toFixed()}, ${guard(0, 255, green).toFixed()}, ${guard(0, 255, blue).toFixed()}, ${parseFloat(guard(0, 1, alpha).toFixed(3))})`;
    }
    function mix(color1, color2, weight) {
      const normalize = (n, index) => index === 3 ? n : n / 255;
      const [r1, g1, b1, a1] = parseToRgba(color1).map(normalize);
      const [r2, g2, b2, a2] = parseToRgba(color2).map(normalize);
      const alphaDelta = a2 - a1;
      const normalizedWeight = weight * 2 - 1;
      const combinedWeight = normalizedWeight * alphaDelta === -1 ? normalizedWeight : normalizedWeight + alphaDelta / (1 + normalizedWeight * alphaDelta);
      const weight2 = (combinedWeight + 1) / 2;
      const weight1 = 1 - weight2;
      const r3 = (r1 * weight1 + r2 * weight2) * 255;
      const g = (g1 * weight1 + g2 * weight2) * 255;
      const b = (b1 * weight1 + b2 * weight2) * 255;
      const a = a2 * weight + a1 * (1 - weight);
      return rgba(r3, g, b, a);
    }
    function getScale(...colors) {
      return (n) => {
        const lastIndex = colors.length - 1;
        const lowIndex = guard(0, lastIndex, Math.floor(n * lastIndex));
        const highIndex = guard(0, lastIndex, Math.ceil(n * lastIndex));
        const color1 = colors[lowIndex];
        const color2 = colors[highIndex];
        const unit = 1 / lastIndex;
        const weight = (n - unit * lowIndex) / unit;
        return mix(color1, color2, weight);
      };
    }
    var guidelines = {
      decorative: 1.5,
      readable: 3,
      aa: 4.5,
      aaa: 7
    };
    function hasBadContrast(color, standard = "aa", background = "#fff") {
      return getContrast(color, background) < guidelines[standard];
    }
    function lighten(color, amount) {
      return darken(color, -amount);
    }
    function transparentize(color, amount) {
      const [r2, g, b, a] = parseToRgba(color);
      return rgba(r2, g, b, a - amount);
    }
    function opacify(color, amount) {
      return transparentize(color, -amount);
    }
    function readableColorIsBlack(color) {
      return getLuminance(color) > 0.179;
    }
    function readableColor(color) {
      return readableColorIsBlack(color) ? "#000" : "#fff";
    }
    function saturate(color, amount) {
      return desaturate(color, -amount);
    }
    function toHex(color) {
      const [r2, g, b, a] = parseToRgba(color);
      let hex = (x) => {
        const h = guard(0, 255, x).toString(16);
        return h.length === 1 ? `0${h}` : h;
      };
      return `#${hex(r2)}${hex(g)}${hex(b)}${a < 1 ? hex(Math.round(a * 255)) : ""}`;
    }
    function toRgba(color) {
      return rgba(...parseToRgba(color));
    }
    function toHsla(color) {
      return hsla(...parseToHsla(color));
    }
    exports.ColorError = ColorError$1;
    exports.adjustHue = adjustHue;
    exports.darken = darken;
    exports.desaturate = desaturate;
    exports.getContrast = getContrast;
    exports.getLuminance = getLuminance;
    exports.getScale = getScale;
    exports.guard = guard;
    exports.hasBadContrast = hasBadContrast;
    exports.hsla = hsla;
    exports.lighten = lighten;
    exports.mix = mix;
    exports.opacify = opacify;
    exports.parseToHsla = parseToHsla;
    exports.parseToRgba = parseToRgba;
    exports.readableColor = readableColor;
    exports.readableColorIsBlack = readableColorIsBlack;
    exports.rgba = rgba;
    exports.saturate = saturate;
    exports.toHex = toHex;
    exports.toHsla = toHsla;
    exports.toRgba = toRgba;
    exports.transparentize = transparentize;
  }
});

// ../../node_modules/@chakra-ui/theme-tools/dist/index.js
var require_dist9 = __commonJS({
  "../../node_modules/@chakra-ui/theme-tools/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      addPrefix: () => addPrefix,
      anatomy: () => import_anatomy.anatomy,
      blacken: () => blacken,
      calc: () => calc,
      complementary: () => complementary,
      contrast: () => contrast,
      createBreakpoints: () => createBreakpoints,
      cssVar: () => cssVar,
      darken: () => darken,
      generateStripe: () => generateStripe,
      getColor: () => getColor,
      isAccessible: () => isAccessible,
      isDark: () => isDark,
      isDecimal: () => isDecimal,
      isLight: () => isLight,
      isReadable: () => isReadable,
      lighten: () => lighten,
      mode: () => mode,
      orient: () => orient,
      randomColor: () => randomColor,
      readability: () => readability,
      toVar: () => toVar,
      toVarRef: () => toVarRef,
      tone: () => tone,
      transparentize: () => transparentize,
      whiten: () => whiten
    });
    module.exports = __toCommonJS2(src_exports);
    var import_anatomy = require_dist8();
    var import_color2k = require_index_exports_require_cjs();
    function dlv_es_default(t, e, l, n, r) {
      for (e = e.split ? e.split(".") : e, n = 0; n < e.length; n++)
        t = t ? t[e[n]] : r;
      return t === r ? l : t;
    }
    var isEmptyObject = (obj) => Object.keys(obj).length === 0;
    var getColor = (theme, color, fallback) => {
      const hex = dlv_es_default(theme, `colors.${color}`, color);
      try {
        (0, import_color2k.toHex)(hex);
        return hex;
      } catch {
        return fallback != null ? fallback : "#000000";
      }
    };
    var getBrightness = (color) => {
      const [r, g, b] = (0, import_color2k.parseToRgba)(color);
      return (r * 299 + g * 587 + b * 114) / 1e3;
    };
    var tone = (color) => (theme) => {
      const hex = getColor(theme, color);
      const brightness = getBrightness(hex);
      const isDark2 = brightness < 128;
      return isDark2 ? "dark" : "light";
    };
    var isDark = (color) => (theme) => tone(color)(theme) === "dark";
    var isLight = (color) => (theme) => tone(color)(theme) === "light";
    var transparentize = (color, opacity) => (theme) => {
      const raw = getColor(theme, color);
      return (0, import_color2k.transparentize)(raw, 1 - opacity);
    };
    var whiten = (color, amount) => (theme) => {
      const raw = getColor(theme, color);
      return (0, import_color2k.toHex)((0, import_color2k.mix)(raw, "#fff", amount));
    };
    var blacken = (color, amount) => (theme) => {
      const raw = getColor(theme, color);
      return (0, import_color2k.toHex)((0, import_color2k.mix)(raw, "#000", amount / 100));
    };
    var darken = (color, amount) => (theme) => {
      const raw = getColor(theme, color);
      return (0, import_color2k.toHex)((0, import_color2k.darken)(raw, amount / 100));
    };
    var lighten = (color, amount) => (theme) => {
      const raw = getColor(theme, color);
      (0, import_color2k.toHex)((0, import_color2k.lighten)(raw, amount / 100));
    };
    var contrast = (fg, bg) => (theme) => (0, import_color2k.getContrast)(getColor(theme, bg), getColor(theme, fg));
    var isAccessible = (textColor, bgColor, options) => (theme) => isReadable(getColor(theme, bgColor), getColor(theme, textColor), options);
    function isReadable(color1, color2, wcag2 = { level: "AA", size: "small" }) {
      var _a, _b;
      const readabilityLevel = readability(color1, color2);
      switch (((_a = wcag2.level) != null ? _a : "AA") + ((_b = wcag2.size) != null ? _b : "small")) {
        case "AAsmall":
        case "AAAlarge":
          return readabilityLevel >= 4.5;
        case "AAlarge":
          return readabilityLevel >= 3;
        case "AAAsmall":
          return readabilityLevel >= 7;
        default:
          return false;
      }
    }
    function readability(color1, color2) {
      return (Math.max((0, import_color2k.getLuminance)(color1), (0, import_color2k.getLuminance)(color2)) + 0.05) / (Math.min((0, import_color2k.getLuminance)(color1), (0, import_color2k.getLuminance)(color2)) + 0.05);
    }
    var complementary = (color) => (theme) => {
      const raw = getColor(theme, color);
      const hsl = (0, import_color2k.parseToHsla)(raw);
      const complementHsl = Object.assign(hsl, [
        (hsl[0] + 180) % 360
      ]);
      return (0, import_color2k.toHex)((0, import_color2k.hsla)(...complementHsl));
    };
    function generateStripe(size = "1rem", color = "rgba(255, 255, 255, 0.15)") {
      return {
        backgroundImage: `linear-gradient(
    45deg,
    ${color} 25%,
    transparent 25%,
    transparent 50%,
    ${color} 50%,
    ${color} 75%,
    transparent 75%,
    transparent
  )`,
        backgroundSize: `${size} ${size}`
      };
    }
    var randomHex = () => `#${Math.floor(Math.random() * 16777215).toString(16).padEnd(6, "0")}`;
    function randomColor(opts) {
      const fallback = randomHex();
      if (!opts || isEmptyObject(opts)) {
        return fallback;
      }
      if (opts.string && opts.colors) {
        return randomColorFromList(opts.string, opts.colors);
      }
      if (opts.string && !opts.colors) {
        return randomColorFromString(opts.string);
      }
      if (opts.colors && !opts.string) {
        return randomFromList(opts.colors);
      }
      return fallback;
    }
    function randomColorFromString(str) {
      let hash = 0;
      if (str.length === 0)
        return hash.toString();
      for (let i = 0; i < str.length; i += 1) {
        hash = str.charCodeAt(i) + ((hash << 5) - hash);
        hash = hash & hash;
      }
      let color = "#";
      for (let j = 0; j < 3; j += 1) {
        const value = hash >> j * 8 & 255;
        color += `00${value.toString(16)}`.substr(-2);
      }
      return color;
    }
    function randomColorFromList(str, list) {
      let index = 0;
      if (str.length === 0)
        return list[0];
      for (let i = 0; i < str.length; i += 1) {
        index = str.charCodeAt(i) + ((index << 5) - index);
        index = index & index;
      }
      index = (index % list.length + list.length) % list.length;
      return list[index];
    }
    function randomFromList(list) {
      return list[Math.floor(Math.random() * list.length)];
    }
    function mode(light, dark) {
      return (props) => props.colorMode === "dark" ? dark : light;
    }
    function orient(options) {
      const { orientation, vertical, horizontal } = options;
      if (!orientation)
        return {};
      return orientation === "vertical" ? vertical : horizontal;
    }
    var import_shared_utils = require_dist3();
    var createBreakpoints = (config) => {
      (0, import_shared_utils.warn)({
        condition: true,
        message: [
          `[chakra-ui]: createBreakpoints(...) will be deprecated pretty soon`,
          `simply pass the breakpoints as an object. Remove the createBreakpoints(..) call`
        ].join("")
      });
      return { base: "0em", ...config };
    };
    var import_shared_utils2 = require_dist3();
    function toRef(operand) {
      if ((0, import_shared_utils2.isObject)(operand) && operand.reference) {
        return operand.reference;
      }
      return String(operand);
    }
    var toExpr = (operator, ...operands) => operands.map(toRef).join(` ${operator} `).replace(/calc/g, "");
    var add = (...operands) => `calc(${toExpr("+", ...operands)})`;
    var subtract = (...operands) => `calc(${toExpr("-", ...operands)})`;
    var multiply = (...operands) => `calc(${toExpr("*", ...operands)})`;
    var divide = (...operands) => `calc(${toExpr("/", ...operands)})`;
    var negate = (x) => {
      const value = toRef(x);
      if (value != null && !Number.isNaN(parseFloat(value))) {
        return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
      }
      return multiply(value, -1);
    };
    var calc = Object.assign(
      (x) => ({
        add: (...operands) => calc(add(x, ...operands)),
        subtract: (...operands) => calc(subtract(x, ...operands)),
        multiply: (...operands) => calc(multiply(x, ...operands)),
        divide: (...operands) => calc(divide(x, ...operands)),
        negate: () => calc(negate(x)),
        toString: () => x.toString()
      }),
      {
        add,
        subtract,
        multiply,
        divide,
        negate
      }
    );
    function isDecimal(value) {
      return !Number.isInteger(parseFloat(value.toString()));
    }
    function replaceWhiteSpace(value, replaceValue = "-") {
      return value.replace(/\s+/g, replaceValue);
    }
    function escape(value) {
      const valueStr = replaceWhiteSpace(value.toString());
      if (valueStr.includes("\\."))
        return value;
      return isDecimal(value) ? valueStr.replace(".", `\\.`) : value;
    }
    function addPrefix(value, prefix = "") {
      return [prefix, escape(value)].filter(Boolean).join("-");
    }
    function toVarRef(name, fallback) {
      return `var(${escape(name)}${fallback ? `, ${fallback}` : ""})`;
    }
    function toVar(value, prefix = "") {
      return `--${addPrefix(value, prefix)}`;
    }
    function cssVar(name, options) {
      const cssVariable = toVar(name, options == null ? void 0 : options.prefix);
      return {
        variable: cssVariable,
        reference: toVarRef(cssVariable, getFallback(options == null ? void 0 : options.fallback))
      };
    }
    function getFallback(fallback) {
      if (typeof fallback === "string")
        return fallback;
      return fallback == null ? void 0 : fallback.reference;
    }
  }
});

// ../../node_modules/@chakra-ui/theme/dist/index.js
var require_dist10 = __commonJS({
  "../../node_modules/@chakra-ui/theme/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      baseTheme: () => baseTheme,
      default: () => src_default,
      isChakraTheme: () => isChakraTheme,
      requiredChakraThemeKeys: () => requiredChakraThemeKeys,
      theme: () => theme
    });
    module.exports = __toCommonJS2(src_exports);
    var import_anatomy = require_dist8();
    var import_styled_system = require_dist4();
    var { definePartsStyle, defineMultiStyleConfig } = (0, import_styled_system.createMultiStyleConfigHelpers)(import_anatomy.accordionAnatomy.keys);
    var baseStyleContainer = (0, import_styled_system.defineStyle)({
      borderTopWidth: "1px",
      borderColor: "inherit",
      _last: {
        borderBottomWidth: "1px"
      }
    });
    var baseStyleButton = (0, import_styled_system.defineStyle)({
      transitionProperty: "common",
      transitionDuration: "normal",
      fontSize: "md",
      _focusVisible: {
        boxShadow: "outline"
      },
      _hover: {
        bg: "blackAlpha.50"
      },
      _disabled: {
        opacity: 0.4,
        cursor: "not-allowed"
      },
      px: "4",
      py: "2"
    });
    var baseStylePanel = (0, import_styled_system.defineStyle)({
      pt: "2",
      px: "4",
      pb: "5"
    });
    var baseStyleIcon = (0, import_styled_system.defineStyle)({
      fontSize: "1.25em"
    });
    var baseStyle = definePartsStyle({
      container: baseStyleContainer,
      button: baseStyleButton,
      panel: baseStylePanel,
      icon: baseStyleIcon
    });
    var accordionTheme = defineMultiStyleConfig({ baseStyle });
    var import_anatomy2 = require_dist8();
    var import_styled_system2 = require_dist4();
    var import_theme_tools = require_dist9();
    var { definePartsStyle: definePartsStyle2, defineMultiStyleConfig: defineMultiStyleConfig2 } = (0, import_styled_system2.createMultiStyleConfigHelpers)(import_anatomy2.alertAnatomy.keys);
    var $fg = (0, import_styled_system2.cssVar)("alert-fg");
    var $bg = (0, import_styled_system2.cssVar)("alert-bg");
    var baseStyle2 = definePartsStyle2({
      container: {
        bg: $bg.reference,
        px: "4",
        py: "3"
      },
      title: {
        fontWeight: "bold",
        lineHeight: "6",
        marginEnd: "2"
      },
      description: {
        lineHeight: "6"
      },
      icon: {
        color: $fg.reference,
        flexShrink: 0,
        marginEnd: "3",
        w: "5",
        h: "6"
      },
      spinner: {
        color: $fg.reference,
        flexShrink: 0,
        marginEnd: "3",
        w: "5",
        h: "5"
      }
    });
    function getBg(props) {
      const { theme: theme2, colorScheme: c } = props;
      const darkBg = (0, import_theme_tools.transparentize)(`${c}.200`, 0.16)(theme2);
      return {
        light: `colors.${c}.100`,
        dark: darkBg
      };
    }
    var variantSubtle = definePartsStyle2((props) => {
      const { colorScheme: c } = props;
      const bg = getBg(props);
      return {
        container: {
          [$fg.variable]: `colors.${c}.500`,
          [$bg.variable]: bg.light,
          _dark: {
            [$fg.variable]: `colors.${c}.200`,
            [$bg.variable]: bg.dark
          }
        }
      };
    });
    var variantLeftAccent = definePartsStyle2((props) => {
      const { colorScheme: c } = props;
      const bg = getBg(props);
      return {
        container: {
          [$fg.variable]: `colors.${c}.500`,
          [$bg.variable]: bg.light,
          _dark: {
            [$fg.variable]: `colors.${c}.200`,
            [$bg.variable]: bg.dark
          },
          paddingStart: "3",
          borderStartWidth: "4px",
          borderStartColor: $fg.reference
        }
      };
    });
    var variantTopAccent = definePartsStyle2((props) => {
      const { colorScheme: c } = props;
      const bg = getBg(props);
      return {
        container: {
          [$fg.variable]: `colors.${c}.500`,
          [$bg.variable]: bg.light,
          _dark: {
            [$fg.variable]: `colors.${c}.200`,
            [$bg.variable]: bg.dark
          },
          pt: "2",
          borderTopWidth: "4px",
          borderTopColor: $fg.reference
        }
      };
    });
    var variantSolid = definePartsStyle2((props) => {
      const { colorScheme: c } = props;
      return {
        container: {
          [$fg.variable]: `colors.white`,
          [$bg.variable]: `colors.${c}.500`,
          _dark: {
            [$fg.variable]: `colors.gray.900`,
            [$bg.variable]: `colors.${c}.200`
          },
          color: $fg.reference
        }
      };
    });
    var variants = {
      subtle: variantSubtle,
      "left-accent": variantLeftAccent,
      "top-accent": variantTopAccent,
      solid: variantSolid
    };
    var alertTheme = defineMultiStyleConfig2({
      baseStyle: baseStyle2,
      variants,
      defaultProps: {
        variant: "subtle",
        colorScheme: "blue"
      }
    });
    var import_anatomy3 = require_dist8();
    var import_styled_system3 = require_dist4();
    var import_theme_tools2 = require_dist9();
    var spacing = {
      px: "1px",
      0.5: "0.125rem",
      1: "0.25rem",
      1.5: "0.375rem",
      2: "0.5rem",
      2.5: "0.625rem",
      3: "0.75rem",
      3.5: "0.875rem",
      4: "1rem",
      5: "1.25rem",
      6: "1.5rem",
      7: "1.75rem",
      8: "2rem",
      9: "2.25rem",
      10: "2.5rem",
      12: "3rem",
      14: "3.5rem",
      16: "4rem",
      20: "5rem",
      24: "6rem",
      28: "7rem",
      32: "8rem",
      36: "9rem",
      40: "10rem",
      44: "11rem",
      48: "12rem",
      52: "13rem",
      56: "14rem",
      60: "15rem",
      64: "16rem",
      72: "18rem",
      80: "20rem",
      96: "24rem"
    };
    var largeSizes = {
      max: "max-content",
      min: "min-content",
      full: "100%",
      "3xs": "14rem",
      "2xs": "16rem",
      xs: "20rem",
      sm: "24rem",
      md: "28rem",
      lg: "32rem",
      xl: "36rem",
      "2xl": "42rem",
      "3xl": "48rem",
      "4xl": "56rem",
      "5xl": "64rem",
      "6xl": "72rem",
      "7xl": "80rem",
      "8xl": "90rem",
      prose: "60ch"
    };
    var container = {
      sm: "640px",
      md: "768px",
      lg: "1024px",
      xl: "1280px"
    };
    var sizes = {
      ...spacing,
      ...largeSizes,
      container
    };
    var sizes_default = sizes;
    var isFunction = (value) => typeof value === "function";
    function runIfFn(valueOrFn, ...args) {
      return isFunction(valueOrFn) ? valueOrFn(...args) : valueOrFn;
    }
    var { definePartsStyle: definePartsStyle3, defineMultiStyleConfig: defineMultiStyleConfig3 } = (0, import_styled_system3.createMultiStyleConfigHelpers)(import_anatomy3.avatarAnatomy.keys);
    var $border = (0, import_styled_system3.cssVar)("avatar-border-color");
    var $bg2 = (0, import_styled_system3.cssVar)("avatar-bg");
    var baseStyleBadge = (0, import_styled_system3.defineStyle)({
      borderRadius: "full",
      border: "0.2em solid",
      [$border.variable]: "white",
      _dark: {
        [$border.variable]: "colors.gray.800"
      },
      borderColor: $border.reference
    });
    var baseStyleExcessLabel = (0, import_styled_system3.defineStyle)({
      [$bg2.variable]: "colors.gray.200",
      _dark: {
        [$bg2.variable]: "colors.whiteAlpha.400"
      },
      bgColor: $bg2.reference
    });
    var $avatarBg = (0, import_styled_system3.cssVar)("avatar-background");
    var baseStyleContainer2 = (0, import_styled_system3.defineStyle)((props) => {
      const { name, theme: theme2 } = props;
      const bg = name ? (0, import_theme_tools2.randomColor)({ string: name }) : "colors.gray.400";
      const isBgDark = (0, import_theme_tools2.isDark)(bg)(theme2);
      let color = "white";
      if (!isBgDark)
        color = "gray.800";
      return {
        bg: $avatarBg.reference,
        "&:not([data-loaded])": {
          [$avatarBg.variable]: bg
        },
        color,
        [$border.variable]: "colors.white",
        _dark: {
          [$border.variable]: "colors.gray.800"
        },
        borderColor: $border.reference,
        verticalAlign: "top"
      };
    });
    var baseStyle3 = definePartsStyle3((props) => ({
      badge: runIfFn(baseStyleBadge, props),
      excessLabel: runIfFn(baseStyleExcessLabel, props),
      container: runIfFn(baseStyleContainer2, props)
    }));
    function getSize(size2) {
      const themeSize = size2 !== "100%" ? sizes_default[size2] : void 0;
      return definePartsStyle3({
        container: {
          width: size2,
          height: size2,
          fontSize: `calc(${themeSize != null ? themeSize : size2} / 2.5)`
        },
        excessLabel: {
          width: size2,
          height: size2
        },
        label: {
          fontSize: `calc(${themeSize != null ? themeSize : size2} / 2.5)`,
          lineHeight: size2 !== "100%" ? themeSize != null ? themeSize : size2 : void 0
        }
      });
    }
    var sizes2 = {
      "2xs": getSize(4),
      xs: getSize(6),
      sm: getSize(8),
      md: getSize(12),
      lg: getSize(16),
      xl: getSize(24),
      "2xl": getSize(32),
      full: getSize("100%")
    };
    var avatarTheme = defineMultiStyleConfig3({
      baseStyle: baseStyle3,
      sizes: sizes2,
      defaultProps: { size: "md" }
    });
    var import_styled_system4 = require_dist4();
    var import_theme_tools3 = require_dist9();
    var vars = (0, import_styled_system4.defineCssVars)("badge", ["bg", "color", "shadow"]);
    var baseStyle4 = (0, import_styled_system4.defineStyle)({
      px: 1,
      textTransform: "uppercase",
      fontSize: "xs",
      borderRadius: "sm",
      fontWeight: "bold",
      bg: vars.bg.reference,
      color: vars.color.reference,
      boxShadow: vars.shadow.reference
    });
    var variantSolid2 = (0, import_styled_system4.defineStyle)((props) => {
      const { colorScheme: c, theme: theme2 } = props;
      const dark = (0, import_theme_tools3.transparentize)(`${c}.500`, 0.6)(theme2);
      return {
        [vars.bg.variable]: `colors.${c}.500`,
        [vars.color.variable]: `colors.white`,
        _dark: {
          [vars.bg.variable]: dark,
          [vars.color.variable]: `colors.whiteAlpha.800`
        }
      };
    });
    var variantSubtle2 = (0, import_styled_system4.defineStyle)((props) => {
      const { colorScheme: c, theme: theme2 } = props;
      const darkBg = (0, import_theme_tools3.transparentize)(`${c}.200`, 0.16)(theme2);
      return {
        [vars.bg.variable]: `colors.${c}.100`,
        [vars.color.variable]: `colors.${c}.800`,
        _dark: {
          [vars.bg.variable]: darkBg,
          [vars.color.variable]: `colors.${c}.200`
        }
      };
    });
    var variantOutline = (0, import_styled_system4.defineStyle)((props) => {
      const { colorScheme: c, theme: theme2 } = props;
      const darkColor = (0, import_theme_tools3.transparentize)(`${c}.200`, 0.8)(theme2);
      return {
        [vars.color.variable]: `colors.${c}.500`,
        _dark: {
          [vars.color.variable]: darkColor
        },
        [vars.shadow.variable]: `inset 0 0 0px 1px ${vars.color.reference}`
      };
    });
    var variants2 = {
      solid: variantSolid2,
      subtle: variantSubtle2,
      outline: variantOutline
    };
    var badgeTheme = (0, import_styled_system4.defineStyleConfig)({
      baseStyle: baseStyle4,
      variants: variants2,
      defaultProps: {
        variant: "subtle",
        colorScheme: "gray"
      }
    });
    var import_anatomy4 = require_dist8();
    var import_styled_system5 = require_dist4();
    var { defineMultiStyleConfig: defineMultiStyleConfig4, definePartsStyle: definePartsStyle4 } = (0, import_styled_system5.createMultiStyleConfigHelpers)(import_anatomy4.breadcrumbAnatomy.keys);
    var $decor = (0, import_styled_system5.cssVar)("breadcrumb-link-decor");
    var baseStyleLink = (0, import_styled_system5.defineStyle)({
      transitionProperty: "common",
      transitionDuration: "fast",
      transitionTimingFunction: "ease-out",
      outline: "none",
      color: "inherit",
      textDecoration: $decor.reference,
      [$decor.variable]: "none",
      "&:not([aria-current=page])": {
        cursor: "pointer",
        _hover: {
          [$decor.variable]: "underline"
        },
        _focusVisible: {
          boxShadow: "outline"
        }
      }
    });
    var baseStyle5 = definePartsStyle4({
      link: baseStyleLink
    });
    var breadcrumbTheme = defineMultiStyleConfig4({
      baseStyle: baseStyle5
    });
    var import_styled_system6 = require_dist4();
    var import_theme_tools4 = require_dist9();
    var baseStyle6 = (0, import_styled_system6.defineStyle)({
      lineHeight: "1.2",
      borderRadius: "md",
      fontWeight: "semibold",
      transitionProperty: "common",
      transitionDuration: "normal",
      _focusVisible: {
        boxShadow: "outline"
      },
      _disabled: {
        opacity: 0.4,
        cursor: "not-allowed",
        boxShadow: "none"
      },
      _hover: {
        _disabled: {
          bg: "initial"
        }
      }
    });
    var variantGhost = (0, import_styled_system6.defineStyle)((props) => {
      const { colorScheme: c, theme: theme2 } = props;
      if (c === "gray") {
        return {
          color: (0, import_theme_tools4.mode)(`inherit`, `whiteAlpha.900`)(props),
          _hover: {
            bg: (0, import_theme_tools4.mode)(`gray.100`, `whiteAlpha.200`)(props)
          },
          _active: { bg: (0, import_theme_tools4.mode)(`gray.200`, `whiteAlpha.300`)(props) }
        };
      }
      const darkHoverBg = (0, import_theme_tools4.transparentize)(`${c}.200`, 0.12)(theme2);
      const darkActiveBg = (0, import_theme_tools4.transparentize)(`${c}.200`, 0.24)(theme2);
      return {
        color: (0, import_theme_tools4.mode)(`${c}.600`, `${c}.200`)(props),
        bg: "transparent",
        _hover: {
          bg: (0, import_theme_tools4.mode)(`${c}.50`, darkHoverBg)(props)
        },
        _active: {
          bg: (0, import_theme_tools4.mode)(`${c}.100`, darkActiveBg)(props)
        }
      };
    });
    var variantOutline2 = (0, import_styled_system6.defineStyle)((props) => {
      const { colorScheme: c } = props;
      const borderColor = (0, import_theme_tools4.mode)(`gray.200`, `whiteAlpha.300`)(props);
      return {
        border: "1px solid",
        borderColor: c === "gray" ? borderColor : "currentColor",
        ".chakra-button__group[data-attached][data-orientation=horizontal] > &:not(:last-of-type)": { marginEnd: "-1px" },
        ".chakra-button__group[data-attached][data-orientation=vertical] > &:not(:last-of-type)": { marginBottom: "-1px" },
        ...runIfFn(variantGhost, props)
      };
    });
    var accessibleColorMap = {
      yellow: {
        bg: "yellow.400",
        color: "black",
        hoverBg: "yellow.500",
        activeBg: "yellow.600"
      },
      cyan: {
        bg: "cyan.400",
        color: "black",
        hoverBg: "cyan.500",
        activeBg: "cyan.600"
      }
    };
    var variantSolid3 = (0, import_styled_system6.defineStyle)((props) => {
      var _a8;
      const { colorScheme: c } = props;
      if (c === "gray") {
        const bg2 = (0, import_theme_tools4.mode)(`gray.100`, `whiteAlpha.200`)(props);
        return {
          bg: bg2,
          _hover: {
            bg: (0, import_theme_tools4.mode)(`gray.200`, `whiteAlpha.300`)(props),
            _disabled: {
              bg: bg2
            }
          },
          _active: { bg: (0, import_theme_tools4.mode)(`gray.300`, `whiteAlpha.400`)(props) }
        };
      }
      const {
        bg = `${c}.500`,
        color = "white",
        hoverBg = `${c}.600`,
        activeBg = `${c}.700`
      } = (_a8 = accessibleColorMap[c]) != null ? _a8 : {};
      const background = (0, import_theme_tools4.mode)(bg, `${c}.200`)(props);
      return {
        bg: background,
        color: (0, import_theme_tools4.mode)(color, `gray.800`)(props),
        _hover: {
          bg: (0, import_theme_tools4.mode)(hoverBg, `${c}.300`)(props),
          _disabled: {
            bg: background
          }
        },
        _active: { bg: (0, import_theme_tools4.mode)(activeBg, `${c}.400`)(props) }
      };
    });
    var variantLink = (0, import_styled_system6.defineStyle)((props) => {
      const { colorScheme: c } = props;
      return {
        padding: 0,
        height: "auto",
        lineHeight: "normal",
        verticalAlign: "baseline",
        color: (0, import_theme_tools4.mode)(`${c}.500`, `${c}.200`)(props),
        _hover: {
          textDecoration: "underline",
          _disabled: {
            textDecoration: "none"
          }
        },
        _active: {
          color: (0, import_theme_tools4.mode)(`${c}.700`, `${c}.500`)(props)
        }
      };
    });
    var variantUnstyled = (0, import_styled_system6.defineStyle)({
      bg: "none",
      color: "inherit",
      display: "inline",
      lineHeight: "inherit",
      m: "0",
      p: "0"
    });
    var variants3 = {
      ghost: variantGhost,
      outline: variantOutline2,
      solid: variantSolid3,
      link: variantLink,
      unstyled: variantUnstyled
    };
    var sizes3 = {
      lg: (0, import_styled_system6.defineStyle)({
        h: "12",
        minW: "12",
        fontSize: "lg",
        px: "6"
      }),
      md: (0, import_styled_system6.defineStyle)({
        h: "10",
        minW: "10",
        fontSize: "md",
        px: "4"
      }),
      sm: (0, import_styled_system6.defineStyle)({
        h: "8",
        minW: "8",
        fontSize: "sm",
        px: "3"
      }),
      xs: (0, import_styled_system6.defineStyle)({
        h: "6",
        minW: "6",
        fontSize: "xs",
        px: "2"
      })
    };
    var buttonTheme = (0, import_styled_system6.defineStyleConfig)({
      baseStyle: baseStyle6,
      variants: variants3,
      sizes: sizes3,
      defaultProps: {
        variant: "solid",
        size: "md",
        colorScheme: "gray"
      }
    });
    var import_anatomy5 = require_dist8();
    var import_styled_system7 = require_dist4();
    var { definePartsStyle: definePartsStyle5, defineMultiStyleConfig: defineMultiStyleConfig5 } = (0, import_styled_system7.createMultiStyleConfigHelpers)(import_anatomy5.cardAnatomy.keys);
    var $bg3 = (0, import_styled_system7.cssVar)("card-bg");
    var $padding = (0, import_styled_system7.cssVar)("card-padding");
    var $shadow = (0, import_styled_system7.cssVar)("card-shadow");
    var $radius = (0, import_styled_system7.cssVar)("card-radius");
    var $border2 = (0, import_styled_system7.cssVar)("card-border-width", "0");
    var $borderColor = (0, import_styled_system7.cssVar)("card-border-color");
    var baseStyle7 = definePartsStyle5({
      container: {
        [$bg3.variable]: "colors.chakra-body-bg",
        backgroundColor: $bg3.reference,
        boxShadow: $shadow.reference,
        borderRadius: $radius.reference,
        color: "chakra-body-text",
        borderWidth: $border2.reference,
        borderColor: $borderColor.reference
      },
      body: {
        padding: $padding.reference,
        flex: "1 1 0%"
      },
      header: {
        padding: $padding.reference
      },
      footer: {
        padding: $padding.reference
      }
    });
    var sizes4 = {
      sm: definePartsStyle5({
        container: {
          [$radius.variable]: "radii.base",
          [$padding.variable]: "space.3"
        }
      }),
      md: definePartsStyle5({
        container: {
          [$radius.variable]: "radii.md",
          [$padding.variable]: "space.5"
        }
      }),
      lg: definePartsStyle5({
        container: {
          [$radius.variable]: "radii.xl",
          [$padding.variable]: "space.7"
        }
      })
    };
    var variants4 = {
      elevated: definePartsStyle5({
        container: {
          [$shadow.variable]: "shadows.base",
          _dark: {
            [$bg3.variable]: "colors.gray.700"
          }
        }
      }),
      outline: definePartsStyle5({
        container: {
          [$border2.variable]: "1px",
          [$borderColor.variable]: "colors.chakra-border-color"
        }
      }),
      filled: definePartsStyle5({
        container: {
          [$bg3.variable]: "colors.chakra-subtle-bg"
        }
      }),
      unstyled: {
        body: {
          [$padding.variable]: 0
        },
        header: {
          [$padding.variable]: 0
        },
        footer: {
          [$padding.variable]: 0
        }
      }
    };
    var cardTheme = defineMultiStyleConfig5({
      baseStyle: baseStyle7,
      variants: variants4,
      sizes: sizes4,
      defaultProps: {
        variant: "elevated",
        size: "md"
      }
    });
    var import_anatomy6 = require_dist8();
    var import_styled_system8 = require_dist4();
    var import_theme_tools5 = require_dist9();
    var { definePartsStyle: definePartsStyle6, defineMultiStyleConfig: defineMultiStyleConfig6 } = (0, import_styled_system8.createMultiStyleConfigHelpers)(import_anatomy6.checkboxAnatomy.keys);
    var $size = (0, import_styled_system8.cssVar)("checkbox-size");
    var baseStyleControl = (0, import_styled_system8.defineStyle)((props) => {
      const { colorScheme: c } = props;
      return {
        w: $size.reference,
        h: $size.reference,
        transitionProperty: "box-shadow",
        transitionDuration: "normal",
        border: "2px solid",
        borderRadius: "sm",
        borderColor: "inherit",
        color: "white",
        _checked: {
          bg: (0, import_theme_tools5.mode)(`${c}.500`, `${c}.200`)(props),
          borderColor: (0, import_theme_tools5.mode)(`${c}.500`, `${c}.200`)(props),
          color: (0, import_theme_tools5.mode)("white", "gray.900")(props),
          _hover: {
            bg: (0, import_theme_tools5.mode)(`${c}.600`, `${c}.300`)(props),
            borderColor: (0, import_theme_tools5.mode)(`${c}.600`, `${c}.300`)(props)
          },
          _disabled: {
            borderColor: (0, import_theme_tools5.mode)("gray.200", "transparent")(props),
            bg: (0, import_theme_tools5.mode)("gray.200", "whiteAlpha.300")(props),
            color: (0, import_theme_tools5.mode)("gray.500", "whiteAlpha.500")(props)
          }
        },
        _indeterminate: {
          bg: (0, import_theme_tools5.mode)(`${c}.500`, `${c}.200`)(props),
          borderColor: (0, import_theme_tools5.mode)(`${c}.500`, `${c}.200`)(props),
          color: (0, import_theme_tools5.mode)("white", "gray.900")(props)
        },
        _disabled: {
          bg: (0, import_theme_tools5.mode)("gray.100", "whiteAlpha.100")(props),
          borderColor: (0, import_theme_tools5.mode)("gray.100", "transparent")(props)
        },
        _focusVisible: {
          boxShadow: "outline"
        },
        _invalid: {
          borderColor: (0, import_theme_tools5.mode)("red.500", "red.300")(props)
        }
      };
    });
    var baseStyleContainer3 = (0, import_styled_system8.defineStyle)({
      _disabled: { cursor: "not-allowed" }
    });
    var baseStyleLabel = (0, import_styled_system8.defineStyle)({
      userSelect: "none",
      _disabled: { opacity: 0.4 }
    });
    var baseStyleIcon2 = (0, import_styled_system8.defineStyle)({
      transitionProperty: "transform",
      transitionDuration: "normal"
    });
    var baseStyle8 = definePartsStyle6((props) => ({
      icon: baseStyleIcon2,
      container: baseStyleContainer3,
      control: runIfFn(baseStyleControl, props),
      label: baseStyleLabel
    }));
    var sizes5 = {
      sm: definePartsStyle6({
        control: { [$size.variable]: "sizes.3" },
        label: { fontSize: "sm" },
        icon: { fontSize: "3xs" }
      }),
      md: definePartsStyle6({
        control: { [$size.variable]: "sizes.4" },
        label: { fontSize: "md" },
        icon: { fontSize: "2xs" }
      }),
      lg: definePartsStyle6({
        control: { [$size.variable]: "sizes.5" },
        label: { fontSize: "lg" },
        icon: { fontSize: "2xs" }
      })
    };
    var checkboxTheme = defineMultiStyleConfig6({
      baseStyle: baseStyle8,
      sizes: sizes5,
      defaultProps: {
        size: "md",
        colorScheme: "blue"
      }
    });
    var import_styled_system9 = require_dist4();
    var import_theme_tools6 = require_dist9();
    var $size2 = (0, import_theme_tools6.cssVar)("close-button-size");
    var $bg4 = (0, import_theme_tools6.cssVar)("close-button-bg");
    var baseStyle9 = (0, import_styled_system9.defineStyle)({
      w: [$size2.reference],
      h: [$size2.reference],
      borderRadius: "md",
      transitionProperty: "common",
      transitionDuration: "normal",
      _disabled: {
        opacity: 0.4,
        cursor: "not-allowed",
        boxShadow: "none"
      },
      _hover: {
        [$bg4.variable]: "colors.blackAlpha.100",
        _dark: {
          [$bg4.variable]: "colors.whiteAlpha.100"
        }
      },
      _active: {
        [$bg4.variable]: "colors.blackAlpha.200",
        _dark: {
          [$bg4.variable]: "colors.whiteAlpha.200"
        }
      },
      _focusVisible: {
        boxShadow: "outline"
      },
      bg: $bg4.reference
    });
    var sizes6 = {
      lg: (0, import_styled_system9.defineStyle)({
        [$size2.variable]: "sizes.10",
        fontSize: "md"
      }),
      md: (0, import_styled_system9.defineStyle)({
        [$size2.variable]: "sizes.8",
        fontSize: "xs"
      }),
      sm: (0, import_styled_system9.defineStyle)({
        [$size2.variable]: "sizes.6",
        fontSize: "2xs"
      })
    };
    var closeButtonTheme = (0, import_styled_system9.defineStyleConfig)({
      baseStyle: baseStyle9,
      sizes: sizes6,
      defaultProps: {
        size: "md"
      }
    });
    var import_styled_system10 = require_dist4();
    var { variants: variants5, defaultProps } = badgeTheme;
    var baseStyle10 = (0, import_styled_system10.defineStyle)({
      fontFamily: "mono",
      fontSize: "sm",
      px: "0.2em",
      borderRadius: "sm",
      bg: vars.bg.reference,
      color: vars.color.reference,
      boxShadow: vars.shadow.reference
    });
    var codeTheme = (0, import_styled_system10.defineStyleConfig)({
      baseStyle: baseStyle10,
      variants: variants5,
      defaultProps
    });
    var import_styled_system11 = require_dist4();
    var baseStyle11 = (0, import_styled_system11.defineStyle)({
      w: "100%",
      mx: "auto",
      maxW: "prose",
      px: "4"
    });
    var containerTheme = (0, import_styled_system11.defineStyleConfig)({
      baseStyle: baseStyle11
    });
    var import_styled_system12 = require_dist4();
    var baseStyle12 = (0, import_styled_system12.defineStyle)({
      opacity: 0.6,
      borderColor: "inherit"
    });
    var variantSolid4 = (0, import_styled_system12.defineStyle)({
      borderStyle: "solid"
    });
    var variantDashed = (0, import_styled_system12.defineStyle)({
      borderStyle: "dashed"
    });
    var variants6 = {
      solid: variantSolid4,
      dashed: variantDashed
    };
    var dividerTheme = (0, import_styled_system12.defineStyleConfig)({
      baseStyle: baseStyle12,
      variants: variants6,
      defaultProps: {
        variant: "solid"
      }
    });
    var import_anatomy7 = require_dist8();
    var import_styled_system13 = require_dist4();
    var { definePartsStyle: definePartsStyle7, defineMultiStyleConfig: defineMultiStyleConfig7 } = (0, import_styled_system13.createMultiStyleConfigHelpers)(import_anatomy7.drawerAnatomy.keys);
    var $bg5 = (0, import_styled_system13.cssVar)("drawer-bg");
    var $bs = (0, import_styled_system13.cssVar)("drawer-box-shadow");
    function getSize2(value) {
      if (value === "full") {
        return definePartsStyle7({
          dialog: { maxW: "100vw", h: "100vh" }
        });
      }
      return definePartsStyle7({
        dialog: { maxW: value }
      });
    }
    var baseStyleOverlay = (0, import_styled_system13.defineStyle)({
      bg: "blackAlpha.600",
      zIndex: "overlay"
    });
    var baseStyleDialogContainer = (0, import_styled_system13.defineStyle)({
      display: "flex",
      zIndex: "modal",
      justifyContent: "center"
    });
    var baseStyleDialog = (0, import_styled_system13.defineStyle)((props) => {
      const { isFullHeight } = props;
      return {
        ...isFullHeight && { height: "100vh" },
        zIndex: "modal",
        maxH: "100vh",
        color: "inherit",
        [$bg5.variable]: "colors.white",
        [$bs.variable]: "shadows.lg",
        _dark: {
          [$bg5.variable]: "colors.gray.700",
          [$bs.variable]: "shadows.dark-lg"
        },
        bg: $bg5.reference,
        boxShadow: $bs.reference
      };
    });
    var baseStyleHeader = (0, import_styled_system13.defineStyle)({
      px: "6",
      py: "4",
      fontSize: "xl",
      fontWeight: "semibold"
    });
    var baseStyleCloseButton = (0, import_styled_system13.defineStyle)({
      position: "absolute",
      top: "2",
      insetEnd: "3"
    });
    var baseStyleBody = (0, import_styled_system13.defineStyle)({
      px: "6",
      py: "2",
      flex: "1",
      overflow: "auto"
    });
    var baseStyleFooter = (0, import_styled_system13.defineStyle)({
      px: "6",
      py: "4"
    });
    var baseStyle13 = definePartsStyle7((props) => ({
      overlay: baseStyleOverlay,
      dialogContainer: baseStyleDialogContainer,
      dialog: runIfFn(baseStyleDialog, props),
      header: baseStyleHeader,
      closeButton: baseStyleCloseButton,
      body: baseStyleBody,
      footer: baseStyleFooter
    }));
    var sizes7 = {
      xs: getSize2("xs"),
      sm: getSize2("md"),
      md: getSize2("lg"),
      lg: getSize2("2xl"),
      xl: getSize2("4xl"),
      full: getSize2("full")
    };
    var drawerTheme = defineMultiStyleConfig7({
      baseStyle: baseStyle13,
      sizes: sizes7,
      defaultProps: {
        size: "xs"
      }
    });
    var import_anatomy8 = require_dist8();
    var import_styled_system14 = require_dist4();
    var { definePartsStyle: definePartsStyle8, defineMultiStyleConfig: defineMultiStyleConfig8 } = (0, import_styled_system14.createMultiStyleConfigHelpers)(import_anatomy8.editableAnatomy.keys);
    var baseStylePreview = (0, import_styled_system14.defineStyle)({
      borderRadius: "md",
      py: "1",
      transitionProperty: "common",
      transitionDuration: "normal"
    });
    var baseStyleInput = (0, import_styled_system14.defineStyle)({
      borderRadius: "md",
      py: "1",
      transitionProperty: "common",
      transitionDuration: "normal",
      width: "full",
      _focusVisible: { boxShadow: "outline" },
      _placeholder: { opacity: 0.6 }
    });
    var baseStyleTextarea = (0, import_styled_system14.defineStyle)({
      borderRadius: "md",
      py: "1",
      transitionProperty: "common",
      transitionDuration: "normal",
      width: "full",
      _focusVisible: { boxShadow: "outline" },
      _placeholder: { opacity: 0.6 }
    });
    var baseStyle14 = definePartsStyle8({
      preview: baseStylePreview,
      input: baseStyleInput,
      textarea: baseStyleTextarea
    });
    var editableTheme = defineMultiStyleConfig8({
      baseStyle: baseStyle14
    });
    var import_anatomy9 = require_dist8();
    var import_styled_system15 = require_dist4();
    var { definePartsStyle: definePartsStyle9, defineMultiStyleConfig: defineMultiStyleConfig9 } = (0, import_styled_system15.createMultiStyleConfigHelpers)(import_anatomy9.formAnatomy.keys);
    var $fg2 = (0, import_styled_system15.cssVar)("form-control-color");
    var baseStyleRequiredIndicator = (0, import_styled_system15.defineStyle)({
      marginStart: "1",
      [$fg2.variable]: "colors.red.500",
      _dark: {
        [$fg2.variable]: "colors.red.300"
      },
      color: $fg2.reference
    });
    var baseStyleHelperText = (0, import_styled_system15.defineStyle)({
      mt: "2",
      [$fg2.variable]: "colors.gray.600",
      _dark: {
        [$fg2.variable]: "colors.whiteAlpha.600"
      },
      color: $fg2.reference,
      lineHeight: "normal",
      fontSize: "sm"
    });
    var baseStyle15 = definePartsStyle9({
      container: {
        width: "100%",
        position: "relative"
      },
      requiredIndicator: baseStyleRequiredIndicator,
      helperText: baseStyleHelperText
    });
    var formTheme = defineMultiStyleConfig9({
      baseStyle: baseStyle15
    });
    var import_anatomy10 = require_dist8();
    var import_styled_system16 = require_dist4();
    var { definePartsStyle: definePartsStyle10, defineMultiStyleConfig: defineMultiStyleConfig10 } = (0, import_styled_system16.createMultiStyleConfigHelpers)(import_anatomy10.formErrorAnatomy.keys);
    var $fg3 = (0, import_styled_system16.cssVar)("form-error-color");
    var baseStyleText = (0, import_styled_system16.defineStyle)({
      [$fg3.variable]: `colors.red.500`,
      _dark: {
        [$fg3.variable]: `colors.red.300`
      },
      color: $fg3.reference,
      mt: "2",
      fontSize: "sm",
      lineHeight: "normal"
    });
    var baseStyleIcon3 = (0, import_styled_system16.defineStyle)({
      marginEnd: "0.5em",
      [$fg3.variable]: `colors.red.500`,
      _dark: {
        [$fg3.variable]: `colors.red.300`
      },
      color: $fg3.reference
    });
    var baseStyle16 = definePartsStyle10({
      text: baseStyleText,
      icon: baseStyleIcon3
    });
    var formErrorTheme = defineMultiStyleConfig10({
      baseStyle: baseStyle16
    });
    var import_styled_system17 = require_dist4();
    var baseStyle17 = (0, import_styled_system17.defineStyle)({
      fontSize: "md",
      marginEnd: "3",
      mb: "2",
      fontWeight: "medium",
      transitionProperty: "common",
      transitionDuration: "normal",
      opacity: 1,
      _disabled: {
        opacity: 0.4
      }
    });
    var formLabelTheme = (0, import_styled_system17.defineStyleConfig)({
      baseStyle: baseStyle17
    });
    var import_styled_system18 = require_dist4();
    var baseStyle18 = (0, import_styled_system18.defineStyle)({
      fontFamily: "heading",
      fontWeight: "bold"
    });
    var sizes8 = {
      "4xl": (0, import_styled_system18.defineStyle)({
        fontSize: ["6xl", null, "7xl"],
        lineHeight: 1
      }),
      "3xl": (0, import_styled_system18.defineStyle)({
        fontSize: ["5xl", null, "6xl"],
        lineHeight: 1
      }),
      "2xl": (0, import_styled_system18.defineStyle)({
        fontSize: ["4xl", null, "5xl"],
        lineHeight: [1.2, null, 1]
      }),
      xl: (0, import_styled_system18.defineStyle)({
        fontSize: ["3xl", null, "4xl"],
        lineHeight: [1.33, null, 1.2]
      }),
      lg: (0, import_styled_system18.defineStyle)({
        fontSize: ["2xl", null, "3xl"],
        lineHeight: [1.33, null, 1.2]
      }),
      md: (0, import_styled_system18.defineStyle)({
        fontSize: "xl",
        lineHeight: 1.2
      }),
      sm: (0, import_styled_system18.defineStyle)({
        fontSize: "md",
        lineHeight: 1.2
      }),
      xs: (0, import_styled_system18.defineStyle)({
        fontSize: "sm",
        lineHeight: 1.2
      })
    };
    var headingTheme = (0, import_styled_system18.defineStyleConfig)({
      baseStyle: baseStyle18,
      sizes: sizes8,
      defaultProps: {
        size: "xl"
      }
    });
    var import_anatomy11 = require_dist8();
    var import_styled_system19 = require_dist4();
    var import_theme_tools7 = require_dist9();
    var { definePartsStyle: definePartsStyle11, defineMultiStyleConfig: defineMultiStyleConfig11 } = (0, import_styled_system19.createMultiStyleConfigHelpers)(import_anatomy11.inputAnatomy.keys);
    var baseStyle19 = definePartsStyle11({
      field: {
        width: "100%",
        minWidth: 0,
        outline: 0,
        position: "relative",
        appearance: "none",
        transitionProperty: "common",
        transitionDuration: "normal",
        _disabled: {
          opacity: 0.4,
          cursor: "not-allowed"
        }
      }
    });
    var size = {
      lg: (0, import_styled_system19.defineStyle)({
        fontSize: "lg",
        px: "4",
        h: "12",
        borderRadius: "md"
      }),
      md: (0, import_styled_system19.defineStyle)({
        fontSize: "md",
        px: "4",
        h: "10",
        borderRadius: "md"
      }),
      sm: (0, import_styled_system19.defineStyle)({
        fontSize: "sm",
        px: "3",
        h: "8",
        borderRadius: "sm"
      }),
      xs: (0, import_styled_system19.defineStyle)({
        fontSize: "xs",
        px: "2",
        h: "6",
        borderRadius: "sm"
      })
    };
    var sizes9 = {
      lg: definePartsStyle11({
        field: size.lg,
        addon: size.lg
      }),
      md: definePartsStyle11({
        field: size.md,
        addon: size.md
      }),
      sm: definePartsStyle11({
        field: size.sm,
        addon: size.sm
      }),
      xs: definePartsStyle11({
        field: size.xs,
        addon: size.xs
      })
    };
    function getDefaults(props) {
      const { focusBorderColor: fc, errorBorderColor: ec } = props;
      return {
        focusBorderColor: fc || (0, import_theme_tools7.mode)("blue.500", "blue.300")(props),
        errorBorderColor: ec || (0, import_theme_tools7.mode)("red.500", "red.300")(props)
      };
    }
    var variantOutline3 = definePartsStyle11((props) => {
      const { theme: theme2 } = props;
      const { focusBorderColor: fc, errorBorderColor: ec } = getDefaults(props);
      return {
        field: {
          border: "1px solid",
          borderColor: "inherit",
          bg: "inherit",
          _hover: {
            borderColor: (0, import_theme_tools7.mode)("gray.300", "whiteAlpha.400")(props)
          },
          _readOnly: {
            boxShadow: "none !important",
            userSelect: "all"
          },
          _invalid: {
            borderColor: (0, import_theme_tools7.getColor)(theme2, ec),
            boxShadow: `0 0 0 1px ${(0, import_theme_tools7.getColor)(theme2, ec)}`
          },
          _focusVisible: {
            zIndex: 1,
            borderColor: (0, import_theme_tools7.getColor)(theme2, fc),
            boxShadow: `0 0 0 1px ${(0, import_theme_tools7.getColor)(theme2, fc)}`
          }
        },
        addon: {
          border: "1px solid",
          borderColor: (0, import_theme_tools7.mode)("inherit", "whiteAlpha.50")(props),
          bg: (0, import_theme_tools7.mode)("gray.100", "whiteAlpha.300")(props)
        }
      };
    });
    var variantFilled = definePartsStyle11((props) => {
      const { theme: theme2 } = props;
      const { focusBorderColor: fc, errorBorderColor: ec } = getDefaults(props);
      return {
        field: {
          border: "2px solid",
          borderColor: "transparent",
          bg: (0, import_theme_tools7.mode)("gray.100", "whiteAlpha.50")(props),
          _hover: {
            bg: (0, import_theme_tools7.mode)("gray.200", "whiteAlpha.100")(props)
          },
          _readOnly: {
            boxShadow: "none !important",
            userSelect: "all"
          },
          _invalid: {
            borderColor: (0, import_theme_tools7.getColor)(theme2, ec)
          },
          _focusVisible: {
            bg: "transparent",
            borderColor: (0, import_theme_tools7.getColor)(theme2, fc)
          }
        },
        addon: {
          border: "2px solid",
          borderColor: "transparent",
          bg: (0, import_theme_tools7.mode)("gray.100", "whiteAlpha.50")(props)
        }
      };
    });
    var variantFlushed = definePartsStyle11((props) => {
      const { theme: theme2 } = props;
      const { focusBorderColor: fc, errorBorderColor: ec } = getDefaults(props);
      return {
        field: {
          borderBottom: "1px solid",
          borderColor: "inherit",
          borderRadius: "0",
          px: "0",
          bg: "transparent",
          _readOnly: {
            boxShadow: "none !important",
            userSelect: "all"
          },
          _invalid: {
            borderColor: (0, import_theme_tools7.getColor)(theme2, ec),
            boxShadow: `0px 1px 0px 0px ${(0, import_theme_tools7.getColor)(theme2, ec)}`
          },
          _focusVisible: {
            borderColor: (0, import_theme_tools7.getColor)(theme2, fc),
            boxShadow: `0px 1px 0px 0px ${(0, import_theme_tools7.getColor)(theme2, fc)}`
          }
        },
        addon: {
          borderBottom: "2px solid",
          borderColor: "inherit",
          borderRadius: "0",
          px: "0",
          bg: "transparent"
        }
      };
    });
    var variantUnstyled2 = definePartsStyle11({
      field: {
        bg: "transparent",
        px: "0",
        height: "auto"
      },
      addon: {
        bg: "transparent",
        px: "0",
        height: "auto"
      }
    });
    var variants7 = {
      outline: variantOutline3,
      filled: variantFilled,
      flushed: variantFlushed,
      unstyled: variantUnstyled2
    };
    var inputTheme = defineMultiStyleConfig11({
      baseStyle: baseStyle19,
      sizes: sizes9,
      variants: variants7,
      defaultProps: {
        size: "md",
        variant: "outline"
      }
    });
    var import_styled_system20 = require_dist4();
    var $bg6 = (0, import_styled_system20.cssVar)("kbd-bg");
    var baseStyle20 = (0, import_styled_system20.defineStyle)({
      [$bg6.variable]: "colors.gray.100",
      _dark: {
        [$bg6.variable]: "colors.whiteAlpha.100"
      },
      bg: $bg6.reference,
      borderRadius: "md",
      borderWidth: "1px",
      borderBottomWidth: "3px",
      fontSize: "0.8em",
      fontWeight: "bold",
      lineHeight: "normal",
      px: "0.4em",
      whiteSpace: "nowrap"
    });
    var kbdTheme = (0, import_styled_system20.defineStyleConfig)({
      baseStyle: baseStyle20
    });
    var import_styled_system21 = require_dist4();
    var baseStyle21 = (0, import_styled_system21.defineStyle)({
      transitionProperty: "common",
      transitionDuration: "fast",
      transitionTimingFunction: "ease-out",
      cursor: "pointer",
      textDecoration: "none",
      outline: "none",
      color: "inherit",
      _hover: {
        textDecoration: "underline"
      },
      _focusVisible: {
        boxShadow: "outline"
      }
    });
    var linkTheme = (0, import_styled_system21.defineStyleConfig)({
      baseStyle: baseStyle21
    });
    var import_anatomy12 = require_dist8();
    var import_styled_system22 = require_dist4();
    var { defineMultiStyleConfig: defineMultiStyleConfig12, definePartsStyle: definePartsStyle12 } = (0, import_styled_system22.createMultiStyleConfigHelpers)(import_anatomy12.listAnatomy.keys);
    var baseStyleIcon4 = (0, import_styled_system22.defineStyle)({
      marginEnd: "2",
      display: "inline",
      verticalAlign: "text-bottom"
    });
    var baseStyle22 = definePartsStyle12({
      icon: baseStyleIcon4
    });
    var listTheme = defineMultiStyleConfig12({
      baseStyle: baseStyle22
    });
    var import_anatomy13 = require_dist8();
    var import_styled_system23 = require_dist4();
    var { defineMultiStyleConfig: defineMultiStyleConfig13, definePartsStyle: definePartsStyle13 } = (0, import_styled_system23.createMultiStyleConfigHelpers)(import_anatomy13.menuAnatomy.keys);
    var $bg7 = (0, import_styled_system23.cssVar)("menu-bg");
    var $shadow2 = (0, import_styled_system23.cssVar)("menu-shadow");
    var baseStyleList = (0, import_styled_system23.defineStyle)({
      [$bg7.variable]: "#fff",
      [$shadow2.variable]: "shadows.sm",
      _dark: {
        [$bg7.variable]: "colors.gray.700",
        [$shadow2.variable]: "shadows.dark-lg"
      },
      color: "inherit",
      minW: "3xs",
      py: "2",
      zIndex: 1,
      borderRadius: "md",
      borderWidth: "1px",
      bg: $bg7.reference,
      boxShadow: $shadow2.reference
    });
    var baseStyleItem = (0, import_styled_system23.defineStyle)({
      py: "1.5",
      px: "3",
      transitionProperty: "background",
      transitionDuration: "ultra-fast",
      transitionTimingFunction: "ease-in",
      _focus: {
        [$bg7.variable]: "colors.gray.100",
        _dark: {
          [$bg7.variable]: "colors.whiteAlpha.100"
        }
      },
      _active: {
        [$bg7.variable]: "colors.gray.200",
        _dark: {
          [$bg7.variable]: "colors.whiteAlpha.200"
        }
      },
      _expanded: {
        [$bg7.variable]: "colors.gray.100",
        _dark: {
          [$bg7.variable]: "colors.whiteAlpha.100"
        }
      },
      _disabled: {
        opacity: 0.4,
        cursor: "not-allowed"
      },
      bg: $bg7.reference
    });
    var baseStyleGroupTitle = (0, import_styled_system23.defineStyle)({
      mx: 4,
      my: 2,
      fontWeight: "semibold",
      fontSize: "sm"
    });
    var baseStyleCommand = (0, import_styled_system23.defineStyle)({
      opacity: 0.6
    });
    var baseStyleDivider = (0, import_styled_system23.defineStyle)({
      border: 0,
      borderBottom: "1px solid",
      borderColor: "inherit",
      my: "2",
      opacity: 0.6
    });
    var baseStyleButton2 = (0, import_styled_system23.defineStyle)({
      transitionProperty: "common",
      transitionDuration: "normal"
    });
    var baseStyle23 = definePartsStyle13({
      button: baseStyleButton2,
      list: baseStyleList,
      item: baseStyleItem,
      groupTitle: baseStyleGroupTitle,
      command: baseStyleCommand,
      divider: baseStyleDivider
    });
    var menuTheme = defineMultiStyleConfig13({
      baseStyle: baseStyle23
    });
    var import_anatomy14 = require_dist8();
    var import_styled_system24 = require_dist4();
    var { defineMultiStyleConfig: defineMultiStyleConfig14, definePartsStyle: definePartsStyle14 } = (0, import_styled_system24.createMultiStyleConfigHelpers)(import_anatomy14.modalAnatomy.keys);
    var $bg8 = (0, import_styled_system24.cssVar)("modal-bg");
    var $shadow3 = (0, import_styled_system24.cssVar)("modal-shadow");
    var baseStyleOverlay2 = (0, import_styled_system24.defineStyle)({
      bg: "blackAlpha.600",
      zIndex: "modal"
    });
    var baseStyleDialogContainer2 = (0, import_styled_system24.defineStyle)((props) => {
      const { isCentered, scrollBehavior } = props;
      return {
        display: "flex",
        zIndex: "modal",
        justifyContent: "center",
        alignItems: isCentered ? "center" : "flex-start",
        overflow: scrollBehavior === "inside" ? "hidden" : "auto",
        overscrollBehaviorY: "none"
      };
    });
    var baseStyleDialog2 = (0, import_styled_system24.defineStyle)((props) => {
      const { isCentered, scrollBehavior } = props;
      return {
        borderRadius: "md",
        color: "inherit",
        my: isCentered ? "auto" : "16",
        mx: isCentered ? "auto" : void 0,
        zIndex: "modal",
        maxH: scrollBehavior === "inside" ? "calc(100% - 7.5rem)" : void 0,
        [$bg8.variable]: "colors.white",
        [$shadow3.variable]: "shadows.lg",
        _dark: {
          [$bg8.variable]: "colors.gray.700",
          [$shadow3.variable]: "shadows.dark-lg"
        },
        bg: $bg8.reference,
        boxShadow: $shadow3.reference
      };
    });
    var baseStyleHeader2 = (0, import_styled_system24.defineStyle)({
      px: "6",
      py: "4",
      fontSize: "xl",
      fontWeight: "semibold"
    });
    var baseStyleCloseButton2 = (0, import_styled_system24.defineStyle)({
      position: "absolute",
      top: "2",
      insetEnd: "3"
    });
    var baseStyleBody2 = (0, import_styled_system24.defineStyle)((props) => {
      const { scrollBehavior } = props;
      return {
        px: "6",
        py: "2",
        flex: "1",
        overflow: scrollBehavior === "inside" ? "auto" : void 0
      };
    });
    var baseStyleFooter2 = (0, import_styled_system24.defineStyle)({
      px: "6",
      py: "4"
    });
    var baseStyle24 = definePartsStyle14((props) => ({
      overlay: baseStyleOverlay2,
      dialogContainer: runIfFn(baseStyleDialogContainer2, props),
      dialog: runIfFn(baseStyleDialog2, props),
      header: baseStyleHeader2,
      closeButton: baseStyleCloseButton2,
      body: runIfFn(baseStyleBody2, props),
      footer: baseStyleFooter2
    }));
    function getSize3(value) {
      if (value === "full") {
        return definePartsStyle14({
          dialog: {
            maxW: "100vw",
            minH: "$100vh",
            my: "0",
            borderRadius: "0"
          }
        });
      }
      return definePartsStyle14({
        dialog: { maxW: value }
      });
    }
    var sizes10 = {
      xs: getSize3("xs"),
      sm: getSize3("sm"),
      md: getSize3("md"),
      lg: getSize3("lg"),
      xl: getSize3("xl"),
      "2xl": getSize3("2xl"),
      "3xl": getSize3("3xl"),
      "4xl": getSize3("4xl"),
      "5xl": getSize3("5xl"),
      "6xl": getSize3("6xl"),
      full: getSize3("full")
    };
    var modalTheme = defineMultiStyleConfig14({
      baseStyle: baseStyle24,
      sizes: sizes10,
      defaultProps: { size: "md" }
    });
    var import_anatomy15 = require_dist8();
    var import_styled_system25 = require_dist4();
    var import_theme_tools8 = require_dist9();
    var typography = {
      letterSpacings: {
        tighter: "-0.05em",
        tight: "-0.025em",
        normal: "0",
        wide: "0.025em",
        wider: "0.05em",
        widest: "0.1em"
      },
      lineHeights: {
        normal: "normal",
        none: 1,
        shorter: 1.25,
        short: 1.375,
        base: 1.5,
        tall: 1.625,
        taller: "2",
        "3": ".75rem",
        "4": "1rem",
        "5": "1.25rem",
        "6": "1.5rem",
        "7": "1.75rem",
        "8": "2rem",
        "9": "2.25rem",
        "10": "2.5rem"
      },
      fontWeights: {
        hairline: 100,
        thin: 200,
        light: 300,
        normal: 400,
        medium: 500,
        semibold: 600,
        bold: 700,
        extrabold: 800,
        black: 900
      },
      fonts: {
        heading: `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`,
        body: `-apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`,
        mono: `SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace`
      },
      fontSizes: {
        "3xs": "0.45rem",
        "2xs": "0.625rem",
        xs: "0.75rem",
        sm: "0.875rem",
        md: "1rem",
        lg: "1.125rem",
        xl: "1.25rem",
        "2xl": "1.5rem",
        "3xl": "1.875rem",
        "4xl": "2.25rem",
        "5xl": "3rem",
        "6xl": "3.75rem",
        "7xl": "4.5rem",
        "8xl": "6rem",
        "9xl": "8rem"
      }
    };
    var typography_default = typography;
    var { defineMultiStyleConfig: defineMultiStyleConfig15, definePartsStyle: definePartsStyle15 } = (0, import_styled_system25.createMultiStyleConfigHelpers)(import_anatomy15.numberInputAnatomy.keys);
    var $stepperWidth = (0, import_theme_tools8.cssVar)("number-input-stepper-width");
    var $inputPadding = (0, import_theme_tools8.cssVar)("number-input-input-padding");
    var inputPaddingValue = (0, import_theme_tools8.calc)($stepperWidth).add("0.5rem").toString();
    var $bg9 = (0, import_theme_tools8.cssVar)("number-input-bg");
    var $fg4 = (0, import_theme_tools8.cssVar)("number-input-color");
    var $border3 = (0, import_theme_tools8.cssVar)("number-input-border-color");
    var baseStyleRoot = (0, import_styled_system25.defineStyle)({
      [$stepperWidth.variable]: "sizes.6",
      [$inputPadding.variable]: inputPaddingValue
    });
    var baseStyleField = (0, import_styled_system25.defineStyle)(
      (props) => {
        var _a8, _b5;
        return (_b5 = (_a8 = runIfFn(inputTheme.baseStyle, props)) == null ? void 0 : _a8.field) != null ? _b5 : {};
      }
    );
    var baseStyleStepperGroup = (0, import_styled_system25.defineStyle)({
      width: $stepperWidth.reference
    });
    var baseStyleStepper = (0, import_styled_system25.defineStyle)({
      borderStart: "1px solid",
      borderStartColor: $border3.reference,
      color: $fg4.reference,
      bg: $bg9.reference,
      [$fg4.variable]: "colors.chakra-body-text",
      [$border3.variable]: "colors.chakra-border-color",
      _dark: {
        [$fg4.variable]: "colors.whiteAlpha.800",
        [$border3.variable]: "colors.whiteAlpha.300"
      },
      _active: {
        [$bg9.variable]: "colors.gray.200",
        _dark: {
          [$bg9.variable]: "colors.whiteAlpha.300"
        }
      },
      _disabled: {
        opacity: 0.4,
        cursor: "not-allowed"
      }
    });
    var baseStyle25 = definePartsStyle15((props) => {
      var _a8;
      return {
        root: baseStyleRoot,
        field: (_a8 = runIfFn(baseStyleField, props)) != null ? _a8 : {},
        stepperGroup: baseStyleStepperGroup,
        stepper: baseStyleStepper
      };
    });
    function getSize4(size2) {
      var _a8, _b5, _c3;
      const sizeStyle = (_a8 = inputTheme.sizes) == null ? void 0 : _a8[size2];
      const radius = {
        lg: "md",
        md: "md",
        sm: "sm",
        xs: "sm"
      };
      const _fontSize = (_c3 = (_b5 = sizeStyle.field) == null ? void 0 : _b5.fontSize) != null ? _c3 : "md";
      const fontSize = typography_default.fontSizes[_fontSize];
      return definePartsStyle15({
        field: {
          ...sizeStyle.field,
          paddingInlineEnd: $inputPadding.reference,
          verticalAlign: "top"
        },
        stepper: {
          fontSize: (0, import_theme_tools8.calc)(fontSize).multiply(0.75).toString(),
          _first: {
            borderTopEndRadius: radius[size2]
          },
          _last: {
            borderBottomEndRadius: radius[size2],
            mt: "-1px",
            borderTopWidth: 1
          }
        }
      });
    }
    var sizes11 = {
      xs: getSize4("xs"),
      sm: getSize4("sm"),
      md: getSize4("md"),
      lg: getSize4("lg")
    };
    var numberInputTheme = defineMultiStyleConfig15({
      baseStyle: baseStyle25,
      sizes: sizes11,
      variants: inputTheme.variants,
      defaultProps: inputTheme.defaultProps
    });
    var import_styled_system26 = require_dist4();
    var _a;
    var baseStyle26 = (0, import_styled_system26.defineStyle)({
      ...(_a = inputTheme.baseStyle) == null ? void 0 : _a.field,
      textAlign: "center"
    });
    var sizes12 = {
      lg: (0, import_styled_system26.defineStyle)({
        fontSize: "lg",
        w: 12,
        h: 12,
        borderRadius: "md"
      }),
      md: (0, import_styled_system26.defineStyle)({
        fontSize: "md",
        w: 10,
        h: 10,
        borderRadius: "md"
      }),
      sm: (0, import_styled_system26.defineStyle)({
        fontSize: "sm",
        w: 8,
        h: 8,
        borderRadius: "sm"
      }),
      xs: (0, import_styled_system26.defineStyle)({
        fontSize: "xs",
        w: 6,
        h: 6,
        borderRadius: "sm"
      })
    };
    var _a2;
    var _b;
    var variants8 = {
      outline: (0, import_styled_system26.defineStyle)(
        (props) => {
          var _a8, _b5, _c3;
          return (_c3 = (_b5 = runIfFn((_a8 = inputTheme.variants) == null ? void 0 : _a8.outline, props)) == null ? void 0 : _b5.field) != null ? _c3 : {};
        }
      ),
      flushed: (0, import_styled_system26.defineStyle)(
        (props) => {
          var _a8, _b5, _c3;
          return (_c3 = (_b5 = runIfFn((_a8 = inputTheme.variants) == null ? void 0 : _a8.flushed, props)) == null ? void 0 : _b5.field) != null ? _c3 : {};
        }
      ),
      filled: (0, import_styled_system26.defineStyle)(
        (props) => {
          var _a8, _b5, _c3;
          return (_c3 = (_b5 = runIfFn((_a8 = inputTheme.variants) == null ? void 0 : _a8.filled, props)) == null ? void 0 : _b5.field) != null ? _c3 : {};
        }
      ),
      unstyled: (_b = (_a2 = inputTheme.variants) == null ? void 0 : _a2.unstyled.field) != null ? _b : {}
    };
    var pinInputTheme = (0, import_styled_system26.defineStyleConfig)({
      baseStyle: baseStyle26,
      sizes: sizes12,
      variants: variants8,
      defaultProps: inputTheme.defaultProps
    });
    var import_anatomy16 = require_dist8();
    var import_styled_system27 = require_dist4();
    var import_theme_tools9 = require_dist9();
    var { defineMultiStyleConfig: defineMultiStyleConfig16, definePartsStyle: definePartsStyle16 } = (0, import_styled_system27.createMultiStyleConfigHelpers)(import_anatomy16.popoverAnatomy.keys);
    var $popperBg = (0, import_theme_tools9.cssVar)("popper-bg");
    var $arrowBg = (0, import_theme_tools9.cssVar)("popper-arrow-bg");
    var $arrowShadowColor = (0, import_theme_tools9.cssVar)("popper-arrow-shadow-color");
    var baseStylePopper = (0, import_styled_system27.defineStyle)({ zIndex: 10 });
    var baseStyleContent = (0, import_styled_system27.defineStyle)({
      [$popperBg.variable]: `colors.white`,
      bg: $popperBg.reference,
      [$arrowBg.variable]: $popperBg.reference,
      [$arrowShadowColor.variable]: `colors.gray.200`,
      _dark: {
        [$popperBg.variable]: `colors.gray.700`,
        [$arrowShadowColor.variable]: `colors.whiteAlpha.300`
      },
      width: "xs",
      border: "1px solid",
      borderColor: "inherit",
      borderRadius: "md",
      boxShadow: "sm",
      zIndex: "inherit",
      _focusVisible: {
        outline: 0,
        boxShadow: "outline"
      }
    });
    var baseStyleHeader3 = (0, import_styled_system27.defineStyle)({
      px: 3,
      py: 2,
      borderBottomWidth: "1px"
    });
    var baseStyleBody3 = (0, import_styled_system27.defineStyle)({
      px: 3,
      py: 2
    });
    var baseStyleFooter3 = (0, import_styled_system27.defineStyle)({
      px: 3,
      py: 2,
      borderTopWidth: "1px"
    });
    var baseStyleCloseButton3 = (0, import_styled_system27.defineStyle)({
      position: "absolute",
      borderRadius: "md",
      top: 1,
      insetEnd: 2,
      padding: 2
    });
    var baseStyle27 = definePartsStyle16({
      popper: baseStylePopper,
      content: baseStyleContent,
      header: baseStyleHeader3,
      body: baseStyleBody3,
      footer: baseStyleFooter3,
      closeButton: baseStyleCloseButton3
    });
    var popoverTheme = defineMultiStyleConfig16({
      baseStyle: baseStyle27
    });
    var import_anatomy17 = require_dist8();
    var import_styled_system28 = require_dist4();
    var import_theme_tools10 = require_dist9();
    var { defineMultiStyleConfig: defineMultiStyleConfig17, definePartsStyle: definePartsStyle17 } = (0, import_styled_system28.createMultiStyleConfigHelpers)(import_anatomy17.progressAnatomy.keys);
    var filledStyle = (0, import_styled_system28.defineStyle)((props) => {
      const { colorScheme: c, theme: t, isIndeterminate, hasStripe } = props;
      const stripeStyle = (0, import_theme_tools10.mode)(
        (0, import_theme_tools10.generateStripe)(),
        (0, import_theme_tools10.generateStripe)("1rem", "rgba(0,0,0,0.1)")
      )(props);
      const bgColor = (0, import_theme_tools10.mode)(`${c}.500`, `${c}.200`)(props);
      const gradient = `linear-gradient(
    to right,
    transparent 0%,
    ${(0, import_theme_tools10.getColor)(t, bgColor)} 50%,
    transparent 100%
  )`;
      const addStripe = !isIndeterminate && hasStripe;
      return {
        ...addStripe && stripeStyle,
        ...isIndeterminate ? { bgImage: gradient } : { bgColor }
      };
    });
    var baseStyleLabel2 = (0, import_styled_system28.defineStyle)({
      lineHeight: "1",
      fontSize: "0.25em",
      fontWeight: "bold",
      color: "white"
    });
    var baseStyleTrack = (0, import_styled_system28.defineStyle)((props) => {
      return {
        bg: (0, import_theme_tools10.mode)("gray.100", "whiteAlpha.300")(props)
      };
    });
    var baseStyleFilledTrack = (0, import_styled_system28.defineStyle)((props) => {
      return {
        transitionProperty: "common",
        transitionDuration: "slow",
        ...filledStyle(props)
      };
    });
    var baseStyle28 = definePartsStyle17((props) => ({
      label: baseStyleLabel2,
      filledTrack: baseStyleFilledTrack(props),
      track: baseStyleTrack(props)
    }));
    var sizes13 = {
      xs: definePartsStyle17({
        track: { h: "1" }
      }),
      sm: definePartsStyle17({
        track: { h: "2" }
      }),
      md: definePartsStyle17({
        track: { h: "3" }
      }),
      lg: definePartsStyle17({
        track: { h: "4" }
      })
    };
    var progressTheme = defineMultiStyleConfig17({
      sizes: sizes13,
      baseStyle: baseStyle28,
      defaultProps: {
        size: "md",
        colorScheme: "blue"
      }
    });
    var import_anatomy18 = require_dist8();
    var import_styled_system29 = require_dist4();
    var { defineMultiStyleConfig: defineMultiStyleConfig18, definePartsStyle: definePartsStyle18 } = (0, import_styled_system29.createMultiStyleConfigHelpers)(import_anatomy18.radioAnatomy.keys);
    var baseStyleControl2 = (0, import_styled_system29.defineStyle)((props) => {
      var _a8;
      const controlStyle = (_a8 = runIfFn(checkboxTheme.baseStyle, props)) == null ? void 0 : _a8.control;
      return {
        ...controlStyle,
        borderRadius: "full",
        _checked: {
          ...controlStyle == null ? void 0 : controlStyle["_checked"],
          _before: {
            content: `""`,
            display: "inline-block",
            pos: "relative",
            w: "50%",
            h: "50%",
            borderRadius: "50%",
            bg: "currentColor"
          }
        }
      };
    });
    var baseStyle29 = definePartsStyle18((props) => {
      var _a8, _b5, _c3, _d3;
      return {
        label: (_b5 = (_a8 = checkboxTheme).baseStyle) == null ? void 0 : _b5.call(_a8, props).label,
        container: (_d3 = (_c3 = checkboxTheme).baseStyle) == null ? void 0 : _d3.call(_c3, props).container,
        control: baseStyleControl2(props)
      };
    });
    var sizes14 = {
      md: definePartsStyle18({
        control: { w: "4", h: "4" },
        label: { fontSize: "md" }
      }),
      lg: definePartsStyle18({
        control: { w: "5", h: "5" },
        label: { fontSize: "lg" }
      }),
      sm: definePartsStyle18({
        control: { width: "3", height: "3" },
        label: { fontSize: "sm" }
      })
    };
    var radioTheme = defineMultiStyleConfig18({
      baseStyle: baseStyle29,
      sizes: sizes14,
      defaultProps: {
        size: "md",
        colorScheme: "blue"
      }
    });
    var import_anatomy19 = require_dist8();
    var import_styled_system30 = require_dist4();
    var { defineMultiStyleConfig: defineMultiStyleConfig19, definePartsStyle: definePartsStyle19 } = (0, import_styled_system30.createMultiStyleConfigHelpers)(import_anatomy19.selectAnatomy.keys);
    var $bg10 = (0, import_styled_system30.cssVar)("select-bg");
    var _a3;
    var baseStyleField2 = (0, import_styled_system30.defineStyle)({
      ...(_a3 = inputTheme.baseStyle) == null ? void 0 : _a3.field,
      appearance: "none",
      paddingBottom: "1px",
      lineHeight: "normal",
      bg: $bg10.reference,
      [$bg10.variable]: "colors.white",
      _dark: {
        [$bg10.variable]: "colors.gray.700"
      },
      "> option, > optgroup": {
        bg: $bg10.reference
      }
    });
    var baseStyleIcon5 = (0, import_styled_system30.defineStyle)({
      width: "6",
      height: "100%",
      insetEnd: "2",
      position: "relative",
      color: "currentColor",
      fontSize: "xl",
      _disabled: {
        opacity: 0.5
      }
    });
    var baseStyle30 = definePartsStyle19({
      field: baseStyleField2,
      icon: baseStyleIcon5
    });
    var iconSpacing = (0, import_styled_system30.defineStyle)({
      paddingInlineEnd: "8"
    });
    var _a4;
    var _b2;
    var _c;
    var _d;
    var _e;
    var _f;
    var _g;
    var _h;
    var sizes15 = {
      lg: {
        ...(_a4 = inputTheme.sizes) == null ? void 0 : _a4.lg,
        field: {
          ...(_b2 = inputTheme.sizes) == null ? void 0 : _b2.lg.field,
          ...iconSpacing
        }
      },
      md: {
        ...(_c = inputTheme.sizes) == null ? void 0 : _c.md,
        field: {
          ...(_d = inputTheme.sizes) == null ? void 0 : _d.md.field,
          ...iconSpacing
        }
      },
      sm: {
        ...(_e = inputTheme.sizes) == null ? void 0 : _e.sm,
        field: {
          ...(_f = inputTheme.sizes) == null ? void 0 : _f.sm.field,
          ...iconSpacing
        }
      },
      xs: {
        ...(_g = inputTheme.sizes) == null ? void 0 : _g.xs,
        field: {
          ...(_h = inputTheme.sizes) == null ? void 0 : _h.xs.field,
          ...iconSpacing
        },
        icon: {
          insetEnd: "1"
        }
      }
    };
    var selectTheme = defineMultiStyleConfig19({
      baseStyle: baseStyle30,
      sizes: sizes15,
      variants: inputTheme.variants,
      defaultProps: inputTheme.defaultProps
    });
    var import_styled_system31 = require_dist4();
    var $startColor = (0, import_styled_system31.cssVar)("skeleton-start-color");
    var $endColor = (0, import_styled_system31.cssVar)("skeleton-end-color");
    var baseStyle31 = (0, import_styled_system31.defineStyle)({
      [$startColor.variable]: "colors.gray.100",
      [$endColor.variable]: "colors.gray.400",
      _dark: {
        [$startColor.variable]: "colors.gray.800",
        [$endColor.variable]: "colors.gray.600"
      },
      background: $startColor.reference,
      borderColor: $endColor.reference,
      opacity: 0.7,
      borderRadius: "sm"
    });
    var skeletonTheme = (0, import_styled_system31.defineStyleConfig)({
      baseStyle: baseStyle31
    });
    var import_styled_system32 = require_dist4();
    var $bg11 = (0, import_styled_system32.cssVar)("skip-link-bg");
    var baseStyle32 = (0, import_styled_system32.defineStyle)({
      borderRadius: "md",
      fontWeight: "semibold",
      _focusVisible: {
        boxShadow: "outline",
        padding: "4",
        position: "fixed",
        top: "6",
        insetStart: "6",
        [$bg11.variable]: "colors.white",
        _dark: {
          [$bg11.variable]: "colors.gray.700"
        },
        bg: $bg11.reference
      }
    });
    var skipLinkTheme = (0, import_styled_system32.defineStyleConfig)({
      baseStyle: baseStyle32
    });
    var import_anatomy20 = require_dist8();
    var import_styled_system33 = require_dist4();
    var import_theme_tools11 = require_dist9();
    var { defineMultiStyleConfig: defineMultiStyleConfig20, definePartsStyle: definePartsStyle20 } = (0, import_styled_system33.createMultiStyleConfigHelpers)(import_anatomy20.sliderAnatomy.keys);
    var $thumbSize = (0, import_styled_system33.cssVar)("slider-thumb-size");
    var $trackSize = (0, import_styled_system33.cssVar)("slider-track-size");
    var $bg12 = (0, import_styled_system33.cssVar)("slider-bg");
    var baseStyleContainer4 = (0, import_styled_system33.defineStyle)((props) => {
      const { orientation } = props;
      return {
        display: "inline-block",
        position: "relative",
        cursor: "pointer",
        _disabled: {
          opacity: 0.6,
          cursor: "default",
          pointerEvents: "none"
        },
        ...(0, import_theme_tools11.orient)({
          orientation,
          vertical: { h: "100%" },
          horizontal: { w: "100%" }
        })
      };
    });
    var baseStyleTrack2 = (0, import_styled_system33.defineStyle)((props) => {
      const orientationStyles = (0, import_theme_tools11.orient)({
        orientation: props.orientation,
        horizontal: { h: $trackSize.reference },
        vertical: { w: $trackSize.reference }
      });
      return {
        ...orientationStyles,
        overflow: "hidden",
        borderRadius: "sm",
        [$bg12.variable]: "colors.gray.200",
        _dark: {
          [$bg12.variable]: "colors.whiteAlpha.200"
        },
        _disabled: {
          [$bg12.variable]: "colors.gray.300",
          _dark: {
            [$bg12.variable]: "colors.whiteAlpha.300"
          }
        },
        bg: $bg12.reference
      };
    });
    var baseStyleThumb = (0, import_styled_system33.defineStyle)((props) => {
      const { orientation } = props;
      const orientationStyle = (0, import_theme_tools11.orient)({
        orientation,
        vertical: {
          left: "50%",
          transform: `translateX(-50%)`,
          _active: {
            transform: `translateX(-50%) scale(1.15)`
          }
        },
        horizontal: {
          top: "50%",
          transform: `translateY(-50%)`,
          _active: {
            transform: `translateY(-50%) scale(1.15)`
          }
        }
      });
      return {
        ...orientationStyle,
        w: $thumbSize.reference,
        h: $thumbSize.reference,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        position: "absolute",
        outline: 0,
        zIndex: 1,
        borderRadius: "full",
        bg: "white",
        boxShadow: "base",
        border: "1px solid",
        borderColor: "transparent",
        transitionProperty: "transform",
        transitionDuration: "normal",
        _focusVisible: {
          boxShadow: "outline"
        },
        _disabled: {
          bg: "gray.300"
        }
      };
    });
    var baseStyleFilledTrack2 = (0, import_styled_system33.defineStyle)((props) => {
      const { colorScheme: c } = props;
      return {
        width: "inherit",
        height: "inherit",
        [$bg12.variable]: `colors.${c}.500`,
        _dark: {
          [$bg12.variable]: `colors.${c}.200`
        },
        bg: $bg12.reference
      };
    });
    var baseStyle33 = definePartsStyle20((props) => ({
      container: baseStyleContainer4(props),
      track: baseStyleTrack2(props),
      thumb: baseStyleThumb(props),
      filledTrack: baseStyleFilledTrack2(props)
    }));
    var sizeLg = definePartsStyle20({
      container: {
        [$thumbSize.variable]: `sizes.4`,
        [$trackSize.variable]: `sizes.1`
      }
    });
    var sizeMd = definePartsStyle20({
      container: {
        [$thumbSize.variable]: `sizes.3.5`,
        [$trackSize.variable]: `sizes.1`
      }
    });
    var sizeSm = definePartsStyle20({
      container: {
        [$thumbSize.variable]: `sizes.2.5`,
        [$trackSize.variable]: `sizes.0.5`
      }
    });
    var sizes16 = {
      lg: sizeLg,
      md: sizeMd,
      sm: sizeSm
    };
    var sliderTheme = defineMultiStyleConfig20({
      baseStyle: baseStyle33,
      sizes: sizes16,
      defaultProps: {
        size: "md",
        colorScheme: "blue"
      }
    });
    var import_styled_system34 = require_dist4();
    var import_theme_tools12 = require_dist9();
    var $size3 = (0, import_theme_tools12.cssVar)("spinner-size");
    var baseStyle34 = (0, import_styled_system34.defineStyle)({
      width: [$size3.reference],
      height: [$size3.reference]
    });
    var sizes17 = {
      xs: (0, import_styled_system34.defineStyle)({
        [$size3.variable]: "sizes.3"
      }),
      sm: (0, import_styled_system34.defineStyle)({
        [$size3.variable]: "sizes.4"
      }),
      md: (0, import_styled_system34.defineStyle)({
        [$size3.variable]: "sizes.6"
      }),
      lg: (0, import_styled_system34.defineStyle)({
        [$size3.variable]: "sizes.8"
      }),
      xl: (0, import_styled_system34.defineStyle)({
        [$size3.variable]: "sizes.12"
      })
    };
    var spinnerTheme = (0, import_styled_system34.defineStyleConfig)({
      baseStyle: baseStyle34,
      sizes: sizes17,
      defaultProps: {
        size: "md"
      }
    });
    var import_anatomy21 = require_dist8();
    var import_styled_system35 = require_dist4();
    var { defineMultiStyleConfig: defineMultiStyleConfig21, definePartsStyle: definePartsStyle21 } = (0, import_styled_system35.createMultiStyleConfigHelpers)(import_anatomy21.statAnatomy.keys);
    var baseStyleLabel3 = (0, import_styled_system35.defineStyle)({
      fontWeight: "medium"
    });
    var baseStyleHelpText = (0, import_styled_system35.defineStyle)({
      opacity: 0.8,
      marginBottom: "2"
    });
    var baseStyleNumber = (0, import_styled_system35.defineStyle)({
      verticalAlign: "baseline",
      fontWeight: "semibold"
    });
    var baseStyleIcon6 = (0, import_styled_system35.defineStyle)({
      marginEnd: 1,
      w: "3.5",
      h: "3.5",
      verticalAlign: "middle"
    });
    var baseStyle35 = definePartsStyle21({
      container: {},
      label: baseStyleLabel3,
      helpText: baseStyleHelpText,
      number: baseStyleNumber,
      icon: baseStyleIcon6
    });
    var sizes18 = {
      md: definePartsStyle21({
        label: { fontSize: "sm" },
        helpText: { fontSize: "sm" },
        number: { fontSize: "2xl" }
      })
    };
    var statTheme = defineMultiStyleConfig21({
      baseStyle: baseStyle35,
      sizes: sizes18,
      defaultProps: {
        size: "md"
      }
    });
    var import_styled_system36 = require_dist4();
    var { defineMultiStyleConfig: defineMultiStyleConfig22, definePartsStyle: definePartsStyle22 } = (0, import_styled_system36.createMultiStyleConfigHelpers)([
      "stepper",
      "step",
      "title",
      "description",
      "indicator",
      "separator",
      "icon",
      "number"
    ]);
    var $size4 = (0, import_styled_system36.cssVar)("stepper-indicator-size");
    var $iconSize = (0, import_styled_system36.cssVar)("stepper-icon-size");
    var $titleFontSize = (0, import_styled_system36.cssVar)("stepper-title-font-size");
    var $descFontSize = (0, import_styled_system36.cssVar)("stepper-description-font-size");
    var $accentColor = (0, import_styled_system36.cssVar)("stepper-accent-color");
    var baseStyle36 = definePartsStyle22(({ colorScheme: c }) => ({
      stepper: {
        display: "flex",
        justifyContent: "space-between",
        gap: "4",
        "&[data-orientation=vertical]": {
          flexDirection: "column",
          alignItems: "flex-start"
        },
        "&[data-orientation=horizontal]": {
          flexDirection: "row",
          alignItems: "center"
        },
        [$accentColor.variable]: `colors.${c}.500`,
        _dark: {
          [$accentColor.variable]: `colors.${c}.200`
        }
      },
      title: {
        fontSize: $titleFontSize.reference,
        fontWeight: "medium"
      },
      description: {
        fontSize: $descFontSize.reference,
        color: "chakra-subtle-text"
      },
      number: {
        fontSize: $titleFontSize.reference
      },
      step: {
        flexShrink: 0,
        position: "relative",
        display: "flex",
        gap: "2",
        "&[data-orientation=horizontal]": {
          alignItems: "center"
        },
        flex: "1",
        "&:last-of-type:not([data-stretch])": {
          flex: "initial"
        }
      },
      icon: {
        flexShrink: 0,
        width: $iconSize.reference,
        height: $iconSize.reference
      },
      indicator: {
        flexShrink: 0,
        borderRadius: "full",
        width: $size4.reference,
        height: $size4.reference,
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        "&[data-status=active]": {
          borderWidth: "2px",
          borderColor: $accentColor.reference
        },
        "&[data-status=complete]": {
          bg: $accentColor.reference,
          color: "chakra-inverse-text"
        },
        "&[data-status=incomplete]": {
          borderWidth: "2px"
        }
      },
      separator: {
        bg: "chakra-border-color",
        flex: "1",
        "&[data-status=complete]": {
          bg: $accentColor.reference
        },
        "&[data-orientation=horizontal]": {
          width: "100%",
          height: "2px",
          marginStart: "2"
        },
        "&[data-orientation=vertical]": {
          width: "2px",
          position: "absolute",
          height: "100%",
          maxHeight: `calc(100% - ${$size4.reference} - 8px)`,
          top: `calc(${$size4.reference} + 4px)`,
          insetStart: `calc(${$size4.reference} / 2 - 1px)`
        }
      }
    }));
    var stepperTheme = defineMultiStyleConfig22({
      baseStyle: baseStyle36,
      sizes: {
        xs: definePartsStyle22({
          stepper: {
            [$size4.variable]: "sizes.4",
            [$iconSize.variable]: "sizes.3",
            [$titleFontSize.variable]: "fontSizes.xs",
            [$descFontSize.variable]: "fontSizes.xs"
          }
        }),
        sm: definePartsStyle22({
          stepper: {
            [$size4.variable]: "sizes.6",
            [$iconSize.variable]: "sizes.4",
            [$titleFontSize.variable]: "fontSizes.sm",
            [$descFontSize.variable]: "fontSizes.xs"
          }
        }),
        md: definePartsStyle22({
          stepper: {
            [$size4.variable]: "sizes.8",
            [$iconSize.variable]: "sizes.5",
            [$titleFontSize.variable]: "fontSizes.md",
            [$descFontSize.variable]: "fontSizes.sm"
          }
        }),
        lg: definePartsStyle22({
          stepper: {
            [$size4.variable]: "sizes.10",
            [$iconSize.variable]: "sizes.6",
            [$titleFontSize.variable]: "fontSizes.lg",
            [$descFontSize.variable]: "fontSizes.md"
          }
        })
      },
      defaultProps: {
        size: "md",
        colorScheme: "blue"
      }
    });
    var import_anatomy22 = require_dist8();
    var import_styled_system37 = require_dist4();
    var import_theme_tools13 = require_dist9();
    var { defineMultiStyleConfig: defineMultiStyleConfig23, definePartsStyle: definePartsStyle23 } = (0, import_styled_system37.createMultiStyleConfigHelpers)(import_anatomy22.switchAnatomy.keys);
    var $width = (0, import_theme_tools13.cssVar)("switch-track-width");
    var $height = (0, import_theme_tools13.cssVar)("switch-track-height");
    var $diff = (0, import_theme_tools13.cssVar)("switch-track-diff");
    var diffValue = import_theme_tools13.calc.subtract($width, $height);
    var $translateX = (0, import_theme_tools13.cssVar)("switch-thumb-x");
    var $bg13 = (0, import_theme_tools13.cssVar)("switch-bg");
    var baseStyleTrack3 = (0, import_styled_system37.defineStyle)((props) => {
      const { colorScheme: c } = props;
      return {
        borderRadius: "full",
        p: "0.5",
        width: [$width.reference],
        height: [$height.reference],
        transitionProperty: "common",
        transitionDuration: "fast",
        [$bg13.variable]: "colors.gray.300",
        _dark: {
          [$bg13.variable]: "colors.whiteAlpha.400"
        },
        _focusVisible: {
          boxShadow: "outline"
        },
        _disabled: {
          opacity: 0.4,
          cursor: "not-allowed"
        },
        _checked: {
          [$bg13.variable]: `colors.${c}.500`,
          _dark: {
            [$bg13.variable]: `colors.${c}.200`
          }
        },
        bg: $bg13.reference
      };
    });
    var baseStyleThumb2 = (0, import_styled_system37.defineStyle)({
      bg: "white",
      transitionProperty: "transform",
      transitionDuration: "normal",
      borderRadius: "inherit",
      width: [$height.reference],
      height: [$height.reference],
      _checked: {
        transform: `translateX(${$translateX.reference})`
      }
    });
    var baseStyle37 = definePartsStyle23((props) => ({
      container: {
        [$diff.variable]: diffValue,
        [$translateX.variable]: $diff.reference,
        _rtl: {
          [$translateX.variable]: (0, import_theme_tools13.calc)($diff).negate().toString()
        }
      },
      track: baseStyleTrack3(props),
      thumb: baseStyleThumb2
    }));
    var sizes19 = {
      sm: definePartsStyle23({
        container: {
          [$width.variable]: "1.375rem",
          [$height.variable]: "sizes.3"
        }
      }),
      md: definePartsStyle23({
        container: {
          [$width.variable]: "1.875rem",
          [$height.variable]: "sizes.4"
        }
      }),
      lg: definePartsStyle23({
        container: {
          [$width.variable]: "2.875rem",
          [$height.variable]: "sizes.6"
        }
      })
    };
    var switchTheme = defineMultiStyleConfig23({
      baseStyle: baseStyle37,
      sizes: sizes19,
      defaultProps: {
        size: "md",
        colorScheme: "blue"
      }
    });
    var import_anatomy23 = require_dist8();
    var import_styled_system38 = require_dist4();
    var import_theme_tools14 = require_dist9();
    var { defineMultiStyleConfig: defineMultiStyleConfig24, definePartsStyle: definePartsStyle24 } = (0, import_styled_system38.createMultiStyleConfigHelpers)(import_anatomy23.tableAnatomy.keys);
    var baseStyle38 = definePartsStyle24({
      table: {
        fontVariantNumeric: "lining-nums tabular-nums",
        borderCollapse: "collapse",
        width: "full"
      },
      th: {
        fontFamily: "heading",
        fontWeight: "bold",
        textTransform: "uppercase",
        letterSpacing: "wider",
        textAlign: "start"
      },
      td: {
        textAlign: "start"
      },
      caption: {
        mt: 4,
        fontFamily: "heading",
        textAlign: "center",
        fontWeight: "medium"
      }
    });
    var numericStyles = (0, import_styled_system38.defineStyle)({
      "&[data-is-numeric=true]": {
        textAlign: "end"
      }
    });
    var variantSimple = definePartsStyle24((props) => {
      const { colorScheme: c } = props;
      return {
        th: {
          color: (0, import_theme_tools14.mode)("gray.600", "gray.400")(props),
          borderBottom: "1px",
          borderColor: (0, import_theme_tools14.mode)(`${c}.100`, `${c}.700`)(props),
          ...numericStyles
        },
        td: {
          borderBottom: "1px",
          borderColor: (0, import_theme_tools14.mode)(`${c}.100`, `${c}.700`)(props),
          ...numericStyles
        },
        caption: {
          color: (0, import_theme_tools14.mode)("gray.600", "gray.100")(props)
        },
        tfoot: {
          tr: {
            "&:last-of-type": {
              th: { borderBottomWidth: 0 }
            }
          }
        }
      };
    });
    var variantStripe = definePartsStyle24((props) => {
      const { colorScheme: c } = props;
      return {
        th: {
          color: (0, import_theme_tools14.mode)("gray.600", "gray.400")(props),
          borderBottom: "1px",
          borderColor: (0, import_theme_tools14.mode)(`${c}.100`, `${c}.700`)(props),
          ...numericStyles
        },
        td: {
          borderBottom: "1px",
          borderColor: (0, import_theme_tools14.mode)(`${c}.100`, `${c}.700`)(props),
          ...numericStyles
        },
        caption: {
          color: (0, import_theme_tools14.mode)("gray.600", "gray.100")(props)
        },
        tbody: {
          tr: {
            "&:nth-of-type(odd)": {
              "th, td": {
                borderBottomWidth: "1px",
                borderColor: (0, import_theme_tools14.mode)(`${c}.100`, `${c}.700`)(props)
              },
              td: {
                background: (0, import_theme_tools14.mode)(`${c}.100`, `${c}.700`)(props)
              }
            }
          }
        },
        tfoot: {
          tr: {
            "&:last-of-type": {
              th: { borderBottomWidth: 0 }
            }
          }
        }
      };
    });
    var variants9 = {
      simple: variantSimple,
      striped: variantStripe,
      unstyled: (0, import_styled_system38.defineStyle)({})
    };
    var sizes20 = {
      sm: definePartsStyle24({
        th: {
          px: "4",
          py: "1",
          lineHeight: "4",
          fontSize: "xs"
        },
        td: {
          px: "4",
          py: "2",
          fontSize: "sm",
          lineHeight: "4"
        },
        caption: {
          px: "4",
          py: "2",
          fontSize: "xs"
        }
      }),
      md: definePartsStyle24({
        th: {
          px: "6",
          py: "3",
          lineHeight: "4",
          fontSize: "xs"
        },
        td: {
          px: "6",
          py: "4",
          lineHeight: "5"
        },
        caption: {
          px: "6",
          py: "2",
          fontSize: "sm"
        }
      }),
      lg: definePartsStyle24({
        th: {
          px: "8",
          py: "4",
          lineHeight: "5",
          fontSize: "sm"
        },
        td: {
          px: "8",
          py: "5",
          lineHeight: "6"
        },
        caption: {
          px: "6",
          py: "2",
          fontSize: "md"
        }
      })
    };
    var tableTheme = defineMultiStyleConfig24({
      baseStyle: baseStyle38,
      variants: variants9,
      sizes: sizes20,
      defaultProps: {
        variant: "simple",
        size: "md",
        colorScheme: "gray"
      }
    });
    var import_anatomy24 = require_dist8();
    var import_styled_system39 = require_dist4();
    var import_theme_tools15 = require_dist9();
    var $fg5 = (0, import_styled_system39.cssVar)("tabs-color");
    var $bg14 = (0, import_styled_system39.cssVar)("tabs-bg");
    var $border4 = (0, import_styled_system39.cssVar)("tabs-border-color");
    var { defineMultiStyleConfig: defineMultiStyleConfig25, definePartsStyle: definePartsStyle25 } = (0, import_styled_system39.createMultiStyleConfigHelpers)(import_anatomy24.tabsAnatomy.keys);
    var baseStyleRoot2 = (0, import_styled_system39.defineStyle)((props) => {
      const { orientation } = props;
      return {
        display: orientation === "vertical" ? "flex" : "block"
      };
    });
    var baseStyleTab = (0, import_styled_system39.defineStyle)((props) => {
      const { isFitted } = props;
      return {
        flex: isFitted ? 1 : void 0,
        transitionProperty: "common",
        transitionDuration: "normal",
        _focusVisible: {
          zIndex: 1,
          boxShadow: "outline"
        },
        _disabled: {
          cursor: "not-allowed",
          opacity: 0.4
        }
      };
    });
    var baseStyleTablist = (0, import_styled_system39.defineStyle)((props) => {
      const { align = "start", orientation } = props;
      const alignments = {
        end: "flex-end",
        center: "center",
        start: "flex-start"
      };
      return {
        justifyContent: alignments[align],
        flexDirection: orientation === "vertical" ? "column" : "row"
      };
    });
    var baseStyleTabpanel = (0, import_styled_system39.defineStyle)({
      p: 4
    });
    var baseStyle39 = definePartsStyle25((props) => ({
      root: baseStyleRoot2(props),
      tab: baseStyleTab(props),
      tablist: baseStyleTablist(props),
      tabpanel: baseStyleTabpanel
    }));
    var sizes21 = {
      sm: definePartsStyle25({
        tab: {
          py: 1,
          px: 4,
          fontSize: "sm"
        }
      }),
      md: definePartsStyle25({
        tab: {
          fontSize: "md",
          py: 2,
          px: 4
        }
      }),
      lg: definePartsStyle25({
        tab: {
          fontSize: "lg",
          py: 3,
          px: 4
        }
      })
    };
    var variantLine = definePartsStyle25((props) => {
      const { colorScheme: c, orientation } = props;
      const isVertical = orientation === "vertical";
      const borderProp = isVertical ? "borderStart" : "borderBottom";
      const marginProp = isVertical ? "marginStart" : "marginBottom";
      return {
        tablist: {
          [borderProp]: "2px solid",
          borderColor: "inherit"
        },
        tab: {
          [borderProp]: "2px solid",
          borderColor: "transparent",
          [marginProp]: "-2px",
          _selected: {
            [$fg5.variable]: `colors.${c}.600`,
            _dark: {
              [$fg5.variable]: `colors.${c}.300`
            },
            borderColor: "currentColor"
          },
          _active: {
            [$bg14.variable]: "colors.gray.200",
            _dark: {
              [$bg14.variable]: "colors.whiteAlpha.300"
            }
          },
          _disabled: {
            _active: { bg: "none" }
          },
          color: $fg5.reference,
          bg: $bg14.reference
        }
      };
    });
    var variantEnclosed = definePartsStyle25((props) => {
      const { colorScheme: c } = props;
      return {
        tab: {
          borderTopRadius: "md",
          border: "1px solid",
          borderColor: "transparent",
          mb: "-1px",
          [$border4.variable]: "transparent",
          _selected: {
            [$fg5.variable]: `colors.${c}.600`,
            [$border4.variable]: `colors.white`,
            _dark: {
              [$fg5.variable]: `colors.${c}.300`,
              [$border4.variable]: `colors.gray.800`
            },
            borderColor: "inherit",
            borderBottomColor: $border4.reference
          },
          color: $fg5.reference
        },
        tablist: {
          mb: "-1px",
          borderBottom: "1px solid",
          borderColor: "inherit"
        }
      };
    });
    var variantEnclosedColored = definePartsStyle25((props) => {
      const { colorScheme: c } = props;
      return {
        tab: {
          border: "1px solid",
          borderColor: "inherit",
          [$bg14.variable]: "colors.gray.50",
          _dark: {
            [$bg14.variable]: "colors.whiteAlpha.50"
          },
          mb: "-1px",
          _notLast: {
            marginEnd: "-1px"
          },
          _selected: {
            [$bg14.variable]: "colors.white",
            [$fg5.variable]: `colors.${c}.600`,
            _dark: {
              [$bg14.variable]: "colors.gray.800",
              [$fg5.variable]: `colors.${c}.300`
            },
            borderColor: "inherit",
            borderTopColor: "currentColor",
            borderBottomColor: "transparent"
          },
          color: $fg5.reference,
          bg: $bg14.reference
        },
        tablist: {
          mb: "-1px",
          borderBottom: "1px solid",
          borderColor: "inherit"
        }
      };
    });
    var variantSoftRounded = definePartsStyle25((props) => {
      const { colorScheme: c, theme: theme2 } = props;
      return {
        tab: {
          borderRadius: "full",
          fontWeight: "semibold",
          color: "gray.600",
          _selected: {
            color: (0, import_theme_tools15.getColor)(theme2, `${c}.700`),
            bg: (0, import_theme_tools15.getColor)(theme2, `${c}.100`)
          }
        }
      };
    });
    var variantSolidRounded = definePartsStyle25((props) => {
      const { colorScheme: c } = props;
      return {
        tab: {
          borderRadius: "full",
          fontWeight: "semibold",
          [$fg5.variable]: "colors.gray.600",
          _dark: {
            [$fg5.variable]: "inherit"
          },
          _selected: {
            [$fg5.variable]: "colors.white",
            [$bg14.variable]: `colors.${c}.600`,
            _dark: {
              [$fg5.variable]: "colors.gray.800",
              [$bg14.variable]: `colors.${c}.300`
            }
          },
          color: $fg5.reference,
          bg: $bg14.reference
        }
      };
    });
    var variantUnstyled3 = definePartsStyle25({});
    var variants10 = {
      line: variantLine,
      enclosed: variantEnclosed,
      "enclosed-colored": variantEnclosedColored,
      "soft-rounded": variantSoftRounded,
      "solid-rounded": variantSolidRounded,
      unstyled: variantUnstyled3
    };
    var tabsTheme = defineMultiStyleConfig25({
      baseStyle: baseStyle39,
      sizes: sizes21,
      variants: variants10,
      defaultProps: {
        size: "md",
        variant: "line",
        colorScheme: "blue"
      }
    });
    var import_anatomy25 = require_dist8();
    var import_styled_system40 = require_dist4();
    var { defineMultiStyleConfig: defineMultiStyleConfig26, definePartsStyle: definePartsStyle26 } = (0, import_styled_system40.createMultiStyleConfigHelpers)(import_anatomy25.tagAnatomy.keys);
    var $bg15 = (0, import_styled_system40.cssVar)("tag-bg");
    var $color = (0, import_styled_system40.cssVar)("tag-color");
    var $shadow4 = (0, import_styled_system40.cssVar)("tag-shadow");
    var $minH = (0, import_styled_system40.cssVar)("tag-min-height");
    var $minW = (0, import_styled_system40.cssVar)("tag-min-width");
    var $fontSize = (0, import_styled_system40.cssVar)("tag-font-size");
    var $paddingX = (0, import_styled_system40.cssVar)("tag-padding-inline");
    var baseStyleContainer5 = (0, import_styled_system40.defineStyle)({
      fontWeight: "medium",
      lineHeight: 1.2,
      outline: 0,
      [$color.variable]: vars.color.reference,
      [$bg15.variable]: vars.bg.reference,
      [$shadow4.variable]: vars.shadow.reference,
      color: $color.reference,
      bg: $bg15.reference,
      boxShadow: $shadow4.reference,
      borderRadius: "md",
      minH: $minH.reference,
      minW: $minW.reference,
      fontSize: $fontSize.reference,
      px: $paddingX.reference,
      _focusVisible: {
        [$shadow4.variable]: "shadows.outline"
      }
    });
    var baseStyleLabel4 = (0, import_styled_system40.defineStyle)({
      lineHeight: 1.2,
      overflow: "visible"
    });
    var baseStyleCloseButton4 = (0, import_styled_system40.defineStyle)({
      fontSize: "lg",
      w: "5",
      h: "5",
      transitionProperty: "common",
      transitionDuration: "normal",
      borderRadius: "full",
      marginStart: "1.5",
      marginEnd: "-1",
      opacity: 0.5,
      _disabled: {
        opacity: 0.4
      },
      _focusVisible: {
        boxShadow: "outline",
        bg: "rgba(0, 0, 0, 0.14)"
      },
      _hover: {
        opacity: 0.8
      },
      _active: {
        opacity: 1
      }
    });
    var baseStyle40 = definePartsStyle26({
      container: baseStyleContainer5,
      label: baseStyleLabel4,
      closeButton: baseStyleCloseButton4
    });
    var sizes22 = {
      sm: definePartsStyle26({
        container: {
          [$minH.variable]: "sizes.5",
          [$minW.variable]: "sizes.5",
          [$fontSize.variable]: "fontSizes.xs",
          [$paddingX.variable]: "space.2"
        },
        closeButton: {
          marginEnd: "-2px",
          marginStart: "0.35rem"
        }
      }),
      md: definePartsStyle26({
        container: {
          [$minH.variable]: "sizes.6",
          [$minW.variable]: "sizes.6",
          [$fontSize.variable]: "fontSizes.sm",
          [$paddingX.variable]: "space.2"
        }
      }),
      lg: definePartsStyle26({
        container: {
          [$minH.variable]: "sizes.8",
          [$minW.variable]: "sizes.8",
          [$fontSize.variable]: "fontSizes.md",
          [$paddingX.variable]: "space.3"
        }
      })
    };
    var variants11 = {
      subtle: definePartsStyle26((props) => {
        var _a8;
        return {
          container: (_a8 = badgeTheme.variants) == null ? void 0 : _a8.subtle(props)
        };
      }),
      solid: definePartsStyle26((props) => {
        var _a8;
        return {
          container: (_a8 = badgeTheme.variants) == null ? void 0 : _a8.solid(props)
        };
      }),
      outline: definePartsStyle26((props) => {
        var _a8;
        return {
          container: (_a8 = badgeTheme.variants) == null ? void 0 : _a8.outline(props)
        };
      })
    };
    var tagTheme = defineMultiStyleConfig26({
      variants: variants11,
      baseStyle: baseStyle40,
      sizes: sizes22,
      defaultProps: {
        size: "md",
        variant: "subtle",
        colorScheme: "gray"
      }
    });
    var import_styled_system41 = require_dist4();
    var _a5;
    var baseStyle41 = (0, import_styled_system41.defineStyle)({
      ...(_a5 = inputTheme.baseStyle) == null ? void 0 : _a5.field,
      paddingY: "2",
      minHeight: "20",
      lineHeight: "short",
      verticalAlign: "top"
    });
    var _a6;
    var _b3;
    var variants12 = {
      outline: (0, import_styled_system41.defineStyle)(
        (props) => {
          var _a8, _b5;
          return (_b5 = (_a8 = inputTheme.variants) == null ? void 0 : _a8.outline(props).field) != null ? _b5 : {};
        }
      ),
      flushed: (0, import_styled_system41.defineStyle)(
        (props) => {
          var _a8, _b5;
          return (_b5 = (_a8 = inputTheme.variants) == null ? void 0 : _a8.flushed(props).field) != null ? _b5 : {};
        }
      ),
      filled: (0, import_styled_system41.defineStyle)(
        (props) => {
          var _a8, _b5;
          return (_b5 = (_a8 = inputTheme.variants) == null ? void 0 : _a8.filled(props).field) != null ? _b5 : {};
        }
      ),
      unstyled: (_b3 = (_a6 = inputTheme.variants) == null ? void 0 : _a6.unstyled.field) != null ? _b3 : {}
    };
    var _a7;
    var _b4;
    var _c2;
    var _d2;
    var _e2;
    var _f2;
    var _g2;
    var _h2;
    var sizes23 = {
      xs: (_b4 = (_a7 = inputTheme.sizes) == null ? void 0 : _a7.xs.field) != null ? _b4 : {},
      sm: (_d2 = (_c2 = inputTheme.sizes) == null ? void 0 : _c2.sm.field) != null ? _d2 : {},
      md: (_f2 = (_e2 = inputTheme.sizes) == null ? void 0 : _e2.md.field) != null ? _f2 : {},
      lg: (_h2 = (_g2 = inputTheme.sizes) == null ? void 0 : _g2.lg.field) != null ? _h2 : {}
    };
    var textareaTheme = (0, import_styled_system41.defineStyleConfig)({
      baseStyle: baseStyle41,
      sizes: sizes23,
      variants: variants12,
      defaultProps: {
        size: "md",
        variant: "outline"
      }
    });
    var import_styled_system42 = require_dist4();
    var import_theme_tools16 = require_dist9();
    var $bg16 = (0, import_theme_tools16.cssVar)("tooltip-bg");
    var $fg6 = (0, import_theme_tools16.cssVar)("tooltip-fg");
    var $arrowBg2 = (0, import_theme_tools16.cssVar)("popper-arrow-bg");
    var baseStyle42 = (0, import_styled_system42.defineStyle)({
      bg: $bg16.reference,
      color: $fg6.reference,
      [$bg16.variable]: "colors.gray.700",
      [$fg6.variable]: "colors.whiteAlpha.900",
      _dark: {
        [$bg16.variable]: "colors.gray.300",
        [$fg6.variable]: "colors.gray.900"
      },
      [$arrowBg2.variable]: $bg16.reference,
      px: "2",
      py: "0.5",
      borderRadius: "sm",
      fontWeight: "medium",
      fontSize: "sm",
      boxShadow: "md",
      maxW: "xs",
      zIndex: "tooltip"
    });
    var tooltipTheme = (0, import_styled_system42.defineStyleConfig)({
      baseStyle: baseStyle42
    });
    var components = {
      Accordion: accordionTheme,
      Alert: alertTheme,
      Avatar: avatarTheme,
      Badge: badgeTheme,
      Breadcrumb: breadcrumbTheme,
      Button: buttonTheme,
      Checkbox: checkboxTheme,
      CloseButton: closeButtonTheme,
      Code: codeTheme,
      Container: containerTheme,
      Divider: dividerTheme,
      Drawer: drawerTheme,
      Editable: editableTheme,
      Form: formTheme,
      FormError: formErrorTheme,
      FormLabel: formLabelTheme,
      Heading: headingTheme,
      Input: inputTheme,
      Kbd: kbdTheme,
      Link: linkTheme,
      List: listTheme,
      Menu: menuTheme,
      Modal: modalTheme,
      NumberInput: numberInputTheme,
      PinInput: pinInputTheme,
      Popover: popoverTheme,
      Progress: progressTheme,
      Radio: radioTheme,
      Select: selectTheme,
      Skeleton: skeletonTheme,
      SkipLink: skipLinkTheme,
      Slider: sliderTheme,
      Spinner: spinnerTheme,
      Stat: statTheme,
      Switch: switchTheme,
      Table: tableTheme,
      Tabs: tabsTheme,
      Tag: tagTheme,
      Textarea: textareaTheme,
      Tooltip: tooltipTheme,
      Card: cardTheme,
      Stepper: stepperTheme
    };
    var borders = {
      none: 0,
      "1px": "1px solid",
      "2px": "2px solid",
      "4px": "4px solid",
      "8px": "8px solid"
    };
    var borders_default = borders;
    var breakpoints = {
      base: "0em",
      sm: "30em",
      md: "48em",
      lg: "62em",
      xl: "80em",
      "2xl": "96em"
    };
    var breakpoints_default = breakpoints;
    var colors = {
      transparent: "transparent",
      current: "currentColor",
      black: "#000000",
      white: "#FFFFFF",
      whiteAlpha: {
        50: "rgba(255, 255, 255, 0.04)",
        100: "rgba(255, 255, 255, 0.06)",
        200: "rgba(255, 255, 255, 0.08)",
        300: "rgba(255, 255, 255, 0.16)",
        400: "rgba(255, 255, 255, 0.24)",
        500: "rgba(255, 255, 255, 0.36)",
        600: "rgba(255, 255, 255, 0.48)",
        700: "rgba(255, 255, 255, 0.64)",
        800: "rgba(255, 255, 255, 0.80)",
        900: "rgba(255, 255, 255, 0.92)"
      },
      blackAlpha: {
        50: "rgba(0, 0, 0, 0.04)",
        100: "rgba(0, 0, 0, 0.06)",
        200: "rgba(0, 0, 0, 0.08)",
        300: "rgba(0, 0, 0, 0.16)",
        400: "rgba(0, 0, 0, 0.24)",
        500: "rgba(0, 0, 0, 0.36)",
        600: "rgba(0, 0, 0, 0.48)",
        700: "rgba(0, 0, 0, 0.64)",
        800: "rgba(0, 0, 0, 0.80)",
        900: "rgba(0, 0, 0, 0.92)"
      },
      gray: {
        50: "#F7FAFC",
        100: "#EDF2F7",
        200: "#E2E8F0",
        300: "#CBD5E0",
        400: "#A0AEC0",
        500: "#718096",
        600: "#4A5568",
        700: "#2D3748",
        800: "#1A202C",
        900: "#171923"
      },
      red: {
        50: "#FFF5F5",
        100: "#FED7D7",
        200: "#FEB2B2",
        300: "#FC8181",
        400: "#F56565",
        500: "#E53E3E",
        600: "#C53030",
        700: "#9B2C2C",
        800: "#822727",
        900: "#63171B"
      },
      orange: {
        50: "#FFFAF0",
        100: "#FEEBC8",
        200: "#FBD38D",
        300: "#F6AD55",
        400: "#ED8936",
        500: "#DD6B20",
        600: "#C05621",
        700: "#9C4221",
        800: "#7B341E",
        900: "#652B19"
      },
      yellow: {
        50: "#FFFFF0",
        100: "#FEFCBF",
        200: "#FAF089",
        300: "#F6E05E",
        400: "#ECC94B",
        500: "#D69E2E",
        600: "#B7791F",
        700: "#975A16",
        800: "#744210",
        900: "#5F370E"
      },
      green: {
        50: "#F0FFF4",
        100: "#C6F6D5",
        200: "#9AE6B4",
        300: "#68D391",
        400: "#48BB78",
        500: "#38A169",
        600: "#2F855A",
        700: "#276749",
        800: "#22543D",
        900: "#1C4532"
      },
      teal: {
        50: "#E6FFFA",
        100: "#B2F5EA",
        200: "#81E6D9",
        300: "#4FD1C5",
        400: "#38B2AC",
        500: "#319795",
        600: "#2C7A7B",
        700: "#285E61",
        800: "#234E52",
        900: "#1D4044"
      },
      blue: {
        50: "#ebf8ff",
        100: "#bee3f8",
        200: "#90cdf4",
        300: "#63b3ed",
        400: "#4299e1",
        500: "#3182ce",
        600: "#2b6cb0",
        700: "#2c5282",
        800: "#2a4365",
        900: "#1A365D"
      },
      cyan: {
        50: "#EDFDFD",
        100: "#C4F1F9",
        200: "#9DECF9",
        300: "#76E4F7",
        400: "#0BC5EA",
        500: "#00B5D8",
        600: "#00A3C4",
        700: "#0987A0",
        800: "#086F83",
        900: "#065666"
      },
      purple: {
        50: "#FAF5FF",
        100: "#E9D8FD",
        200: "#D6BCFA",
        300: "#B794F4",
        400: "#9F7AEA",
        500: "#805AD5",
        600: "#6B46C1",
        700: "#553C9A",
        800: "#44337A",
        900: "#322659"
      },
      pink: {
        50: "#FFF5F7",
        100: "#FED7E2",
        200: "#FBB6CE",
        300: "#F687B3",
        400: "#ED64A6",
        500: "#D53F8C",
        600: "#B83280",
        700: "#97266D",
        800: "#702459",
        900: "#521B41"
      },
      linkedin: {
        50: "#E8F4F9",
        100: "#CFEDFB",
        200: "#9BDAF3",
        300: "#68C7EC",
        400: "#34B3E4",
        500: "#00A0DC",
        600: "#008CC9",
        700: "#0077B5",
        800: "#005E93",
        900: "#004471"
      },
      facebook: {
        50: "#E8F4F9",
        100: "#D9DEE9",
        200: "#B7C2DA",
        300: "#6482C0",
        400: "#4267B2",
        500: "#385898",
        600: "#314E89",
        700: "#29487D",
        800: "#223B67",
        900: "#1E355B"
      },
      messenger: {
        50: "#D0E6FF",
        100: "#B9DAFF",
        200: "#A2CDFF",
        300: "#7AB8FF",
        400: "#2E90FF",
        500: "#0078FF",
        600: "#0063D1",
        700: "#0052AC",
        800: "#003C7E",
        900: "#002C5C"
      },
      whatsapp: {
        50: "#dffeec",
        100: "#b9f5d0",
        200: "#90edb3",
        300: "#65e495",
        400: "#3cdd78",
        500: "#22c35e",
        600: "#179848",
        700: "#0c6c33",
        800: "#01421c",
        900: "#001803"
      },
      twitter: {
        50: "#E5F4FD",
        100: "#C8E9FB",
        200: "#A8DCFA",
        300: "#83CDF7",
        400: "#57BBF5",
        500: "#1DA1F2",
        600: "#1A94DA",
        700: "#1681BF",
        800: "#136B9E",
        900: "#0D4D71"
      },
      telegram: {
        50: "#E3F2F9",
        100: "#C5E4F3",
        200: "#A2D4EC",
        300: "#7AC1E4",
        400: "#47A9DA",
        500: "#0088CC",
        600: "#007AB8",
        700: "#006BA1",
        800: "#005885",
        900: "#003F5E"
      }
    };
    var colors_default = colors;
    var radii = {
      none: "0",
      sm: "0.125rem",
      base: "0.25rem",
      md: "0.375rem",
      lg: "0.5rem",
      xl: "0.75rem",
      "2xl": "1rem",
      "3xl": "1.5rem",
      full: "9999px"
    };
    var radius_default = radii;
    var shadows = {
      xs: "0 0 0 1px rgba(0, 0, 0, 0.05)",
      sm: "0 1px 2px 0 rgba(0, 0, 0, 0.05)",
      base: "0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)",
      md: "0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)",
      lg: "0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)",
      xl: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)",
      "2xl": "0 25px 50px -12px rgba(0, 0, 0, 0.25)",
      outline: "0 0 0 3px rgba(66, 153, 225, 0.6)",
      inner: "inset 0 2px 4px 0 rgba(0,0,0,0.06)",
      none: "none",
      "dark-lg": "rgba(0, 0, 0, 0.1) 0px 0px 0px 1px, rgba(0, 0, 0, 0.2) 0px 5px 10px, rgba(0, 0, 0, 0.4) 0px 15px 40px"
    };
    var shadows_default = shadows;
    var transitionProperty = {
      common: "background-color, border-color, color, fill, stroke, opacity, box-shadow, transform",
      colors: "background-color, border-color, color, fill, stroke",
      dimensions: "width, height",
      position: "left, right, top, bottom",
      background: "background-color, background-image, background-position"
    };
    var transitionTimingFunction = {
      "ease-in": "cubic-bezier(0.4, 0, 1, 1)",
      "ease-out": "cubic-bezier(0, 0, 0.2, 1)",
      "ease-in-out": "cubic-bezier(0.4, 0, 0.2, 1)"
    };
    var transitionDuration = {
      "ultra-fast": "50ms",
      faster: "100ms",
      fast: "150ms",
      normal: "200ms",
      slow: "300ms",
      slower: "400ms",
      "ultra-slow": "500ms"
    };
    var transition = {
      property: transitionProperty,
      easing: transitionTimingFunction,
      duration: transitionDuration
    };
    var transition_default = transition;
    var zIndices = {
      hide: -1,
      auto: "auto",
      base: 0,
      docked: 10,
      dropdown: 1e3,
      sticky: 1100,
      banner: 1200,
      overlay: 1300,
      modal: 1400,
      popover: 1500,
      skipLink: 1600,
      toast: 1700,
      tooltip: 1800
    };
    var z_index_default = zIndices;
    var blur = {
      none: 0,
      sm: "4px",
      base: "8px",
      md: "12px",
      lg: "16px",
      xl: "24px",
      "2xl": "40px",
      "3xl": "64px"
    };
    var blur_default = blur;
    var foundations = {
      breakpoints: breakpoints_default,
      zIndices: z_index_default,
      radii: radius_default,
      blur: blur_default,
      colors: colors_default,
      ...typography_default,
      sizes: sizes_default,
      shadows: shadows_default,
      space: spacing,
      borders: borders_default,
      transition: transition_default
    };
    var semanticTokens = {
      colors: {
        "chakra-body-text": { _light: "gray.800", _dark: "whiteAlpha.900" },
        "chakra-body-bg": { _light: "white", _dark: "gray.800" },
        "chakra-border-color": { _light: "gray.200", _dark: "whiteAlpha.300" },
        "chakra-inverse-text": { _light: "white", _dark: "gray.800" },
        "chakra-subtle-bg": { _light: "gray.100", _dark: "gray.700" },
        "chakra-subtle-text": { _light: "gray.600", _dark: "gray.400" },
        "chakra-placeholder-color": { _light: "gray.500", _dark: "whiteAlpha.400" }
      }
    };
    var styles = {
      global: {
        body: {
          fontFamily: "body",
          color: "chakra-body-text",
          bg: "chakra-body-bg",
          transitionProperty: "background-color",
          transitionDuration: "normal",
          lineHeight: "base"
        },
        "*::placeholder": {
          color: "chakra-placeholder-color"
        },
        "*, *::before, &::after": {
          borderColor: "chakra-border-color"
        }
      }
    };
    var import_shared_utils = require_dist3();
    var requiredChakraThemeKeys = [
      "borders",
      "breakpoints",
      "colors",
      "components",
      "config",
      "direction",
      "fonts",
      "fontSizes",
      "fontWeights",
      "letterSpacings",
      "lineHeights",
      "radii",
      "shadows",
      "sizes",
      "space",
      "styles",
      "transition",
      "zIndices"
    ];
    function isChakraTheme(unit) {
      if (!(0, import_shared_utils.isObject)(unit)) {
        return false;
      }
      return requiredChakraThemeKeys.every(
        (propertyName) => Object.prototype.hasOwnProperty.call(unit, propertyName)
      );
    }
    var direction = "ltr";
    var config = {
      useSystemColorMode: false,
      initialColorMode: "light",
      cssVarPrefix: "chakra"
    };
    var theme = {
      semanticTokens,
      direction,
      ...foundations,
      components,
      styles,
      config
    };
    var src_default = theme;
    var baseTheme = {
      semanticTokens,
      direction,
      components: {},
      ...foundations,
      styles,
      config
    };
  }
});

// ../../node_modules/@chakra-ui/theme-utils/dist/index.js
var require_dist11 = __commonJS({
  "../../node_modules/@chakra-ui/theme-utils/dist/index.js"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      extendBaseTheme: () => extendBaseTheme,
      extendTheme: () => extendTheme,
      mergeThemeOverride: () => mergeThemeOverride,
      withDefaultColorScheme: () => withDefaultColorScheme,
      withDefaultProps: () => withDefaultProps,
      withDefaultSize: () => withDefaultSize,
      withDefaultVariant: () => withDefaultVariant
    });
    module.exports = __toCommonJS2(src_exports);
    var import_theme = require_dist10();
    var import_lodash = __toESM(require_lodash());
    function isFunction(value) {
      return typeof value === "function";
    }
    function pipe(...fns) {
      return (v) => fns.reduce((a, b) => b(a), v);
    }
    var createExtendTheme = (theme2) => {
      return function extendTheme2(...extensions) {
        let overrides = [...extensions];
        let activeTheme = extensions[extensions.length - 1];
        if ((0, import_theme.isChakraTheme)(activeTheme) && overrides.length > 1) {
          overrides = overrides.slice(0, overrides.length - 1);
        } else {
          activeTheme = theme2;
        }
        return pipe(
          ...overrides.map(
            (extension) => (prevTheme) => isFunction(extension) ? extension(prevTheme) : mergeThemeOverride(prevTheme, extension)
          )
        )(activeTheme);
      };
    };
    var extendTheme = createExtendTheme(import_theme.theme);
    var extendBaseTheme = createExtendTheme(import_theme.baseTheme);
    function mergeThemeOverride(...overrides) {
      return (0, import_lodash.default)({}, ...overrides, mergeThemeCustomizer);
    }
    function mergeThemeCustomizer(source, override, key, object) {
      if ((isFunction(source) || isFunction(override)) && Object.prototype.hasOwnProperty.call(object, key)) {
        return (...args) => {
          const sourceValue = isFunction(source) ? source(...args) : source;
          const overrideValue = isFunction(override) ? override(...args) : override;
          return (0, import_lodash.default)({}, sourceValue, overrideValue, mergeThemeCustomizer);
        };
      }
      return void 0;
    }
    var import_shared_utils = require_dist3();
    function withDefaultColorScheme({
      colorScheme,
      components
    }) {
      return (theme2) => {
        let names = Object.keys(theme2.components || {});
        if (Array.isArray(components)) {
          names = components;
        } else if ((0, import_shared_utils.isObject)(components)) {
          names = Object.keys(components);
        }
        return mergeThemeOverride(theme2, {
          components: Object.fromEntries(
            names.map((componentName) => {
              const withColorScheme = {
                defaultProps: {
                  colorScheme
                }
              };
              return [componentName, withColorScheme];
            })
          )
        });
      };
    }
    var import_shared_utils2 = require_dist3();
    function withDefaultSize({
      size,
      components
    }) {
      return (theme2) => {
        let names = Object.keys(theme2.components || {});
        if (Array.isArray(components)) {
          names = components;
        } else if ((0, import_shared_utils2.isObject)(components)) {
          names = Object.keys(components);
        }
        return mergeThemeOverride(theme2, {
          components: Object.fromEntries(
            names.map((componentName) => {
              const withSize = {
                defaultProps: {
                  size
                }
              };
              return [componentName, withSize];
            })
          )
        });
      };
    }
    var import_shared_utils3 = require_dist3();
    function withDefaultVariant({
      variant,
      components
    }) {
      return (theme2) => {
        let names = Object.keys(theme2.components || {});
        if (Array.isArray(components)) {
          names = components;
        } else if ((0, import_shared_utils3.isObject)(components)) {
          names = Object.keys(components);
        }
        return mergeThemeOverride(theme2, {
          components: Object.fromEntries(
            names.map((componentName) => {
              const withVariant = {
                defaultProps: {
                  variant
                }
              };
              return [componentName, withVariant];
            })
          )
        });
      };
    }
    function pipe2(...fns) {
      return (v) => fns.reduce((a, b) => b(a), v);
    }
    function withDefaultProps({
      defaultProps: { colorScheme, variant, size },
      components
    }) {
      const identity = (t) => t;
      const fns = [
        colorScheme ? withDefaultColorScheme({ colorScheme, components }) : identity,
        size ? withDefaultSize({ size, components }) : identity,
        variant ? withDefaultVariant({ variant, components }) : identity
      ];
      return (theme2) => mergeThemeOverride(pipe2(...fns)(theme2));
    }
  }
});

// ../../node_modules/@chakra-ui/system/dist/index.js
var require_dist12 = __commonJS({
  "../../node_modules/@chakra-ui/system/dist/index.js"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      CSSVars: () => CSSVars,
      GlobalStyle: () => GlobalStyle,
      StylesProvider: () => StylesProvider,
      ThemeProvider: () => ThemeProvider,
      chakra: () => chakra,
      createStylesContext: () => createStylesContext,
      forwardRef: () => forwardRef,
      getToken: () => getToken,
      keyframes: () => import_react8.keyframes,
      shouldForwardProp: () => shouldForwardProp,
      styled: () => styled,
      toCSSObject: () => toCSSObject,
      useChakra: () => useChakra,
      useComponentStyles__unstable: () => useComponentStyles__unstable,
      useMultiStyleConfig: () => useMultiStyleConfig,
      useStyleConfig: () => useStyleConfig,
      useStyles: () => useStyles,
      useTheme: () => useTheme,
      useToken: () => useToken
    });
    module.exports = __toCommonJS2(src_exports);
    __reExport(src_exports, require_dist2(), module.exports);
    __reExport(src_exports, require_dist4(), module.exports);
    var import_react8 = require_emotion_react_cjs();
    var import_color_mode = require_dist2();
    var import_react = require_emotion_react_cjs();
    var import_react2 = require_react();
    function useTheme() {
      const theme = (0, import_react2.useContext)(
        import_react.ThemeContext
      );
      if (!theme) {
        throw Error(
          "useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`"
        );
      }
      return theme;
    }
    function useChakra() {
      const colorModeResult = (0, import_color_mode.useColorMode)();
      const theme = useTheme();
      return { ...colorModeResult, theme };
    }
    function getBreakpointValue(theme, value, fallback) {
      var _a2, _b;
      if (value == null)
        return value;
      const getValue = (val) => {
        var _a3, _b2;
        return (_b2 = (_a3 = theme.__breakpoints) == null ? void 0 : _a3.asArray) == null ? void 0 : _b2[val];
      };
      return (_b = (_a2 = getValue(value)) != null ? _a2 : getValue(fallback)) != null ? _b : fallback;
    }
    function getTokenValue(theme, value, fallback) {
      var _a2, _b;
      if (value == null)
        return value;
      const getValue = (val) => {
        var _a3, _b2;
        return (_b2 = (_a3 = theme.__cssMap) == null ? void 0 : _a3[val]) == null ? void 0 : _b2.value;
      };
      return (_b = (_a2 = getValue(value)) != null ? _a2 : getValue(fallback)) != null ? _b : fallback;
    }
    function useToken(scale, token, fallback) {
      const theme = useTheme();
      return getToken(scale, token, fallback)(theme);
    }
    function getToken(scale, token, fallback) {
      const _token = Array.isArray(token) ? token : [token];
      const _fallback = Array.isArray(fallback) ? fallback : [fallback];
      return (theme) => {
        const fallbackArr = _fallback.filter(Boolean);
        const result = _token.map((token2, index) => {
          var _a2, _b;
          if (scale === "breakpoints") {
            return getBreakpointValue(theme, token2, (_a2 = fallbackArr[index]) != null ? _a2 : token2);
          }
          const path = `${scale}.${token2}`;
          return getTokenValue(theme, path, (_b = fallbackArr[index]) != null ? _b : token2);
        });
        return Array.isArray(token) ? result : result[0];
      };
    }
    var import_color_mode2 = require_dist2();
    var import_react_utils = require_dist6();
    var import_styled_system = require_dist4();
    var import_utils = require_dist5();
    var import_react3 = require_emotion_react_cjs();
    var import_react4 = require_react();
    var import_jsx_runtime = require_jsx_runtime();
    function ThemeProvider(props) {
      const { cssVarsRoot, theme, children } = props;
      const computedTheme = (0, import_react4.useMemo)(() => (0, import_styled_system.toCSSVar)(theme), [theme]);
      return (0, import_jsx_runtime.jsxs)(import_react3.ThemeProvider, { theme: computedTheme, children: [
        (0, import_jsx_runtime.jsx)(CSSVars, { root: cssVarsRoot }),
        children
      ] });
    }
    function CSSVars({ root = ":host, :root" }) {
      const selector = [root, `[data-theme]`].join(",");
      return (0, import_jsx_runtime.jsx)(import_react3.Global, { styles: (theme) => ({ [selector]: theme.__cssVars }) });
    }
    var [StylesProvider, useStyles] = (0, import_react_utils.createContext)({
      name: "StylesContext",
      errorMessage: "useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` "
    });
    function createStylesContext(componentName) {
      return (0, import_react_utils.createContext)({
        name: `${componentName}StylesContext`,
        errorMessage: `useStyles: "styles" is undefined. Seems you forgot to wrap the components in "<${componentName} />" `
      });
    }
    function GlobalStyle() {
      const { colorMode } = (0, import_color_mode2.useColorMode)();
      return (0, import_jsx_runtime.jsx)(
        import_react3.Global,
        {
          styles: (theme) => {
            const styleObjectOrFn = (0, import_utils.memoizedGet)(theme, "styles.global");
            const globalStyles = (0, import_utils.runIfFn)(styleObjectOrFn, { theme, colorMode });
            if (!globalStyles)
              return void 0;
            const styles = (0, import_styled_system.css)(globalStyles)(theme);
            return styles;
          }
        }
      );
    }
    var import_color_mode3 = require_dist2();
    var import_styled_system3 = require_dist4();
    var import_utils2 = require_dist5();
    var import_object_utils = require_dist7();
    var import_styled = __toESM(require_emotion_styled_cjs());
    var import_react5 = __toESM(require_react());
    var import_styled_system2 = require_dist4();
    var allPropNames = /* @__PURE__ */ new Set([
      ...import_styled_system2.propNames,
      "textStyle",
      "layerStyle",
      "apply",
      "noOfLines",
      "focusBorderColor",
      "errorBorderColor",
      "as",
      "__css",
      "css",
      "sx"
    ]);
    var validHTMLProps = /* @__PURE__ */ new Set([
      "htmlWidth",
      "htmlHeight",
      "htmlSize",
      "htmlTranslate"
    ]);
    function shouldForwardProp(prop) {
      return validHTMLProps.has(prop) || !allPropNames.has(prop);
    }
    var _a;
    var emotion_styled = (_a = import_styled.default.default) != null ? _a : import_styled.default;
    var toCSSObject = ({ baseStyle }) => (props) => {
      const { theme, css: cssProp, __css, sx, ...rest } = props;
      const styleProps = (0, import_utils2.objectFilter)(rest, (_, prop) => (0, import_styled_system3.isStyleProp)(prop));
      const finalBaseStyle = (0, import_utils2.runIfFn)(baseStyle, props);
      const finalStyles = (0, import_object_utils.assignAfter)(
        {},
        __css,
        finalBaseStyle,
        (0, import_utils2.filterUndefined)(styleProps),
        sx
      );
      const computedCSS = (0, import_styled_system3.css)(finalStyles)(props.theme);
      return cssProp ? [computedCSS, cssProp] : computedCSS;
    };
    function styled(component, options) {
      const { baseStyle, ...styledOptions } = options != null ? options : {};
      if (!styledOptions.shouldForwardProp) {
        styledOptions.shouldForwardProp = shouldForwardProp;
      }
      const styleObject = toCSSObject({ baseStyle });
      const Component = emotion_styled(
        component,
        styledOptions
      )(styleObject);
      const chakraComponent = import_react5.default.forwardRef(function ChakraComponent(props, ref) {
        const { colorMode, forced } = (0, import_color_mode3.useColorMode)();
        return import_react5.default.createElement(Component, {
          ref,
          "data-theme": forced ? colorMode : void 0,
          ...props
        });
      });
      return chakraComponent;
    }
    var import_react6 = require_react();
    function forwardRef(component) {
      return (0, import_react6.forwardRef)(component);
    }
    var import_styled_system4 = require_dist4();
    var import_theme_utils = require_dist11();
    var import_utils3 = require_dist5();
    var import_react7 = require_react();
    var import_react_fast_compare = __toESM(require_react_fast_compare());
    function useStyleConfigImpl(themeKey, props = {}) {
      var _a2;
      const { styleConfig: styleConfigProp, ...rest } = props;
      const { theme, colorMode } = useChakra();
      const themeStyleConfig = themeKey ? (0, import_utils3.memoizedGet)(theme, `components.${themeKey}`) : void 0;
      const styleConfig = styleConfigProp || themeStyleConfig;
      const mergedProps = (0, import_utils3.mergeWith)(
        { theme, colorMode },
        (_a2 = styleConfig == null ? void 0 : styleConfig.defaultProps) != null ? _a2 : {},
        (0, import_utils3.filterUndefined)((0, import_utils3.omit)(rest, ["children"]))
      );
      const stylesRef = (0, import_react7.useRef)({});
      if (styleConfig) {
        const getStyles = (0, import_styled_system4.resolveStyleConfig)(styleConfig);
        const styles = getStyles(mergedProps);
        const isStyleEqual = (0, import_react_fast_compare.default)(stylesRef.current, styles);
        if (!isStyleEqual) {
          stylesRef.current = styles;
        }
      }
      return stylesRef.current;
    }
    function useStyleConfig(themeKey, props = {}) {
      return useStyleConfigImpl(themeKey, props);
    }
    function useMultiStyleConfig(themeKey, props = {}) {
      return useStyleConfigImpl(themeKey, props);
    }
    function useComponentStyles__unstable(themeKey, props) {
      var _a2;
      const { baseConfig, ...restProps } = props;
      const { theme } = useChakra();
      const overrides = (_a2 = theme.components) == null ? void 0 : _a2[themeKey];
      const styleConfig = overrides ? (0, import_theme_utils.mergeThemeOverride)(overrides, baseConfig) : baseConfig;
      return useStyleConfigImpl(null, {
        ...restProps,
        styleConfig
      });
    }
    function factory() {
      const cache = /* @__PURE__ */ new Map();
      return new Proxy(styled, {
        apply(target, thisArg, argArray) {
          return styled(...argArray);
        },
        get(_, element) {
          if (!cache.has(element)) {
            cache.set(element, styled(element));
          }
          return cache.get(element);
        }
      });
    }
    var chakra = factory();
  }
});

// ../../node_modules/@chakra-ui/react-context/dist/index.js
var require_dist13 = __commonJS({
  "../../node_modules/@chakra-ui/react-context/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      createContext: () => createContext
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react = require_react();
    function getErrorMessage(hook, provider) {
      return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
    }
    function createContext(options = {}) {
      const {
        name,
        strict = true,
        hookName = "useContext",
        providerName = "Provider",
        errorMessage,
        defaultValue
      } = options;
      const Context = (0, import_react.createContext)(defaultValue);
      Context.displayName = name;
      function useContext() {
        var _a;
        const context = (0, import_react.useContext)(Context);
        if (!context && strict) {
          const error = new Error(
            errorMessage != null ? errorMessage : getErrorMessage(hookName, providerName)
          );
          error.name = "ContextError";
          (_a = Error.captureStackTrace) == null ? void 0 : _a.call(Error, error, useContext);
          throw error;
        }
        return context;
      }
      return [Context.Provider, useContext, Context];
    }
  }
});

// ../../node_modules/@chakra-ui/react-use-merge-refs/dist/index.js
var require_dist14 = __commonJS({
  "../../node_modules/@chakra-ui/react-use-merge-refs/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      assignRef: () => assignRef,
      mergeRefs: () => mergeRefs,
      useMergeRefs: () => useMergeRefs
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react = require_react();
    function assignRef(ref, value) {
      if (ref == null)
        return;
      if (typeof ref === "function") {
        ref(value);
        return;
      }
      try {
        ref.current = value;
      } catch (error) {
        throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);
      }
    }
    function mergeRefs(...refs) {
      return (node) => {
        refs.forEach((ref) => {
          assignRef(ref, node);
        });
      };
    }
    function useMergeRefs(...refs) {
      return (0, import_react.useMemo)(() => mergeRefs(...refs), refs);
    }
  }
});

// ../../node_modules/@chakra-ui/descendant/dist/index.js
var require_dist15 = __commonJS({
  "../../node_modules/@chakra-ui/descendant/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var __publicField = (obj, key, value) => {
      __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    var src_exports = {};
    __export(src_exports, {
      createDescendantContext: () => createDescendantContext,
      default: () => createDescendantContext
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react_context = require_dist13();
    var import_react_use_merge_refs = require_dist14();
    var import_react2 = require_react();
    var import_react = require_react();
    function sortNodes(nodes) {
      return nodes.sort((a, b) => {
        const compare = a.compareDocumentPosition(b);
        if (compare & Node.DOCUMENT_POSITION_FOLLOWING || compare & Node.DOCUMENT_POSITION_CONTAINED_BY) {
          return -1;
        }
        if (compare & Node.DOCUMENT_POSITION_PRECEDING || compare & Node.DOCUMENT_POSITION_CONTAINS) {
          return 1;
        }
        if (compare & Node.DOCUMENT_POSITION_DISCONNECTED || compare & Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC) {
          throw Error("Cannot sort the given nodes.");
        } else {
          return 0;
        }
      });
    }
    var isElement = (el) => typeof el == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
    function getNextIndex(current, max, loop) {
      let next = current + 1;
      if (loop && next >= max)
        next = 0;
      return next;
    }
    function getPrevIndex(current, max, loop) {
      let next = current - 1;
      if (loop && next < 0)
        next = max;
      return next;
    }
    var useSafeLayoutEffect = typeof window !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
    var cast = (value) => value;
    var DescendantsManager = class {
      constructor() {
        __publicField(this, "descendants", /* @__PURE__ */ new Map());
        __publicField(this, "register", (nodeOrOptions) => {
          if (nodeOrOptions == null)
            return;
          if (isElement(nodeOrOptions)) {
            return this.registerNode(nodeOrOptions);
          }
          return (node) => {
            this.registerNode(node, nodeOrOptions);
          };
        });
        __publicField(this, "unregister", (node) => {
          this.descendants.delete(node);
          const sorted = sortNodes(Array.from(this.descendants.keys()));
          this.assignIndex(sorted);
        });
        __publicField(this, "destroy", () => {
          this.descendants.clear();
        });
        __publicField(this, "assignIndex", (descendants) => {
          this.descendants.forEach((descendant) => {
            const index = descendants.indexOf(descendant.node);
            descendant.index = index;
            descendant.node.dataset["index"] = descendant.index.toString();
          });
        });
        __publicField(this, "count", () => this.descendants.size);
        __publicField(this, "enabledCount", () => this.enabledValues().length);
        __publicField(this, "values", () => {
          const values = Array.from(this.descendants.values());
          return values.sort((a, b) => a.index - b.index);
        });
        __publicField(this, "enabledValues", () => {
          return this.values().filter((descendant) => !descendant.disabled);
        });
        __publicField(this, "item", (index) => {
          if (this.count() === 0)
            return void 0;
          return this.values()[index];
        });
        __publicField(this, "enabledItem", (index) => {
          if (this.enabledCount() === 0)
            return void 0;
          return this.enabledValues()[index];
        });
        __publicField(this, "first", () => this.item(0));
        __publicField(this, "firstEnabled", () => this.enabledItem(0));
        __publicField(this, "last", () => this.item(this.descendants.size - 1));
        __publicField(this, "lastEnabled", () => {
          const lastIndex = this.enabledValues().length - 1;
          return this.enabledItem(lastIndex);
        });
        __publicField(this, "indexOf", (node) => {
          var _a, _b;
          if (!node)
            return -1;
          return (_b = (_a = this.descendants.get(node)) == null ? void 0 : _a.index) != null ? _b : -1;
        });
        __publicField(this, "enabledIndexOf", (node) => {
          if (node == null)
            return -1;
          return this.enabledValues().findIndex((i) => i.node.isSameNode(node));
        });
        __publicField(this, "next", (index, loop = true) => {
          const next = getNextIndex(index, this.count(), loop);
          return this.item(next);
        });
        __publicField(this, "nextEnabled", (index, loop = true) => {
          const item = this.item(index);
          if (!item)
            return;
          const enabledIndex = this.enabledIndexOf(item.node);
          const nextEnabledIndex = getNextIndex(
            enabledIndex,
            this.enabledCount(),
            loop
          );
          return this.enabledItem(nextEnabledIndex);
        });
        __publicField(this, "prev", (index, loop = true) => {
          const prev = getPrevIndex(index, this.count() - 1, loop);
          return this.item(prev);
        });
        __publicField(this, "prevEnabled", (index, loop = true) => {
          const item = this.item(index);
          if (!item)
            return;
          const enabledIndex = this.enabledIndexOf(item.node);
          const prevEnabledIndex = getPrevIndex(
            enabledIndex,
            this.enabledCount() - 1,
            loop
          );
          return this.enabledItem(prevEnabledIndex);
        });
        __publicField(this, "registerNode", (node, options) => {
          if (!node || this.descendants.has(node))
            return;
          const keys = Array.from(this.descendants.keys()).concat(node);
          const sorted = sortNodes(keys);
          if (options == null ? void 0 : options.disabled) {
            options.disabled = !!options.disabled;
          }
          const descendant = { node, index: -1, ...options };
          this.descendants.set(node, descendant);
          this.assignIndex(sorted);
        });
      }
    };
    function useDescendants() {
      const descendants = (0, import_react2.useRef)(new DescendantsManager());
      useSafeLayoutEffect(() => {
        return () => descendants.current.destroy();
      });
      return descendants.current;
    }
    var [DescendantsContextProvider, useDescendantsContext] = (0, import_react_context.createContext)({
      name: "DescendantsProvider",
      errorMessage: "useDescendantsContext must be used within DescendantsProvider"
    });
    function useDescendant(options) {
      const descendants = useDescendantsContext();
      const [index, setIndex] = (0, import_react2.useState)(-1);
      const ref = (0, import_react2.useRef)(null);
      useSafeLayoutEffect(() => {
        return () => {
          if (!ref.current)
            return;
          descendants.unregister(ref.current);
        };
      }, []);
      useSafeLayoutEffect(() => {
        if (!ref.current)
          return;
        const dataIndex = Number(ref.current.dataset["index"]);
        if (index != dataIndex && !Number.isNaN(dataIndex)) {
          setIndex(dataIndex);
        }
      });
      const refCallback = options ? cast(descendants.register(options)) : cast(descendants.register);
      return {
        descendants,
        index,
        enabledIndex: descendants.enabledIndexOf(ref.current),
        register: (0, import_react_use_merge_refs.mergeRefs)(refCallback, ref)
      };
    }
    function createDescendantContext() {
      const ContextProvider = cast(DescendantsContextProvider);
      const _useDescendantsContext = () => cast(useDescendantsContext());
      const _useDescendant = (options) => useDescendant(options);
      const _useDescendants = () => useDescendants();
      return [
        ContextProvider,
        _useDescendantsContext,
        _useDescendants,
        _useDescendant
      ];
    }
  }
});

// ../../node_modules/@chakra-ui/react-use-callback-ref/dist/index.js
var require_dist16 = __commonJS({
  "../../node_modules/@chakra-ui/react-use-callback-ref/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      useCallbackRef: () => useCallbackRef
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react = require_react();
    function useCallbackRef(callback, deps = []) {
      const callbackRef = (0, import_react.useRef)(callback);
      (0, import_react.useEffect)(() => {
        callbackRef.current = callback;
      });
      return (0, import_react.useCallback)((...args) => {
        var _a;
        return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
      }, deps);
    }
  }
});

// ../../node_modules/@chakra-ui/react-use-controllable-state/dist/index.js
var require_dist17 = __commonJS({
  "../../node_modules/@chakra-ui/react-use-controllable-state/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      useControllableProp: () => useControllableProp,
      useControllableState: () => useControllableState
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react = require_react();
    var import_react_use_callback_ref = require_dist16();
    function useControllableProp(prop, state) {
      const controlled = typeof prop !== "undefined";
      const value = controlled ? prop : state;
      return (0, import_react.useMemo)(() => [controlled, value], [controlled, value]);
    }
    function useControllableState(props) {
      const {
        value: valueProp,
        defaultValue,
        onChange,
        shouldUpdate = (prev, next) => prev !== next
      } = props;
      const onChangeProp = (0, import_react_use_callback_ref.useCallbackRef)(onChange);
      const shouldUpdateProp = (0, import_react_use_callback_ref.useCallbackRef)(shouldUpdate);
      const [uncontrolledState, setUncontrolledState] = (0, import_react.useState)(defaultValue);
      const controlled = valueProp !== void 0;
      const value = controlled ? valueProp : uncontrolledState;
      const setValue = (0, import_react_use_callback_ref.useCallbackRef)(
        (next) => {
          const setter = next;
          const nextValue = typeof next === "function" ? setter(value) : next;
          if (!shouldUpdateProp(value, nextValue)) {
            return;
          }
          if (!controlled) {
            setUncontrolledState(nextValue);
          }
          onChangeProp(nextValue);
        },
        [controlled, onChangeProp, value, shouldUpdateProp]
      );
      return [value, setValue];
    }
  }
});

// ../../node_modules/@chakra-ui/icon/dist/index.js
var require_dist18 = __commonJS({
  "../../node_modules/@chakra-ui/icon/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Icon: () => Icon,
      createIcon: () => createIcon,
      default: () => icon_default
    });
    module.exports = __toCommonJS2(src_exports);
    var import_system = require_dist12();
    var import_shared_utils = require_dist3();
    var import_jsx_runtime = require_jsx_runtime();
    var fallbackIcon = {
      path: (0, import_jsx_runtime.jsxs)("g", { stroke: "currentColor", strokeWidth: "1.5", children: [
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            strokeLinecap: "round",
            fill: "none",
            d: "M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25"
          }
        ),
        (0, import_jsx_runtime.jsx)(
          "path",
          {
            fill: "currentColor",
            strokeLinecap: "round",
            d: "M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0"
          }
        ),
        (0, import_jsx_runtime.jsx)("circle", { fill: "none", strokeMiterlimit: "10", cx: "12", cy: "12", r: "11.25" })
      ] }),
      viewBox: "0 0 24 24"
    };
    var Icon = (0, import_system.forwardRef)((props, ref) => {
      const {
        as: element,
        viewBox,
        color = "currentColor",
        focusable = false,
        children,
        className,
        __css,
        ...rest
      } = props;
      const _className = (0, import_shared_utils.cx)("chakra-icon", className);
      const customStyles = (0, import_system.useStyleConfig)("Icon", props);
      const styles = {
        w: "1em",
        h: "1em",
        display: "inline-block",
        lineHeight: "1em",
        flexShrink: 0,
        color,
        ...__css,
        ...customStyles
      };
      const shared = {
        ref,
        focusable,
        className: _className,
        __css: styles
      };
      const _viewBox = viewBox != null ? viewBox : fallbackIcon.viewBox;
      if (element && typeof element !== "string") {
        return (0, import_jsx_runtime.jsx)(import_system.chakra.svg, { as: element, ...shared, ...rest });
      }
      const _path = children != null ? children : fallbackIcon.path;
      return (0, import_jsx_runtime.jsx)(import_system.chakra.svg, { verticalAlign: "middle", viewBox: _viewBox, ...shared, ...rest, children: _path });
    });
    Icon.displayName = "Icon";
    var icon_default = Icon;
    var import_system2 = require_dist12();
    var import_react = require_react();
    var import_jsx_runtime2 = require_jsx_runtime();
    function createIcon(options) {
      const {
        viewBox = "0 0 24 24",
        d: pathDefinition,
        displayName,
        defaultProps = {}
      } = options;
      const path = import_react.Children.toArray(options.path);
      const Comp = (0, import_system2.forwardRef)((props, ref) => (0, import_jsx_runtime2.jsx)(Icon, { ref, viewBox, ...defaultProps, ...props, children: path.length ? path : (0, import_jsx_runtime2.jsx)("path", { fill: "currentColor", d: pathDefinition }) }));
      Comp.displayName = displayName;
      return Comp;
    }
  }
});

// ../../node_modules/framer-motion/dist/cjs/index-legacy-1136d0d0.js
var require_index_legacy_1136d0d0 = __commonJS({
  "../../node_modules/framer-motion/dist/cjs/index-legacy-1136d0d0.js"(exports) {
    "use strict";
    var isBrowser = typeof document !== "undefined";
    function isRefObject(ref) {
      return typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
    }
    function isVariantLabel(v) {
      return typeof v === "string" || Array.isArray(v);
    }
    function isAnimationControls(v) {
      return typeof v === "object" && typeof v.start === "function";
    }
    var variantPriorityOrder = [
      "animate",
      "whileInView",
      "whileFocus",
      "whileHover",
      "whileTap",
      "whileDrag",
      "exit"
    ];
    var variantProps = ["initial", ...variantPriorityOrder];
    function isControllingVariants(props) {
      return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
    }
    function isVariantNode(props) {
      return Boolean(isControllingVariants(props) || props.variants);
    }
    var featureProps = {
      animation: [
        "animate",
        "variants",
        "whileHover",
        "whileTap",
        "exit",
        "whileInView",
        "whileFocus",
        "whileDrag"
      ],
      exit: ["exit"],
      drag: ["drag", "dragControls"],
      focus: ["whileFocus"],
      hover: ["whileHover", "onHoverStart", "onHoverEnd"],
      tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
      pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
      inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
      layout: ["layout", "layoutId"]
    };
    var featureDefinitions = {};
    for (const key in featureProps) {
      featureDefinitions[key] = {
        isEnabled: (props) => featureProps[key].some((name) => !!props[name])
      };
    }
    var scaleCorrectors = {};
    function addScaleCorrector(correctors) {
      Object.assign(scaleCorrectors, correctors);
    }
    var transformPropOrder = [
      "transformPerspective",
      "x",
      "y",
      "z",
      "translateX",
      "translateY",
      "translateZ",
      "scale",
      "scaleX",
      "scaleY",
      "rotate",
      "rotateX",
      "rotateY",
      "rotateZ",
      "skew",
      "skewX",
      "skewY"
    ];
    var transformProps = new Set(transformPropOrder);
    function isForcedMotionValue(key, { layout, layoutId }) {
      return transformProps.has(key) || key.startsWith("origin") || (layout || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
    }
    var isMotionValue = (value) => Boolean(value && value.getVelocity);
    var translateAlias = {
      x: "translateX",
      y: "translateY",
      z: "translateZ",
      transformPerspective: "perspective"
    };
    var numTransforms = transformPropOrder.length;
    function buildTransform(transform2, { enableHardwareAcceleration = true, allowTransformNone = true }, transformIsDefault, transformTemplate) {
      let transformString = "";
      for (let i = 0; i < numTransforms; i++) {
        const key = transformPropOrder[i];
        if (transform2[key] !== void 0) {
          const transformName = translateAlias[key] || key;
          transformString += `${transformName}(${transform2[key]}) `;
        }
      }
      if (enableHardwareAcceleration && !transform2.z) {
        transformString += "translateZ(0)";
      }
      transformString = transformString.trim();
      if (transformTemplate) {
        transformString = transformTemplate(transform2, transformIsDefault ? "" : transformString);
      } else if (allowTransformNone && transformIsDefault) {
        transformString = "none";
      }
      return transformString;
    }
    var checkStringStartsWith = (token) => (key) => typeof key === "string" && key.startsWith(token);
    var isCSSVariableName = checkStringStartsWith("--");
    var isCSSVariableToken = checkStringStartsWith("var(--");
    var cssVariableRegex = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g;
    var getValueAsType = (value, type) => {
      return type && typeof value === "number" ? type.transform(value) : value;
    };
    var clamp = (min, max, v) => Math.min(Math.max(v, min), max);
    var number = {
      test: (v) => typeof v === "number",
      parse: parseFloat,
      transform: (v) => v
    };
    var alpha = {
      ...number,
      transform: (v) => clamp(0, 1, v)
    };
    var scale = {
      ...number,
      default: 1
    };
    var sanitize = (v) => Math.round(v * 1e5) / 1e5;
    var floatRegex = /(-)?([\d]*\.?[\d])+/g;
    var colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi;
    var singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
    function isString(v) {
      return typeof v === "string";
    }
    var createUnitType = (unit) => ({
      test: (v) => isString(v) && v.endsWith(unit) && v.split(" ").length === 1,
      parse: parseFloat,
      transform: (v) => `${v}${unit}`
    });
    var degrees = createUnitType("deg");
    var percent = createUnitType("%");
    var px = createUnitType("px");
    var vh = createUnitType("vh");
    var vw = createUnitType("vw");
    var progressPercentage = {
      ...percent,
      parse: (v) => percent.parse(v) / 100,
      transform: (v) => percent.transform(v * 100)
    };
    var int = {
      ...number,
      transform: Math.round
    };
    var numberValueTypes = {
      borderWidth: px,
      borderTopWidth: px,
      borderRightWidth: px,
      borderBottomWidth: px,
      borderLeftWidth: px,
      borderRadius: px,
      radius: px,
      borderTopLeftRadius: px,
      borderTopRightRadius: px,
      borderBottomRightRadius: px,
      borderBottomLeftRadius: px,
      width: px,
      maxWidth: px,
      height: px,
      maxHeight: px,
      size: px,
      top: px,
      right: px,
      bottom: px,
      left: px,
      padding: px,
      paddingTop: px,
      paddingRight: px,
      paddingBottom: px,
      paddingLeft: px,
      margin: px,
      marginTop: px,
      marginRight: px,
      marginBottom: px,
      marginLeft: px,
      rotate: degrees,
      rotateX: degrees,
      rotateY: degrees,
      rotateZ: degrees,
      scale,
      scaleX: scale,
      scaleY: scale,
      scaleZ: scale,
      skew: degrees,
      skewX: degrees,
      skewY: degrees,
      distance: px,
      translateX: px,
      translateY: px,
      translateZ: px,
      x: px,
      y: px,
      z: px,
      perspective: px,
      transformPerspective: px,
      opacity: alpha,
      originX: progressPercentage,
      originY: progressPercentage,
      originZ: px,
      zIndex: int,
      fillOpacity: alpha,
      strokeOpacity: alpha,
      numOctaves: int
    };
    function buildHTMLStyles(state, latestValues, options, transformTemplate) {
      const { style, vars, transform: transform2, transformOrigin } = state;
      let hasTransform2 = false;
      let hasTransformOrigin = false;
      let transformIsNone = true;
      for (const key in latestValues) {
        const value = latestValues[key];
        if (isCSSVariableName(key)) {
          vars[key] = value;
          continue;
        }
        const valueType = numberValueTypes[key];
        const valueAsType = getValueAsType(value, valueType);
        if (transformProps.has(key)) {
          hasTransform2 = true;
          transform2[key] = valueAsType;
          if (!transformIsNone)
            continue;
          if (value !== (valueType.default || 0))
            transformIsNone = false;
        } else if (key.startsWith("origin")) {
          hasTransformOrigin = true;
          transformOrigin[key] = valueAsType;
        } else {
          style[key] = valueAsType;
        }
      }
      if (!latestValues.transform) {
        if (hasTransform2 || transformTemplate) {
          style.transform = buildTransform(state.transform, options, transformIsNone, transformTemplate);
        } else if (style.transform) {
          style.transform = "none";
        }
      }
      if (hasTransformOrigin) {
        const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
        style.transformOrigin = `${originX} ${originY} ${originZ}`;
      }
    }
    function calcOrigin(origin, offset, size) {
      return typeof origin === "string" ? origin : px.transform(offset + size * origin);
    }
    function calcSVGTransformOrigin(dimensions, originX, originY) {
      const pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);
      const pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
      return `${pxOriginX} ${pxOriginY}`;
    }
    var dashKeys = {
      offset: "stroke-dashoffset",
      array: "stroke-dasharray"
    };
    var camelKeys = {
      offset: "strokeDashoffset",
      array: "strokeDasharray"
    };
    function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {
      attrs.pathLength = 1;
      const keys2 = useDashCase ? dashKeys : camelKeys;
      attrs[keys2.offset] = px.transform(-offset);
      const pathLength = px.transform(length);
      const pathSpacing = px.transform(spacing);
      attrs[keys2.array] = `${pathLength} ${pathSpacing}`;
    }
    function buildSVGAttrs(state, {
      attrX,
      attrY,
      attrScale,
      originX,
      originY,
      pathLength,
      pathSpacing = 1,
      pathOffset = 0,
      ...latest
    }, options, isSVGTag2, transformTemplate) {
      buildHTMLStyles(state, latest, options, transformTemplate);
      if (isSVGTag2) {
        if (state.style.viewBox) {
          state.attrs.viewBox = state.style.viewBox;
        }
        return;
      }
      state.attrs = state.style;
      state.style = {};
      const { attrs, style, dimensions } = state;
      if (attrs.transform) {
        if (dimensions)
          style.transform = attrs.transform;
        delete attrs.transform;
      }
      if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
      }
      if (attrX !== void 0)
        attrs.x = attrX;
      if (attrY !== void 0)
        attrs.y = attrY;
      if (attrScale !== void 0)
        attrs.scale = attrScale;
      if (pathLength !== void 0) {
        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
      }
    }
    var isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
    var camelToDash = (str) => str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
    function renderHTML(element, { style, vars }, styleProp, projection) {
      Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
      for (const key in vars) {
        element.style.setProperty(key, vars[key]);
      }
    }
    var camelCaseAttributes = /* @__PURE__ */ new Set([
      "baseFrequency",
      "diffuseConstant",
      "kernelMatrix",
      "kernelUnitLength",
      "keySplines",
      "keyTimes",
      "limitingConeAngle",
      "markerHeight",
      "markerWidth",
      "numOctaves",
      "targetX",
      "targetY",
      "surfaceScale",
      "specularConstant",
      "specularExponent",
      "stdDeviation",
      "tableValues",
      "viewBox",
      "gradientTransform",
      "pathLength",
      "startOffset",
      "textLength",
      "lengthAdjust"
    ]);
    function renderSVG(element, renderState, _styleProp, projection) {
      renderHTML(element, renderState, void 0, projection);
      for (const key in renderState.attrs) {
        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
      }
    }
    function scrapeMotionValuesFromProps$1(props, prevProps) {
      const { style } = props;
      const newValues = {};
      for (const key in style) {
        if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props)) {
          newValues[key] = style[key];
        }
      }
      return newValues;
    }
    function scrapeMotionValuesFromProps(props, prevProps) {
      const newValues = scrapeMotionValuesFromProps$1(props, prevProps);
      for (const key in props) {
        if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
          const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
          newValues[targetKey] = props[key];
        }
      }
      return newValues;
    }
    function resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {}) {
      if (typeof definition === "function") {
        definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
      }
      if (typeof definition === "string") {
        definition = props.variants && props.variants[definition];
      }
      if (typeof definition === "function") {
        definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
      }
      return definition;
    }
    var isKeyframesTarget = (v) => {
      return Array.isArray(v);
    };
    var isCustomValue = (v) => {
      return Boolean(v && typeof v === "object" && v.mix && v.toValue);
    };
    var resolveFinalValueInKeyframes = (v) => {
      return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
    };
    var combineFunctions = (a, b) => (v) => b(a(v));
    var pipe = (...transformers) => transformers.reduce(combineFunctions);
    function createRenderStep(runNextFrame2) {
      let toRun = [];
      let toRunNextFrame = [];
      let numToRun = 0;
      let isProcessing = false;
      let flushNextFrame = false;
      const toKeepAlive = /* @__PURE__ */ new WeakSet();
      const step = {
        schedule: (callback, keepAlive = false, immediate = false) => {
          const addToCurrentFrame = immediate && isProcessing;
          const buffer = addToCurrentFrame ? toRun : toRunNextFrame;
          if (keepAlive)
            toKeepAlive.add(callback);
          if (buffer.indexOf(callback) === -1) {
            buffer.push(callback);
            if (addToCurrentFrame && isProcessing)
              numToRun = toRun.length;
          }
          return callback;
        },
        cancel: (callback) => {
          const index = toRunNextFrame.indexOf(callback);
          if (index !== -1)
            toRunNextFrame.splice(index, 1);
          toKeepAlive.delete(callback);
        },
        process: (frameData2) => {
          if (isProcessing) {
            flushNextFrame = true;
            return;
          }
          isProcessing = true;
          [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
          toRunNextFrame.length = 0;
          numToRun = toRun.length;
          if (numToRun) {
            for (let i = 0; i < numToRun; i++) {
              const callback = toRun[i];
              callback(frameData2);
              if (toKeepAlive.has(callback)) {
                step.schedule(callback);
                runNextFrame2();
              }
            }
          }
          isProcessing = false;
          if (flushNextFrame) {
            flushNextFrame = false;
            step.process(frameData2);
          }
        }
      };
      return step;
    }
    var frameData = {
      delta: 0,
      timestamp: 0,
      isProcessing: false
    };
    var maxElapsed$1 = 40;
    var useDefaultElapsed = true;
    var runNextFrame = false;
    var stepsOrder = [
      "read",
      "update",
      "preRender",
      "render",
      "postRender"
    ];
    var steps = stepsOrder.reduce((acc, key) => {
      acc[key] = createRenderStep(() => runNextFrame = true);
      return acc;
    }, {});
    var processStep = (stepId) => steps[stepId].process(frameData);
    var processFrame = (timestamp) => {
      runNextFrame = false;
      frameData.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - frameData.timestamp, maxElapsed$1), 1);
      frameData.timestamp = timestamp;
      frameData.isProcessing = true;
      stepsOrder.forEach(processStep);
      frameData.isProcessing = false;
      if (runNextFrame) {
        useDefaultElapsed = false;
        requestAnimationFrame(processFrame);
      }
    };
    var startLoop = () => {
      runNextFrame = true;
      useDefaultElapsed = true;
      if (!frameData.isProcessing)
        requestAnimationFrame(processFrame);
    };
    var frame = stepsOrder.reduce((acc, key) => {
      const step = steps[key];
      acc[key] = (process2, keepAlive = false, immediate = false) => {
        if (!runNextFrame)
          startLoop();
        return step.schedule(process2, keepAlive, immediate);
      };
      return acc;
    }, {});
    function cancelFrame(process2) {
      stepsOrder.forEach((key) => steps[key].cancel(process2));
    }
    var noop = (any) => any;
    function getCurrent(visualElement) {
      const current = {};
      visualElement.values.forEach((value, key) => current[key] = value.get());
      return current;
    }
    function getVelocity(visualElement) {
      const velocity = {};
      visualElement.values.forEach((value, key) => velocity[key] = value.getVelocity());
      return velocity;
    }
    function resolveVariant(visualElement, definition, custom) {
      const props = visualElement.getProps();
      return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity(visualElement));
    }
    var optimizedAppearDataId = "framerAppearId";
    var optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
    exports.warning = noop;
    exports.invariant = noop;
    if (true) {
      exports.warning = (check, message) => {
        if (!check && typeof console !== "undefined") {
          console.warn(message);
        }
      };
      exports.invariant = (check, message) => {
        if (!check) {
          throw new Error(message);
        }
      };
    }
    var secondsToMilliseconds = (seconds) => seconds * 1e3;
    var millisecondsToSeconds = (milliseconds) => milliseconds / 1e3;
    var instantAnimationState = {
      current: false
    };
    var isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";
    function isWaapiSupportedEasing(easing) {
      return Boolean(!easing || typeof easing === "string" && supportedWaapiEasing[easing] || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
    }
    var cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;
    var supportedWaapiEasing = {
      linear: "linear",
      ease: "ease",
      easeIn: "ease-in",
      easeOut: "ease-out",
      easeInOut: "ease-in-out",
      circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
      circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
      backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
      backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
    };
    function mapEasingToNativeEasing(easing) {
      if (!easing)
        return void 0;
      return isBezierDefinition(easing) ? cubicBezierAsString(easing) : Array.isArray(easing) ? easing.map(mapEasingToNativeEasing) : supportedWaapiEasing[easing];
    }
    function animateStyle(element, valueName, keyframes3, { delay: delay2 = 0, duration, repeat = 0, repeatType = "loop", ease: ease2, times } = {}) {
      const keyframeOptions = { [valueName]: keyframes3 };
      if (times)
        keyframeOptions.offset = times;
      const easing = mapEasingToNativeEasing(ease2);
      if (Array.isArray(easing))
        keyframeOptions.easing = easing;
      return element.animate(keyframeOptions, {
        delay: delay2,
        duration,
        easing: !Array.isArray(easing) ? easing : "linear",
        fill: "both",
        iterations: repeat + 1,
        direction: repeatType === "reverse" ? "alternate" : "normal"
      });
    }
    var featureTests = {
      waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate")
    };
    var results = {};
    var supports = {};
    for (const key in featureTests) {
      supports[key] = () => {
        if (results[key] === void 0)
          results[key] = featureTests[key]();
        return results[key];
      };
    }
    function getFinalKeyframe(keyframes3, { repeat, repeatType = "loop" }) {
      const index = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : keyframes3.length - 1;
      return keyframes3[index];
    }
    var calcBezier = (t, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1) * t;
    var subdivisionPrecision = 1e-7;
    var subdivisionMaxIterations = 12;
    function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
      let currentX;
      let currentT;
      let i = 0;
      do {
        currentT = lowerBound + (upperBound - lowerBound) / 2;
        currentX = calcBezier(currentT, mX1, mX2) - x;
        if (currentX > 0) {
          upperBound = currentT;
        } else {
          lowerBound = currentT;
        }
      } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
      return currentT;
    }
    function cubicBezier(mX1, mY1, mX2, mY2) {
      if (mX1 === mY1 && mX2 === mY2)
        return noop;
      const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
      return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
    }
    var easeIn = cubicBezier(0.42, 0, 1, 1);
    var easeOut = cubicBezier(0, 0, 0.58, 1);
    var easeInOut = cubicBezier(0.42, 0, 0.58, 1);
    var isEasingArray = (ease2) => {
      return Array.isArray(ease2) && typeof ease2[0] !== "number";
    };
    var mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
    var reverseEasing = (easing) => (p) => 1 - easing(1 - p);
    var circIn = (p) => 1 - Math.sin(Math.acos(p));
    var circOut = reverseEasing(circIn);
    var circInOut = mirrorEasing(circOut);
    var backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);
    var backIn = reverseEasing(backOut);
    var backInOut = mirrorEasing(backIn);
    var anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
    var easingLookup = {
      linear: noop,
      easeIn,
      easeInOut,
      easeOut,
      circIn,
      circInOut,
      circOut,
      backIn,
      backInOut,
      backOut,
      anticipate
    };
    var easingDefinitionToFunction = (definition) => {
      if (Array.isArray(definition)) {
        exports.invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
        const [x1, y1, x2, y2] = definition;
        return cubicBezier(x1, y1, x2, y2);
      } else if (typeof definition === "string") {
        exports.invariant(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`);
        return easingLookup[definition];
      }
      return definition;
    };
    var isColorString = (type, testProp) => (v) => {
      return Boolean(isString(v) && singleColorRegex.test(v) && v.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v, testProp));
    };
    var splitColor = (aName, bName, cName) => (v) => {
      if (!isString(v))
        return v;
      const [a, b, c, alpha2] = v.match(floatRegex);
      return {
        [aName]: parseFloat(a),
        [bName]: parseFloat(b),
        [cName]: parseFloat(c),
        alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
      };
    };
    var clampRgbUnit = (v) => clamp(0, 255, v);
    var rgbUnit = {
      ...number,
      transform: (v) => Math.round(clampRgbUnit(v))
    };
    var rgba = {
      test: isColorString("rgb", "red"),
      parse: splitColor("red", "green", "blue"),
      transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
    };
    function parseHex(v) {
      let r = "";
      let g = "";
      let b = "";
      let a = "";
      if (v.length > 5) {
        r = v.substring(1, 3);
        g = v.substring(3, 5);
        b = v.substring(5, 7);
        a = v.substring(7, 9);
      } else {
        r = v.substring(1, 2);
        g = v.substring(2, 3);
        b = v.substring(3, 4);
        a = v.substring(4, 5);
        r += r;
        g += g;
        b += b;
        a += a;
      }
      return {
        red: parseInt(r, 16),
        green: parseInt(g, 16),
        blue: parseInt(b, 16),
        alpha: a ? parseInt(a, 16) / 255 : 1
      };
    }
    var hex = {
      test: isColorString("#"),
      parse: parseHex,
      transform: rgba.transform
    };
    var hsla = {
      test: isColorString("hsl", "hue"),
      parse: splitColor("hue", "saturation", "lightness"),
      transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
        return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
      }
    };
    var color = {
      test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),
      parse: (v) => {
        if (rgba.test(v)) {
          return rgba.parse(v);
        } else if (hsla.test(v)) {
          return hsla.parse(v);
        } else {
          return hex.parse(v);
        }
      },
      transform: (v) => {
        return isString(v) ? v : v.hasOwnProperty("red") ? rgba.transform(v) : hsla.transform(v);
      }
    };
    var mix = (from, to, progress2) => -progress2 * from + progress2 * to + from;
    function hueToRgb(p, q, t) {
      if (t < 0)
        t += 1;
      if (t > 1)
        t -= 1;
      if (t < 1 / 6)
        return p + (q - p) * 6 * t;
      if (t < 1 / 2)
        return q;
      if (t < 2 / 3)
        return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    }
    function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
      hue /= 360;
      saturation /= 100;
      lightness /= 100;
      let red = 0;
      let green = 0;
      let blue = 0;
      if (!saturation) {
        red = green = blue = lightness;
      } else {
        const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
        const p = 2 * lightness - q;
        red = hueToRgb(p, q, hue + 1 / 3);
        green = hueToRgb(p, q, hue);
        blue = hueToRgb(p, q, hue - 1 / 3);
      }
      return {
        red: Math.round(red * 255),
        green: Math.round(green * 255),
        blue: Math.round(blue * 255),
        alpha: alpha2
      };
    }
    var mixLinearColor = (from, to, v) => {
      const fromExpo = from * from;
      return Math.sqrt(Math.max(0, v * (to * to - fromExpo) + fromExpo));
    };
    var colorTypes = [hex, rgba, hsla];
    var getColorType = (v) => colorTypes.find((type) => type.test(v));
    function asRGBA(color2) {
      const type = getColorType(color2);
      exports.invariant(Boolean(type), `'${color2}' is not an animatable color. Use the equivalent color code instead.`);
      let model = type.parse(color2);
      if (type === hsla) {
        model = hslaToRgba(model);
      }
      return model;
    }
    var mixColor = (from, to) => {
      const fromRGBA = asRGBA(from);
      const toRGBA = asRGBA(to);
      const blended = { ...fromRGBA };
      return (v) => {
        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
        blended.alpha = mix(fromRGBA.alpha, toRGBA.alpha, v);
        return rgba.transform(blended);
      };
    };
    function test(v) {
      var _a, _b;
      return isNaN(v) && isString(v) && (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;
    }
    var cssVarTokeniser = {
      regex: cssVariableRegex,
      countKey: "Vars",
      token: "${v}",
      parse: noop
    };
    var colorTokeniser = {
      regex: colorRegex,
      countKey: "Colors",
      token: "${c}",
      parse: color.parse
    };
    var numberTokeniser = {
      regex: floatRegex,
      countKey: "Numbers",
      token: "${n}",
      parse: number.parse
    };
    function tokenise(info, { regex, countKey, token, parse }) {
      const matches = info.tokenised.match(regex);
      if (!matches)
        return;
      info["num" + countKey] = matches.length;
      info.tokenised = info.tokenised.replace(regex, token);
      info.values.push(...matches.map(parse));
    }
    function analyseComplexValue(value) {
      const originalValue = value.toString();
      const info = {
        value: originalValue,
        tokenised: originalValue,
        values: [],
        numVars: 0,
        numColors: 0,
        numNumbers: 0
      };
      if (info.value.includes("var(--"))
        tokenise(info, cssVarTokeniser);
      tokenise(info, colorTokeniser);
      tokenise(info, numberTokeniser);
      return info;
    }
    function parseComplexValue(v) {
      return analyseComplexValue(v).values;
    }
    function createTransformer(source) {
      const { values, numColors, numVars, tokenised } = analyseComplexValue(source);
      const numValues = values.length;
      return (v) => {
        let output = tokenised;
        for (let i = 0; i < numValues; i++) {
          if (i < numVars) {
            output = output.replace(cssVarTokeniser.token, v[i]);
          } else if (i < numVars + numColors) {
            output = output.replace(colorTokeniser.token, color.transform(v[i]));
          } else {
            output = output.replace(numberTokeniser.token, sanitize(v[i]));
          }
        }
        return output;
      };
    }
    var convertNumbersToZero = (v) => typeof v === "number" ? 0 : v;
    function getAnimatableNone$1(v) {
      const parsed = parseComplexValue(v);
      const transformer = createTransformer(v);
      return transformer(parsed.map(convertNumbersToZero));
    }
    var complex = {
      test,
      parse: parseComplexValue,
      createTransformer,
      getAnimatableNone: getAnimatableNone$1
    };
    var mixImmediate = (origin, target) => (p) => `${p > 0 ? target : origin}`;
    function getMixer$1(origin, target) {
      if (typeof origin === "number") {
        return (v) => mix(origin, target, v);
      } else if (color.test(origin)) {
        return mixColor(origin, target);
      } else {
        return origin.startsWith("var(") ? mixImmediate(origin, target) : mixComplex(origin, target);
      }
    }
    var mixArray = (from, to) => {
      const output = [...from];
      const numValues = output.length;
      const blendValue = from.map((fromThis, i) => getMixer$1(fromThis, to[i]));
      return (v) => {
        for (let i = 0; i < numValues; i++) {
          output[i] = blendValue[i](v);
        }
        return output;
      };
    };
    var mixObject = (origin, target) => {
      const output = { ...origin, ...target };
      const blendValue = {};
      for (const key in output) {
        if (origin[key] !== void 0 && target[key] !== void 0) {
          blendValue[key] = getMixer$1(origin[key], target[key]);
        }
      }
      return (v) => {
        for (const key in blendValue) {
          output[key] = blendValue[key](v);
        }
        return output;
      };
    };
    var mixComplex = (origin, target) => {
      const template = complex.createTransformer(target);
      const originStats = analyseComplexValue(origin);
      const targetStats = analyseComplexValue(target);
      const canInterpolate = originStats.numVars === targetStats.numVars && originStats.numColors === targetStats.numColors && originStats.numNumbers >= targetStats.numNumbers;
      if (canInterpolate) {
        return pipe(mixArray(originStats.values, targetStats.values), template);
      } else {
        exports.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
        return mixImmediate(origin, target);
      }
    };
    var progress = (from, to, value) => {
      const toFromDifference = to - from;
      return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
    };
    var mixNumber = (from, to) => (p) => mix(from, to, p);
    function detectMixerFactory(v) {
      if (typeof v === "number") {
        return mixNumber;
      } else if (typeof v === "string") {
        return color.test(v) ? mixColor : mixComplex;
      } else if (Array.isArray(v)) {
        return mixArray;
      } else if (typeof v === "object") {
        return mixObject;
      }
      return mixNumber;
    }
    function createMixers(output, ease2, customMixer) {
      const mixers = [];
      const mixerFactory = customMixer || detectMixerFactory(output[0]);
      const numMixers = output.length - 1;
      for (let i = 0; i < numMixers; i++) {
        let mixer = mixerFactory(output[i], output[i + 1]);
        if (ease2) {
          const easingFunction = Array.isArray(ease2) ? ease2[i] || noop : ease2;
          mixer = pipe(easingFunction, mixer);
        }
        mixers.push(mixer);
      }
      return mixers;
    }
    function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
      const inputLength = input.length;
      exports.invariant(inputLength === output.length, "Both input and output ranges must be the same length");
      if (inputLength === 1)
        return () => output[0];
      if (input[0] > input[inputLength - 1]) {
        input = [...input].reverse();
        output = [...output].reverse();
      }
      const mixers = createMixers(output, ease2, mixer);
      const numMixers = mixers.length;
      const interpolator = (v) => {
        let i = 0;
        if (numMixers > 1) {
          for (; i < input.length - 2; i++) {
            if (v < input[i + 1])
              break;
          }
        }
        const progressInRange = progress(input[i], input[i + 1], v);
        return mixers[i](progressInRange);
      };
      return isClamp ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;
    }
    function fillOffset(offset, remaining) {
      const min = offset[offset.length - 1];
      for (let i = 1; i <= remaining; i++) {
        const offsetProgress = progress(0, remaining, i);
        offset.push(mix(min, 1, offsetProgress));
      }
    }
    function defaultOffset$1(arr) {
      const offset = [0];
      fillOffset(offset, arr.length - 1);
      return offset;
    }
    function convertOffsetToTimes(offset, duration) {
      return offset.map((o) => o * duration);
    }
    function defaultEasing(values, easing) {
      return values.map(() => easing || easeInOut).splice(0, values.length - 1);
    }
    function keyframes2({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
      const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
      const state = {
        done: false,
        value: keyframeValues[0]
      };
      const absoluteTimes = convertOffsetToTimes(
        times && times.length === keyframeValues.length ? times : defaultOffset$1(keyframeValues),
        duration
      );
      const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
        ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
      });
      return {
        calculatedDuration: duration,
        next: (t) => {
          state.value = mapTimeToKeyframe(t);
          state.done = t >= duration;
          return state;
        }
      };
    }
    function velocityPerSecond(velocity, frameDuration) {
      return frameDuration ? velocity * (1e3 / frameDuration) : 0;
    }
    var velocitySampleDuration = 5;
    function calcGeneratorVelocity(resolveValue, t, current) {
      const prevT = Math.max(t - velocitySampleDuration, 0);
      return velocityPerSecond(current - resolveValue(prevT), t - prevT);
    }
    var safeMin = 1e-3;
    var minDuration = 0.01;
    var maxDuration$1 = 10;
    var minDamping = 0.05;
    var maxDamping = 1;
    function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
      let envelope;
      let derivative;
      exports.warning(duration <= secondsToMilliseconds(maxDuration$1), "Spring duration must be 10 seconds or less");
      let dampingRatio = 1 - bounce;
      dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
      duration = clamp(minDuration, maxDuration$1, millisecondsToSeconds(duration));
      if (dampingRatio < 1) {
        envelope = (undampedFreq2) => {
          const exponentialDecay = undampedFreq2 * dampingRatio;
          const delta = exponentialDecay * duration;
          const a = exponentialDecay - velocity;
          const b = calcAngularFreq(undampedFreq2, dampingRatio);
          const c = Math.exp(-delta);
          return safeMin - a / b * c;
        };
        derivative = (undampedFreq2) => {
          const exponentialDecay = undampedFreq2 * dampingRatio;
          const delta = exponentialDecay * duration;
          const d = delta * velocity + velocity;
          const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
          const f = Math.exp(-delta);
          const g = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
          const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
          return factor * ((d - e) * f) / g;
        };
      } else {
        envelope = (undampedFreq2) => {
          const a = Math.exp(-undampedFreq2 * duration);
          const b = (undampedFreq2 - velocity) * duration + 1;
          return -safeMin + a * b;
        };
        derivative = (undampedFreq2) => {
          const a = Math.exp(-undampedFreq2 * duration);
          const b = (velocity - undampedFreq2) * (duration * duration);
          return a * b;
        };
      }
      const initialGuess = 5 / duration;
      const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
      duration = secondsToMilliseconds(duration);
      if (isNaN(undampedFreq)) {
        return {
          stiffness: 100,
          damping: 10,
          duration
        };
      } else {
        const stiffness = Math.pow(undampedFreq, 2) * mass;
        return {
          stiffness,
          damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
          duration
        };
      }
    }
    var rootIterations = 12;
    function approximateRoot(envelope, derivative, initialGuess) {
      let result = initialGuess;
      for (let i = 1; i < rootIterations; i++) {
        result = result - envelope(result) / derivative(result);
      }
      return result;
    }
    function calcAngularFreq(undampedFreq, dampingRatio) {
      return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
    }
    var durationKeys = ["duration", "bounce"];
    var physicsKeys = ["stiffness", "damping", "mass"];
    function isSpringType(options, keys2) {
      return keys2.some((key) => options[key] !== void 0);
    }
    function getSpringOptions(options) {
      let springOptions = {
        velocity: 0,
        stiffness: 100,
        damping: 10,
        mass: 1,
        isResolvedFromDuration: false,
        ...options
      };
      if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
        const derived = findSpring(options);
        springOptions = {
          ...springOptions,
          ...derived,
          velocity: 0,
          mass: 1
        };
        springOptions.isResolvedFromDuration = true;
      }
      return springOptions;
    }
    function spring({ keyframes: keyframes3, restDelta, restSpeed, ...options }) {
      const origin = keyframes3[0];
      const target = keyframes3[keyframes3.length - 1];
      const state = { done: false, value: origin };
      const { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options);
      const initialVelocity = velocity ? -millisecondsToSeconds(velocity) : 0;
      const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
      const initialDelta = target - origin;
      const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
      const isGranularScale = Math.abs(initialDelta) < 5;
      restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
      restDelta || (restDelta = isGranularScale ? 5e-3 : 0.5);
      let resolveSpring;
      if (dampingRatio < 1) {
        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
        resolveSpring = (t) => {
          const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
          return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
        };
      } else if (dampingRatio === 1) {
        resolveSpring = (t) => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
      } else {
        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
        resolveSpring = (t) => {
          const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
          const freqForT = Math.min(dampedAngularFreq * t, 300);
          return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
        };
      }
      return {
        calculatedDuration: isResolvedFromDuration ? duration || null : null,
        next: (t) => {
          const current = resolveSpring(t);
          if (!isResolvedFromDuration) {
            let currentVelocity = initialVelocity;
            if (t !== 0) {
              if (dampingRatio < 1) {
                currentVelocity = calcGeneratorVelocity(resolveSpring, t, current);
              } else {
                currentVelocity = 0;
              }
            }
            const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
            const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
            state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
          } else {
            state.done = t >= duration;
          }
          state.value = state.done ? target : current;
          return state;
        }
      };
    }
    function inertia({ keyframes: keyframes3, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed }) {
      const origin = keyframes3[0];
      const state = {
        done: false,
        value: origin
      };
      const isOutOfBounds = (v) => min !== void 0 && v < min || max !== void 0 && v > max;
      const nearestBoundary = (v) => {
        if (min === void 0)
          return max;
        if (max === void 0)
          return min;
        return Math.abs(min - v) < Math.abs(max - v) ? min : max;
      };
      let amplitude = power * velocity;
      const ideal = origin + amplitude;
      const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
      if (target !== ideal)
        amplitude = target - origin;
      const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);
      const calcLatest = (t) => target + calcDelta(t);
      const applyFriction = (t) => {
        const delta = calcDelta(t);
        const latest = calcLatest(t);
        state.done = Math.abs(delta) <= restDelta;
        state.value = state.done ? target : latest;
      };
      let timeReachedBoundary;
      let spring$1;
      const checkCatchBoundary = (t) => {
        if (!isOutOfBounds(state.value))
          return;
        timeReachedBoundary = t;
        spring$1 = spring({
          keyframes: [state.value, nearestBoundary(state.value)],
          velocity: calcGeneratorVelocity(calcLatest, t, state.value),
          damping: bounceDamping,
          stiffness: bounceStiffness,
          restDelta,
          restSpeed
        });
      };
      checkCatchBoundary(0);
      return {
        calculatedDuration: null,
        next: (t) => {
          let hasUpdatedFrame = false;
          if (!spring$1 && timeReachedBoundary === void 0) {
            hasUpdatedFrame = true;
            applyFriction(t);
            checkCatchBoundary(t);
          }
          if (timeReachedBoundary !== void 0 && t > timeReachedBoundary) {
            return spring$1.next(t - timeReachedBoundary);
          } else {
            !hasUpdatedFrame && applyFriction(t);
            return state;
          }
        }
      };
    }
    var frameloopDriver = (update) => {
      const passTimestamp = ({ timestamp }) => update(timestamp);
      return {
        start: () => frame.update(passTimestamp, true),
        stop: () => cancelFrame(passTimestamp),
        now: () => frameData.isProcessing ? frameData.timestamp : performance.now()
      };
    };
    var maxGeneratorDuration = 2e4;
    function calcGeneratorDuration(generator) {
      let duration = 0;
      const timeStep = 50;
      let state = generator.next(duration);
      while (!state.done && duration < maxGeneratorDuration) {
        duration += timeStep;
        state = generator.next(duration);
      }
      return duration >= maxGeneratorDuration ? Infinity : duration;
    }
    var types = {
      decay: inertia,
      inertia,
      tween: keyframes2,
      keyframes: keyframes2,
      spring
    };
    function animateValue({ autoplay = true, delay: delay2 = 0, driver = frameloopDriver, keyframes: keyframes$1, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", onPlay, onStop, onComplete, onUpdate, ...options }) {
      let speed = 1;
      let hasStopped = false;
      let resolveFinishedPromise;
      let currentFinishedPromise;
      const updateFinishedPromise = () => {
        resolveFinishedPromise && resolveFinishedPromise();
        currentFinishedPromise = new Promise((resolve) => {
          resolveFinishedPromise = resolve;
        });
      };
      updateFinishedPromise();
      let animationDriver;
      const generatorFactory = types[type] || keyframes2;
      let mapNumbersToKeyframes;
      if (generatorFactory !== keyframes2 && typeof keyframes$1[0] !== "number") {
        mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {
          clamp: false
        });
        keyframes$1 = [0, 100];
      }
      const generator = generatorFactory({ ...options, keyframes: keyframes$1 });
      let mirroredGenerator;
      if (repeatType === "mirror") {
        mirroredGenerator = generatorFactory({
          ...options,
          keyframes: [...keyframes$1].reverse(),
          velocity: -(options.velocity || 0)
        });
      }
      let playState = "idle";
      let holdTime = null;
      let startTime = null;
      let cancelTime = null;
      if (generator.calculatedDuration === null && repeat) {
        generator.calculatedDuration = calcGeneratorDuration(generator);
      }
      const { calculatedDuration } = generator;
      let resolvedDuration = Infinity;
      let totalDuration = Infinity;
      if (calculatedDuration !== null) {
        resolvedDuration = calculatedDuration + repeatDelay;
        totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
      }
      let currentTime = 0;
      const tick = (timestamp) => {
        if (startTime === null)
          return;
        if (speed > 0)
          startTime = Math.min(startTime, timestamp);
        if (holdTime !== null) {
          currentTime = holdTime;
        } else {
          currentTime = (timestamp - startTime) * speed;
        }
        const timeWithoutDelay = currentTime - delay2;
        const isInDelayPhase = timeWithoutDelay < 0;
        currentTime = Math.max(timeWithoutDelay, 0);
        if (playState === "finished" && holdTime === null) {
          currentTime = totalDuration;
        }
        let elapsed = currentTime;
        let frameGenerator = generator;
        if (repeat) {
          const progress2 = currentTime / resolvedDuration;
          let currentIteration = Math.floor(progress2);
          let iterationProgress = progress2 % 1;
          if (!iterationProgress && progress2 >= 1) {
            iterationProgress = 1;
          }
          iterationProgress === 1 && currentIteration--;
          currentIteration = Math.min(currentIteration, repeat + 1);
          const iterationIsOdd = Boolean(currentIteration % 2);
          if (iterationIsOdd) {
            if (repeatType === "reverse") {
              iterationProgress = 1 - iterationProgress;
              if (repeatDelay) {
                iterationProgress -= repeatDelay / resolvedDuration;
              }
            } else if (repeatType === "mirror") {
              frameGenerator = mirroredGenerator;
            }
          }
          let p = clamp(0, 1, iterationProgress);
          if (currentTime > totalDuration) {
            p = repeatType === "reverse" && iterationIsOdd ? 1 : 0;
          }
          elapsed = p * resolvedDuration;
        }
        const state = isInDelayPhase ? { done: false, value: keyframes$1[0] } : frameGenerator.next(elapsed);
        if (mapNumbersToKeyframes) {
          state.value = mapNumbersToKeyframes(state.value);
        }
        let { done } = state;
        if (!isInDelayPhase && calculatedDuration !== null) {
          done = currentTime >= totalDuration;
        }
        const isAnimationFinished = holdTime === null && (playState === "finished" || playState === "running" && done || speed < 0 && currentTime <= 0);
        if (onUpdate) {
          onUpdate(state.value);
        }
        if (isAnimationFinished) {
          finish();
        }
        return state;
      };
      const stopAnimationDriver = () => {
        animationDriver && animationDriver.stop();
        animationDriver = void 0;
      };
      const cancel = () => {
        playState = "idle";
        stopAnimationDriver();
        updateFinishedPromise();
        startTime = cancelTime = null;
      };
      const finish = () => {
        playState = "finished";
        onComplete && onComplete();
        stopAnimationDriver();
        updateFinishedPromise();
      };
      const play = () => {
        if (hasStopped)
          return;
        if (!animationDriver)
          animationDriver = driver(tick);
        const now = animationDriver.now();
        onPlay && onPlay();
        if (holdTime !== null) {
          startTime = now - holdTime;
        } else if (!startTime || playState === "finished") {
          startTime = now;
        }
        cancelTime = startTime;
        holdTime = null;
        playState = "running";
        animationDriver.start();
      };
      if (autoplay) {
        play();
      }
      const controls = {
        then(resolve, reject) {
          return currentFinishedPromise.then(resolve, reject);
        },
        get time() {
          return millisecondsToSeconds(currentTime);
        },
        set time(newTime) {
          newTime = secondsToMilliseconds(newTime);
          currentTime = newTime;
          if (holdTime !== null || !animationDriver || speed === 0) {
            holdTime = newTime;
          } else {
            startTime = animationDriver.now() - newTime / speed;
          }
        },
        get duration() {
          const duration = generator.calculatedDuration === null ? calcGeneratorDuration(generator) : generator.calculatedDuration;
          return millisecondsToSeconds(duration);
        },
        get speed() {
          return speed;
        },
        set speed(newSpeed) {
          if (newSpeed === speed || !animationDriver)
            return;
          speed = newSpeed;
          controls.time = millisecondsToSeconds(currentTime);
        },
        get state() {
          return playState;
        },
        play,
        pause: () => {
          playState = "paused";
          holdTime = currentTime;
        },
        stop: () => {
          hasStopped = true;
          if (playState === "idle")
            return;
          playState = "idle";
          onStop && onStop();
          cancel();
        },
        cancel: () => {
          if (cancelTime !== null)
            tick(cancelTime);
          cancel();
        },
        complete: () => {
          playState = "finished";
        },
        sample: (elapsed) => {
          startTime = 0;
          return tick(elapsed);
        }
      };
      return controls;
    }
    var acceleratedValues = /* @__PURE__ */ new Set([
      "opacity",
      "clipPath",
      "filter",
      "transform",
      "backgroundColor"
    ]);
    var sampleDelta = 10;
    var maxDuration = 2e4;
    var requiresPregeneratedKeyframes = (valueName, options) => options.type === "spring" || valueName === "backgroundColor" || !isWaapiSupportedEasing(options.ease);
    function createAcceleratedAnimation(value, valueName, { onUpdate, onComplete, ...options }) {
      const canAccelerateAnimation = supports.waapi() && acceleratedValues.has(valueName) && !options.repeatDelay && options.repeatType !== "mirror" && options.damping !== 0 && options.type !== "inertia";
      if (!canAccelerateAnimation)
        return false;
      let hasStopped = false;
      let resolveFinishedPromise;
      let currentFinishedPromise;
      const updateFinishedPromise = () => {
        currentFinishedPromise = new Promise((resolve) => {
          resolveFinishedPromise = resolve;
        });
      };
      updateFinishedPromise();
      let { keyframes: keyframes3, duration = 300, ease: ease2, times } = options;
      if (requiresPregeneratedKeyframes(valueName, options)) {
        const sampleAnimation = animateValue({
          ...options,
          repeat: 0,
          delay: 0
        });
        let state = { done: false, value: keyframes3[0] };
        const pregeneratedKeyframes = [];
        let t = 0;
        while (!state.done && t < maxDuration) {
          state = sampleAnimation.sample(t);
          pregeneratedKeyframes.push(state.value);
          t += sampleDelta;
        }
        times = void 0;
        keyframes3 = pregeneratedKeyframes;
        duration = t - sampleDelta;
        ease2 = "linear";
      }
      const animation = animateStyle(value.owner.current, valueName, keyframes3, {
        ...options,
        duration,
        ease: ease2,
        times
      });
      const cancelAnimation = () => animation.cancel();
      const safeCancel = () => {
        frame.update(cancelAnimation);
        resolveFinishedPromise();
        updateFinishedPromise();
      };
      animation.onfinish = () => {
        value.set(getFinalKeyframe(keyframes3, options));
        onComplete && onComplete();
        safeCancel();
      };
      return {
        then(resolve, reject) {
          return currentFinishedPromise.then(resolve, reject);
        },
        get time() {
          return millisecondsToSeconds(animation.currentTime || 0);
        },
        set time(newTime) {
          animation.currentTime = secondsToMilliseconds(newTime);
        },
        get speed() {
          return animation.playbackRate;
        },
        set speed(newSpeed) {
          animation.playbackRate = newSpeed;
        },
        get duration() {
          return millisecondsToSeconds(duration);
        },
        play: () => {
          if (hasStopped)
            return;
          animation.play();
          cancelFrame(cancelAnimation);
        },
        pause: () => animation.pause(),
        stop: () => {
          hasStopped = true;
          if (animation.playState === "idle")
            return;
          const { currentTime } = animation;
          if (currentTime) {
            const sampleAnimation = animateValue({
              ...options,
              autoplay: false
            });
            value.setWithVelocity(sampleAnimation.sample(currentTime - sampleDelta).value, sampleAnimation.sample(currentTime).value, sampleDelta);
          }
          safeCancel();
        },
        complete: () => animation.finish(),
        cancel: safeCancel
      };
    }
    function createInstantAnimation({ keyframes: keyframes3, delay: delay2, onUpdate, onComplete }) {
      const setValue = () => {
        onUpdate && onUpdate(keyframes3[keyframes3.length - 1]);
        onComplete && onComplete();
        return {
          time: 0,
          speed: 1,
          duration: 0,
          play: noop,
          pause: noop,
          stop: noop,
          then: (resolve) => {
            resolve();
            return Promise.resolve();
          },
          cancel: noop,
          complete: noop
        };
      };
      return delay2 ? animateValue({
        keyframes: [0, 1],
        duration: 0,
        delay: delay2,
        onComplete: setValue
      }) : setValue();
    }
    var underDampedSpring = {
      type: "spring",
      stiffness: 500,
      damping: 25,
      restSpeed: 10
    };
    var criticallyDampedSpring = (target) => ({
      type: "spring",
      stiffness: 550,
      damping: target === 0 ? 2 * Math.sqrt(550) : 30,
      restSpeed: 10
    });
    var keyframesTransition = {
      type: "keyframes",
      duration: 0.8
    };
    var ease = {
      type: "keyframes",
      ease: [0.25, 0.1, 0.35, 1],
      duration: 0.3
    };
    var getDefaultTransition = (valueKey, { keyframes: keyframes3 }) => {
      if (keyframes3.length > 2) {
        return keyframesTransition;
      } else if (transformProps.has(valueKey)) {
        return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes3[1]) : underDampedSpring;
      }
      return ease;
    };
    var isAnimatable = (key, value) => {
      if (key === "zIndex")
        return false;
      if (typeof value === "number" || Array.isArray(value))
        return true;
      if (typeof value === "string" && (complex.test(value) || value === "0") && !value.startsWith("url(")) {
        return true;
      }
      return false;
    };
    var maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
    function applyDefaultFilter(v) {
      const [name, value] = v.slice(0, -1).split("(");
      if (name === "drop-shadow")
        return v;
      const [number2] = value.match(floatRegex) || [];
      if (!number2)
        return v;
      const unit = value.replace(number2, "");
      let defaultValue = maxDefaults.has(name) ? 1 : 0;
      if (number2 !== value)
        defaultValue *= 100;
      return name + "(" + defaultValue + unit + ")";
    }
    var functionRegex = /([a-z-]*)\(.*?\)/g;
    var filter = {
      ...complex,
      getAnimatableNone: (v) => {
        const functions = v.match(functionRegex);
        return functions ? functions.map(applyDefaultFilter).join(" ") : v;
      }
    };
    var defaultValueTypes = {
      ...numberValueTypes,
      color,
      backgroundColor: color,
      outlineColor: color,
      fill: color,
      stroke: color,
      borderColor: color,
      borderTopColor: color,
      borderRightColor: color,
      borderBottomColor: color,
      borderLeftColor: color,
      filter,
      WebkitFilter: filter
    };
    var getDefaultValueType = (key) => defaultValueTypes[key];
    function getAnimatableNone(key, value) {
      let defaultValueType = getDefaultValueType(key);
      if (defaultValueType !== filter)
        defaultValueType = complex;
      return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
    }
    var isZeroValueString = (v) => /^0[^.\s]+$/.test(v);
    function isNone(value) {
      if (typeof value === "number") {
        return value === 0;
      } else if (value !== null) {
        return value === "none" || value === "0" || isZeroValueString(value);
      }
    }
    function getKeyframes(value, valueName, target, transition) {
      const isTargetAnimatable = isAnimatable(valueName, target);
      let keyframes3;
      if (Array.isArray(target)) {
        keyframes3 = [...target];
      } else {
        keyframes3 = [null, target];
      }
      const defaultOrigin = transition.from !== void 0 ? transition.from : value.get();
      let animatableTemplateValue = void 0;
      const noneKeyframeIndexes = [];
      for (let i = 0; i < keyframes3.length; i++) {
        if (keyframes3[i] === null) {
          keyframes3[i] = i === 0 ? defaultOrigin : keyframes3[i - 1];
        }
        if (isNone(keyframes3[i])) {
          noneKeyframeIndexes.push(i);
        }
        if (typeof keyframes3[i] === "string" && keyframes3[i] !== "none" && keyframes3[i] !== "0") {
          animatableTemplateValue = keyframes3[i];
        }
      }
      if (isTargetAnimatable && noneKeyframeIndexes.length && animatableTemplateValue) {
        for (let i = 0; i < noneKeyframeIndexes.length; i++) {
          const index = noneKeyframeIndexes[i];
          keyframes3[index] = getAnimatableNone(valueName, animatableTemplateValue);
        }
      }
      return keyframes3;
    }
    function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
      return !!Object.keys(transition).length;
    }
    function getValueTransition$1(transition, key) {
      return transition[key] || transition["default"] || transition;
    }
    var animateMotionValue = (valueName, value, target, transition = {}) => {
      return (onComplete) => {
        const valueTransition = getValueTransition$1(transition, valueName) || {};
        const delay2 = valueTransition.delay || transition.delay || 0;
        let { elapsed = 0 } = transition;
        elapsed = elapsed - secondsToMilliseconds(delay2);
        const keyframes3 = getKeyframes(value, valueName, target, valueTransition);
        const originKeyframe = keyframes3[0];
        const targetKeyframe = keyframes3[keyframes3.length - 1];
        const isOriginAnimatable = isAnimatable(valueName, originKeyframe);
        const isTargetAnimatable = isAnimatable(valueName, targetKeyframe);
        exports.warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${valueName} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
        let options = {
          keyframes: keyframes3,
          velocity: value.getVelocity(),
          ease: "easeOut",
          ...valueTransition,
          delay: -elapsed,
          onUpdate: (v) => {
            value.set(v);
            valueTransition.onUpdate && valueTransition.onUpdate(v);
          },
          onComplete: () => {
            onComplete();
            valueTransition.onComplete && valueTransition.onComplete();
          }
        };
        if (!isTransitionDefined(valueTransition)) {
          options = {
            ...options,
            ...getDefaultTransition(valueName, options)
          };
        }
        if (options.duration) {
          options.duration = secondsToMilliseconds(options.duration);
        }
        if (options.repeatDelay) {
          options.repeatDelay = secondsToMilliseconds(options.repeatDelay);
        }
        if (!isOriginAnimatable || !isTargetAnimatable || instantAnimationState.current || valueTransition.type === false) {
          return createInstantAnimation(options);
        }
        if (value.owner && value.owner.current instanceof HTMLElement && !value.owner.getProps().onUpdate) {
          const acceleratedAnimation = createAcceleratedAnimation(value, valueName, options);
          if (acceleratedAnimation)
            return acceleratedAnimation;
        }
        return animateValue(options);
      };
    };
    function isWillChangeMotionValue(value) {
      return Boolean(isMotionValue(value) && value.add);
    }
    var isNumericalString = (v) => /^\-?\d*\.?\d+$/.test(v);
    function addUniqueItem(arr, item) {
      if (arr.indexOf(item) === -1)
        arr.push(item);
    }
    function removeItem(arr, item) {
      const index = arr.indexOf(item);
      if (index > -1)
        arr.splice(index, 1);
    }
    function moveItem([...arr], fromIndex, toIndex) {
      const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;
      if (startIndex >= 0 && startIndex < arr.length) {
        const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;
        const [item] = arr.splice(fromIndex, 1);
        arr.splice(endIndex, 0, item);
      }
      return arr;
    }
    var SubscriptionManager = class {
      constructor() {
        this.subscriptions = [];
      }
      add(handler) {
        addUniqueItem(this.subscriptions, handler);
        return () => removeItem(this.subscriptions, handler);
      }
      notify(a, b, c) {
        const numSubscriptions = this.subscriptions.length;
        if (!numSubscriptions)
          return;
        if (numSubscriptions === 1) {
          this.subscriptions[0](a, b, c);
        } else {
          for (let i = 0; i < numSubscriptions; i++) {
            const handler = this.subscriptions[i];
            handler && handler(a, b, c);
          }
        }
      }
      getSize() {
        return this.subscriptions.length;
      }
      clear() {
        this.subscriptions.length = 0;
      }
    };
    var warned = /* @__PURE__ */ new Set();
    function warnOnce(condition, message, element) {
      if (condition || warned.has(message))
        return;
      console.warn(message);
      if (element)
        console.warn(element);
      warned.add(message);
    }
    var isFloat = (value) => {
      return !isNaN(parseFloat(value));
    };
    var MotionValue = class {
      constructor(init, options = {}) {
        this.version = "10.12.16";
        this.timeDelta = 0;
        this.lastUpdated = 0;
        this.canTrackVelocity = false;
        this.events = {};
        this.updateAndNotify = (v, render = true) => {
          this.prev = this.current;
          this.current = v;
          const { delta, timestamp } = frameData;
          if (this.lastUpdated !== timestamp) {
            this.timeDelta = delta;
            this.lastUpdated = timestamp;
            frame.postRender(this.scheduleVelocityCheck);
          }
          if (this.prev !== this.current && this.events.change) {
            this.events.change.notify(this.current);
          }
          if (this.events.velocityChange) {
            this.events.velocityChange.notify(this.getVelocity());
          }
          if (render && this.events.renderRequest) {
            this.events.renderRequest.notify(this.current);
          }
        };
        this.scheduleVelocityCheck = () => frame.postRender(this.velocityCheck);
        this.velocityCheck = ({ timestamp }) => {
          if (timestamp !== this.lastUpdated) {
            this.prev = this.current;
            if (this.events.velocityChange) {
              this.events.velocityChange.notify(this.getVelocity());
            }
          }
        };
        this.hasAnimated = false;
        this.prev = this.current = init;
        this.canTrackVelocity = isFloat(this.current);
        this.owner = options.owner;
      }
      onChange(subscription) {
        if (true) {
          warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on("change", callback).`);
        }
        return this.on("change", subscription);
      }
      on(eventName, callback) {
        if (!this.events[eventName]) {
          this.events[eventName] = new SubscriptionManager();
        }
        const unsubscribe = this.events[eventName].add(callback);
        if (eventName === "change") {
          return () => {
            unsubscribe();
            frame.read(() => {
              if (!this.events.change.getSize()) {
                this.stop();
              }
            });
          };
        }
        return unsubscribe;
      }
      clearListeners() {
        for (const eventManagers in this.events) {
          this.events[eventManagers].clear();
        }
      }
      attach(passiveEffect, stopPassiveEffect) {
        this.passiveEffect = passiveEffect;
        this.stopPassiveEffect = stopPassiveEffect;
      }
      set(v, render = true) {
        if (!render || !this.passiveEffect) {
          this.updateAndNotify(v, render);
        } else {
          this.passiveEffect(v, this.updateAndNotify);
        }
      }
      setWithVelocity(prev, current, delta) {
        this.set(current);
        this.prev = prev;
        this.timeDelta = delta;
      }
      jump(v) {
        this.updateAndNotify(v);
        this.prev = v;
        this.stop();
        if (this.stopPassiveEffect)
          this.stopPassiveEffect();
      }
      get() {
        return this.current;
      }
      getPrevious() {
        return this.prev;
      }
      getVelocity() {
        return this.canTrackVelocity ? velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta) : 0;
      }
      start(startAnimation) {
        this.stop();
        return new Promise((resolve) => {
          this.hasAnimated = true;
          this.animation = startAnimation(resolve);
          if (this.events.animationStart) {
            this.events.animationStart.notify();
          }
        }).then(() => {
          if (this.events.animationComplete) {
            this.events.animationComplete.notify();
          }
          this.clearAnimation();
        });
      }
      stop() {
        if (this.animation) {
          this.animation.stop();
          if (this.events.animationCancel) {
            this.events.animationCancel.notify();
          }
        }
        this.clearAnimation();
      }
      isAnimating() {
        return !!this.animation;
      }
      clearAnimation() {
        delete this.animation;
      }
      destroy() {
        this.clearListeners();
        this.stop();
        if (this.stopPassiveEffect) {
          this.stopPassiveEffect();
        }
      }
    };
    function motionValue(init, options) {
      return new MotionValue(init, options);
    }
    var testValueType = (v) => (type) => type.test(v);
    var auto = {
      test: (v) => v === "auto",
      parse: (v) => v
    };
    var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
    var findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));
    var valueTypes = [...dimensionValueTypes, color, complex];
    var findValueType = (v) => valueTypes.find(testValueType(v));
    function setMotionValue(visualElement, key, value) {
      if (visualElement.hasValue(key)) {
        visualElement.getValue(key).set(value);
      } else {
        visualElement.addValue(key, motionValue(value));
      }
    }
    function setTarget(visualElement, definition) {
      const resolved = resolveVariant(visualElement, definition);
      let { transitionEnd = {}, transition = {}, ...target } = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {};
      target = { ...target, ...transitionEnd };
      for (const key in target) {
        const value = resolveFinalValueInKeyframes(target[key]);
        setMotionValue(visualElement, key, value);
      }
    }
    function setVariants(visualElement, variantLabels) {
      const reversedLabels = [...variantLabels].reverse();
      reversedLabels.forEach((key) => {
        const variant = visualElement.getVariant(key);
        variant && setTarget(visualElement, variant);
        if (visualElement.variantChildren) {
          visualElement.variantChildren.forEach((child) => {
            setVariants(child, variantLabels);
          });
        }
      });
    }
    function setValues(visualElement, definition) {
      if (Array.isArray(definition)) {
        return setVariants(visualElement, definition);
      } else if (typeof definition === "string") {
        return setVariants(visualElement, [definition]);
      } else {
        setTarget(visualElement, definition);
      }
    }
    function checkTargetForNewValues(visualElement, target, origin) {
      var _a, _b;
      const newValueKeys = Object.keys(target).filter((key) => !visualElement.hasValue(key));
      const numNewValues = newValueKeys.length;
      if (!numNewValues)
        return;
      for (let i = 0; i < numNewValues; i++) {
        const key = newValueKeys[i];
        const targetValue = target[key];
        let value = null;
        if (Array.isArray(targetValue)) {
          value = targetValue[0];
        }
        if (value === null) {
          value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];
        }
        if (value === void 0 || value === null)
          continue;
        if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
          value = parseFloat(value);
        } else if (!findValueType(value) && complex.test(targetValue)) {
          value = getAnimatableNone(key, targetValue);
        }
        visualElement.addValue(key, motionValue(value, { owner: visualElement }));
        if (origin[key] === void 0) {
          origin[key] = value;
        }
        if (value !== null)
          visualElement.setBaseTarget(key, value);
      }
    }
    function getOriginFromTransition(key, transition) {
      if (!transition)
        return;
      const valueTransition = transition[key] || transition["default"] || transition;
      return valueTransition.from;
    }
    function getOrigin(target, transition, visualElement) {
      const origin = {};
      for (const key in target) {
        const transitionOrigin = getOriginFromTransition(key, transition);
        if (transitionOrigin !== void 0) {
          origin[key] = transitionOrigin;
        } else {
          const value = visualElement.getValue(key);
          if (value) {
            origin[key] = value.get();
          }
        }
      }
      return origin;
    }
    function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
      const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
      needsAnimating[key] = false;
      return shouldBlock;
    }
    function animateTarget(visualElement, definition, { delay: delay2 = 0, transitionOverride, type } = {}) {
      let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = visualElement.makeTargetAnimatable(definition);
      const willChange = visualElement.getValue("willChange");
      if (transitionOverride)
        transition = transitionOverride;
      const animations = [];
      const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
      for (const key in target) {
        const value = visualElement.getValue(key);
        const valueTarget = target[key];
        if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
          continue;
        }
        const valueTransition = { delay: delay2, elapsed: 0, ...transition };
        if (window.HandoffAppearAnimations && !value.hasAnimated) {
          const appearId = visualElement.getProps()[optimizedAppearDataAttribute];
          if (appearId) {
            valueTransition.elapsed = window.HandoffAppearAnimations(appearId, key, value, frame);
          }
        }
        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key) ? { type: false } : valueTransition));
        const animation = value.animation;
        if (isWillChangeMotionValue(willChange)) {
          willChange.add(key);
          animation.then(() => willChange.remove(key));
        }
        animations.push(animation);
      }
      if (transitionEnd) {
        Promise.all(animations).then(() => {
          transitionEnd && setTarget(visualElement, transitionEnd);
        });
      }
      return animations;
    }
    var distance = (a, b) => Math.abs(a - b);
    function distance2D(a, b) {
      const xDelta = distance(a.x, b.x);
      const yDelta = distance(a.y, b.y);
      return Math.sqrt(xDelta ** 2 + yDelta ** 2);
    }
    var createAxisDelta = () => ({
      translate: 0,
      scale: 1,
      origin: 0,
      originPoint: 0
    });
    var createDelta = () => ({
      x: createAxisDelta(),
      y: createAxisDelta()
    });
    var createAxis = () => ({ min: 0, max: 0 });
    var createBox = () => ({
      x: createAxis(),
      y: createAxis()
    });
    function convertBoundingBoxToBox({ top, left, right, bottom }) {
      return {
        x: { min: left, max: right },
        y: { min: top, max: bottom }
      };
    }
    function convertBoxToBoundingBox({ x, y }) {
      return { top: y.min, right: x.max, bottom: y.max, left: x.min };
    }
    function transformBoxPoints(point2, transformPoint) {
      if (!transformPoint)
        return point2;
      const topLeft = transformPoint({ x: point2.left, y: point2.top });
      const bottomRight = transformPoint({ x: point2.right, y: point2.bottom });
      return {
        top: topLeft.y,
        left: topLeft.x,
        bottom: bottomRight.y,
        right: bottomRight.x
      };
    }
    function isIdentityScale(scale2) {
      return scale2 === void 0 || scale2 === 1;
    }
    function hasScale({ scale: scale2, scaleX, scaleY }) {
      return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
    }
    function hasTransform(values) {
      return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY;
    }
    function has2DTranslate(values) {
      return is2DTranslate(values.x) || is2DTranslate(values.y);
    }
    function is2DTranslate(value) {
      return value && value !== "0%";
    }
    function scalePoint(point2, scale2, originPoint) {
      const distanceFromOrigin = point2 - originPoint;
      const scaled = scale2 * distanceFromOrigin;
      return originPoint + scaled;
    }
    function applyPointDelta(point2, translate, scale2, originPoint, boxScale) {
      if (boxScale !== void 0) {
        point2 = scalePoint(point2, boxScale, originPoint);
      }
      return scalePoint(point2, scale2, originPoint) + translate;
    }
    function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
      axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
      axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
    }
    function applyBoxDelta(box, { x, y }) {
      applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
      applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
    }
    function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
      const treeLength = treePath.length;
      if (!treeLength)
        return;
      treeScale.x = treeScale.y = 1;
      let node;
      let delta;
      for (let i = 0; i < treeLength; i++) {
        node = treePath[i];
        delta = node.projectionDelta;
        const instance = node.instance;
        if (instance && instance.style && instance.style.display === "contents") {
          continue;
        }
        if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
          transformBox(box, {
            x: -node.scroll.offset.x,
            y: -node.scroll.offset.y
          });
        }
        if (delta) {
          treeScale.x *= delta.x.scale;
          treeScale.y *= delta.y.scale;
          applyBoxDelta(box, delta);
        }
        if (isSharedTransition && hasTransform(node.latestValues)) {
          transformBox(box, node.latestValues);
        }
      }
      treeScale.x = snapToDefault(treeScale.x);
      treeScale.y = snapToDefault(treeScale.y);
    }
    function snapToDefault(scale2) {
      if (Number.isInteger(scale2))
        return scale2;
      return scale2 > 1.0000000000001 || scale2 < 0.999999999999 ? scale2 : 1;
    }
    function translateAxis(axis, distance2) {
      axis.min = axis.min + distance2;
      axis.max = axis.max + distance2;
    }
    function transformAxis(axis, transforms, [key, scaleKey, originKey]) {
      const axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5;
      const originPoint = mix(axis.min, axis.max, axisOrigin);
      applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);
    }
    var xKeys = ["x", "scaleX", "originX"];
    var yKeys = ["y", "scaleY", "originY"];
    function transformBox(box, transform2) {
      transformAxis(box.x, transform2, xKeys);
      transformAxis(box.y, transform2, yKeys);
    }
    function measureViewportBox(instance, transformPoint) {
      return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));
    }
    function measurePageBox(element, rootProjectionNode, transformPagePoint) {
      const viewportBox = measureViewportBox(element, transformPagePoint);
      const { scroll: scroll2 } = rootProjectionNode;
      if (scroll2) {
        translateAxis(viewportBox.x, scroll2.offset.x);
        translateAxis(viewportBox.y, scroll2.offset.y);
      }
      return viewportBox;
    }
    function delay(callback, timeout) {
      const start = performance.now();
      const checkElapsed = ({ timestamp }) => {
        const elapsed = timestamp - start;
        if (elapsed >= timeout) {
          cancelFrame(checkElapsed);
          callback(elapsed - timeout);
        }
      };
      frame.read(checkElapsed, true);
      return () => cancelFrame(checkElapsed);
    }
    function resolveElements(elements, scope, selectorCache) {
      var _a;
      if (typeof elements === "string") {
        let root = document;
        if (scope) {
          exports.invariant(Boolean(scope.current), "Scope provided, but no element detected.");
          root = scope.current;
        }
        if (selectorCache) {
          (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : selectorCache[elements] = root.querySelectorAll(elements);
          elements = selectorCache[elements];
        } else {
          elements = root.querySelectorAll(elements);
        }
      } else if (elements instanceof Element) {
        elements = [elements];
      }
      return Array.from(elements || []);
    }
    var visualElementStore = /* @__PURE__ */ new WeakMap();
    var GroupPlaybackControls = class {
      constructor(animations) {
        this.animations = animations.filter(Boolean);
      }
      then(onResolve, onReject) {
        return Promise.all(this.animations).then(onResolve).catch(onReject);
      }
      getAll(propName) {
        return this.animations[0][propName];
      }
      setAll(propName, newValue) {
        for (let i = 0; i < this.animations.length; i++) {
          this.animations[i][propName] = newValue;
        }
      }
      get time() {
        return this.getAll("time");
      }
      set time(time) {
        this.setAll("time", time);
      }
      get speed() {
        return this.getAll("speed");
      }
      set speed(speed) {
        this.setAll("speed", speed);
      }
      get duration() {
        let max = 0;
        for (let i = 0; i < this.animations.length; i++) {
          max = Math.max(max, this.animations[i].duration);
        }
        return max;
      }
      runAll(methodName) {
        this.animations.forEach((controls) => controls[methodName]());
      }
      play() {
        this.runAll("play");
      }
      pause() {
        this.runAll("pause");
      }
      stop() {
        this.runAll("stop");
      }
      cancel() {
        this.runAll("cancel");
      }
      complete() {
        this.runAll("complete");
      }
    };
    function isDOMKeyframes(keyframes3) {
      return typeof keyframes3 === "object" && !Array.isArray(keyframes3);
    }
    function isSVGElement(element) {
      return element instanceof SVGElement && element.tagName !== "svg";
    }
    var splitCSSVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
    function parseCSSVariable(current) {
      const match = splitCSSVariableRegex.exec(current);
      if (!match)
        return [,];
      const [, token, fallback] = match;
      return [token, fallback];
    }
    var maxDepth = 4;
    function getVariableValue(current, element, depth = 1) {
      exports.invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
      const [token, fallback] = parseCSSVariable(current);
      if (!token)
        return;
      const resolved = window.getComputedStyle(element).getPropertyValue(token);
      if (resolved) {
        return resolved.trim();
      } else if (isCSSVariableToken(fallback)) {
        return getVariableValue(fallback, element, depth + 1);
      } else {
        return fallback;
      }
    }
    function resolveCSSVariables(visualElement, { ...target }, transitionEnd) {
      const element = visualElement.current;
      if (!(element instanceof Element))
        return { target, transitionEnd };
      if (transitionEnd) {
        transitionEnd = { ...transitionEnd };
      }
      visualElement.values.forEach((value) => {
        const current = value.get();
        if (!isCSSVariableToken(current))
          return;
        const resolved = getVariableValue(current, element);
        if (resolved)
          value.set(resolved);
      });
      for (const key in target) {
        const current = target[key];
        if (!isCSSVariableToken(current))
          continue;
        const resolved = getVariableValue(current, element);
        if (!resolved)
          continue;
        target[key] = resolved;
        if (!transitionEnd)
          transitionEnd = {};
        if (transitionEnd[key] === void 0) {
          transitionEnd[key] = current;
        }
      }
      return { target, transitionEnd };
    }
    var positionalKeys = /* @__PURE__ */ new Set([
      "width",
      "height",
      "top",
      "left",
      "right",
      "bottom",
      "x",
      "y",
      "translateX",
      "translateY"
    ]);
    var isPositionalKey = (key) => positionalKeys.has(key);
    var hasPositionalKey = (target) => {
      return Object.keys(target).some(isPositionalKey);
    };
    var isNumOrPxType = (v) => v === number || v === px;
    var getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]);
    var getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform: transform2 }) => {
      if (transform2 === "none" || !transform2)
        return 0;
      const matrix3d = transform2.match(/^matrix3d\((.+)\)$/);
      if (matrix3d) {
        return getPosFromMatrix(matrix3d[1], pos3);
      } else {
        const matrix = transform2.match(/^matrix\((.+)\)$/);
        if (matrix) {
          return getPosFromMatrix(matrix[1], pos2);
        } else {
          return 0;
        }
      }
    };
    var transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
    var nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
    function removeNonTranslationalTransform(visualElement) {
      const removedTransforms = [];
      nonTranslationalTransformKeys.forEach((key) => {
        const value = visualElement.getValue(key);
        if (value !== void 0) {
          removedTransforms.push([key, value.get()]);
          value.set(key.startsWith("scale") ? 1 : 0);
        }
      });
      if (removedTransforms.length)
        visualElement.render();
      return removedTransforms;
    }
    var positionalValues = {
      width: ({ x }, { paddingLeft = "0", paddingRight = "0" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
      height: ({ y }, { paddingTop = "0", paddingBottom = "0" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
      top: (_bbox, { top }) => parseFloat(top),
      left: (_bbox, { left }) => parseFloat(left),
      bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),
      right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),
      x: getTranslateFromMatrix(4, 13),
      y: getTranslateFromMatrix(5, 14)
    };
    var convertChangedValueTypes = (target, visualElement, changedKeys) => {
      const originBbox = visualElement.measureViewportBox();
      const element = visualElement.current;
      const elementComputedStyle = getComputedStyle(element);
      const { display } = elementComputedStyle;
      const origin = {};
      if (display === "none") {
        visualElement.setStaticValue("display", target.display || "block");
      }
      changedKeys.forEach((key) => {
        origin[key] = positionalValues[key](originBbox, elementComputedStyle);
      });
      visualElement.render();
      const targetBbox = visualElement.measureViewportBox();
      changedKeys.forEach((key) => {
        const value = visualElement.getValue(key);
        value && value.jump(origin[key]);
        target[key] = positionalValues[key](targetBbox, elementComputedStyle);
      });
      return target;
    };
    var checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {
      target = { ...target };
      transitionEnd = { ...transitionEnd };
      const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
      let removedTransformValues = [];
      let hasAttemptedToRemoveTransformValues = false;
      const changedValueTypeKeys = [];
      targetPositionalKeys.forEach((key) => {
        const value = visualElement.getValue(key);
        if (!visualElement.hasValue(key))
          return;
        let from = origin[key];
        let fromType = findDimensionValueType(from);
        const to = target[key];
        let toType;
        if (isKeyframesTarget(to)) {
          const numKeyframes = to.length;
          const fromIndex = to[0] === null ? 1 : 0;
          from = to[fromIndex];
          fromType = findDimensionValueType(from);
          for (let i = fromIndex; i < numKeyframes; i++) {
            if (to[i] === null)
              break;
            if (!toType) {
              toType = findDimensionValueType(to[i]);
              exports.invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), "Keyframes must be of the same dimension as the current value");
            } else {
              exports.invariant(findDimensionValueType(to[i]) === toType, "All keyframes must be of the same type");
            }
          }
        } else {
          toType = findDimensionValueType(to);
        }
        if (fromType !== toType) {
          if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
            const current = value.get();
            if (typeof current === "string") {
              value.set(parseFloat(current));
            }
            if (typeof to === "string") {
              target[key] = parseFloat(to);
            } else if (Array.isArray(to) && toType === px) {
              target[key] = to.map(parseFloat);
            }
          } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from === 0 || to === 0)) {
            if (from === 0) {
              value.set(toType.transform(from));
            } else {
              target[key] = fromType.transform(to);
            }
          } else {
            if (!hasAttemptedToRemoveTransformValues) {
              removedTransformValues = removeNonTranslationalTransform(visualElement);
              hasAttemptedToRemoveTransformValues = true;
            }
            changedValueTypeKeys.push(key);
            transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target[key];
            value.jump(to);
          }
        }
      });
      if (changedValueTypeKeys.length) {
        const scrollY = changedValueTypeKeys.indexOf("height") >= 0 ? window.pageYOffset : null;
        const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);
        if (removedTransformValues.length) {
          removedTransformValues.forEach(([key, value]) => {
            visualElement.getValue(key).set(value);
          });
        }
        visualElement.render();
        if (isBrowser && scrollY !== null) {
          window.scrollTo({ top: scrollY });
        }
        return { target: convertedTarget, transitionEnd };
      } else {
        return { target, transitionEnd };
      }
    };
    function unitConversion(visualElement, target, origin, transitionEnd) {
      return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : { target, transitionEnd };
    }
    var parseDomVariant = (visualElement, target, origin, transitionEnd) => {
      const resolved = resolveCSSVariables(visualElement, target, transitionEnd);
      target = resolved.target;
      transitionEnd = resolved.transitionEnd;
      return unitConversion(visualElement, target, origin, transitionEnd);
    };
    var prefersReducedMotion = { current: null };
    var hasReducedMotionListener = { current: false };
    function initPrefersReducedMotion() {
      hasReducedMotionListener.current = true;
      if (!isBrowser)
        return;
      if (window.matchMedia) {
        const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
        const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
        motionMediaQuery.addListener(setReducedMotionPreferences);
        setReducedMotionPreferences();
      } else {
        prefersReducedMotion.current = false;
      }
    }
    function updateMotionValuesFromProps(element, next, prev) {
      const { willChange } = next;
      for (const key in next) {
        const nextValue = next[key];
        const prevValue = prev[key];
        if (isMotionValue(nextValue)) {
          element.addValue(key, nextValue);
          if (isWillChangeMotionValue(willChange)) {
            willChange.add(key);
          }
          if (true) {
            warnOnce(nextValue.version === "10.12.16", `Attempting to mix Framer Motion versions ${nextValue.version} with 10.12.16 may not work as expected.`);
          }
        } else if (isMotionValue(prevValue)) {
          element.addValue(key, motionValue(nextValue, { owner: element }));
          if (isWillChangeMotionValue(willChange)) {
            willChange.remove(key);
          }
        } else if (prevValue !== nextValue) {
          if (element.hasValue(key)) {
            const existingValue = element.getValue(key);
            !existingValue.hasAnimated && existingValue.set(nextValue);
          } else {
            const latestValue = element.getStaticValue(key);
            element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
          }
        }
      }
      for (const key in prev) {
        if (next[key] === void 0)
          element.removeValue(key);
      }
      return next;
    }
    var featureNames = Object.keys(featureDefinitions);
    var numFeatures = featureNames.length;
    var propEventHandlers = [
      "AnimationStart",
      "AnimationComplete",
      "Update",
      "BeforeLayoutMeasure",
      "LayoutMeasure",
      "LayoutAnimationStart",
      "LayoutAnimationComplete"
    ];
    var numVariantProps = variantProps.length;
    var VisualElement = class {
      constructor({ parent, props, presenceContext, reducedMotionConfig, visualState }, options = {}) {
        this.current = null;
        this.children = /* @__PURE__ */ new Set();
        this.isVariantNode = false;
        this.isControllingVariants = false;
        this.shouldReduceMotion = null;
        this.values = /* @__PURE__ */ new Map();
        this.features = {};
        this.valueSubscriptions = /* @__PURE__ */ new Map();
        this.prevMotionValues = {};
        this.events = {};
        this.propEventSubscriptions = {};
        this.notifyUpdate = () => this.notify("Update", this.latestValues);
        this.render = () => {
          if (!this.current)
            return;
          this.triggerBuild();
          this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
        };
        this.scheduleRender = () => frame.render(this.render, false, true);
        const { latestValues, renderState } = visualState;
        this.latestValues = latestValues;
        this.baseTarget = { ...latestValues };
        this.initialValues = props.initial ? { ...latestValues } : {};
        this.renderState = renderState;
        this.parent = parent;
        this.props = props;
        this.presenceContext = presenceContext;
        this.depth = parent ? parent.depth + 1 : 0;
        this.reducedMotionConfig = reducedMotionConfig;
        this.options = options;
        this.isControllingVariants = isControllingVariants(props);
        this.isVariantNode = isVariantNode(props);
        if (this.isVariantNode) {
          this.variantChildren = /* @__PURE__ */ new Set();
        }
        this.manuallyAnimateOnMount = Boolean(parent && parent.current);
        const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {});
        for (const key in initialMotionValues) {
          const value = initialMotionValues[key];
          if (latestValues[key] !== void 0 && isMotionValue(value)) {
            value.set(latestValues[key], false);
            if (isWillChangeMotionValue(willChange)) {
              willChange.add(key);
            }
          }
        }
      }
      scrapeMotionValuesFromProps(_props, _prevProps) {
        return {};
      }
      mount(instance) {
        this.current = instance;
        visualElementStore.set(instance, this);
        if (this.projection && !this.projection.instance) {
          this.projection.mount(instance);
        }
        if (this.parent && this.isVariantNode && !this.isControllingVariants) {
          this.removeFromVariantTree = this.parent.addVariantChild(this);
        }
        this.values.forEach((value, key) => this.bindToMotionValue(key, value));
        if (!hasReducedMotionListener.current) {
          initPrefersReducedMotion();
        }
        this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
        if (true) {
          warnOnce(this.shouldReduceMotion !== true, "You have Reduced Motion enabled on your device. Animations may not appear as expected.");
        }
        if (this.parent)
          this.parent.children.add(this);
        this.update(this.props, this.presenceContext);
      }
      unmount() {
        visualElementStore.delete(this.current);
        this.projection && this.projection.unmount();
        cancelFrame(this.notifyUpdate);
        cancelFrame(this.render);
        this.valueSubscriptions.forEach((remove) => remove());
        this.removeFromVariantTree && this.removeFromVariantTree();
        this.parent && this.parent.children.delete(this);
        for (const key in this.events) {
          this.events[key].clear();
        }
        for (const key in this.features) {
          this.features[key].unmount();
        }
        this.current = null;
      }
      bindToMotionValue(key, value) {
        const valueIsTransform = transformProps.has(key);
        const removeOnChange = value.on("change", (latestValue) => {
          this.latestValues[key] = latestValue;
          this.props.onUpdate && frame.update(this.notifyUpdate, false, true);
          if (valueIsTransform && this.projection) {
            this.projection.isTransformDirty = true;
          }
        });
        const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
        this.valueSubscriptions.set(key, () => {
          removeOnChange();
          removeOnRenderRequest();
        });
      }
      sortNodePosition(other) {
        if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
          return 0;
        }
        return this.sortInstanceNodePosition(this.current, other.current);
      }
      loadFeatures({ children, ...renderedProps }, isStrict, preloadedFeatures, initialLayoutGroupConfig) {
        let ProjectionNodeConstructor;
        let MeasureLayout;
        if (preloadedFeatures && isStrict) {
          const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
          renderedProps.ignoreStrict ? exports.warning(false, strictMessage) : exports.invariant(false, strictMessage);
        }
        for (let i = 0; i < numFeatures; i++) {
          const name = featureNames[i];
          const { isEnabled, Feature: FeatureConstructor, ProjectionNode, MeasureLayout: MeasureLayoutComponent } = featureDefinitions[name];
          if (ProjectionNode)
            ProjectionNodeConstructor = ProjectionNode;
          if (isEnabled(renderedProps)) {
            if (!this.features[name] && FeatureConstructor) {
              this.features[name] = new FeatureConstructor(this);
            }
            if (MeasureLayoutComponent) {
              MeasureLayout = MeasureLayoutComponent;
            }
          }
        }
        if (!this.projection && ProjectionNodeConstructor) {
          this.projection = new ProjectionNodeConstructor(this.latestValues, this.parent && this.parent.projection);
          const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot } = renderedProps;
          this.projection.setOptions({
            layoutId,
            layout,
            alwaysMeasureLayout: Boolean(drag) || dragConstraints && isRefObject(dragConstraints),
            visualElement: this,
            scheduleRender: () => this.scheduleRender(),
            animationType: typeof layout === "string" ? layout : "both",
            initialPromotionConfig: initialLayoutGroupConfig,
            layoutScroll,
            layoutRoot
          });
        }
        return MeasureLayout;
      }
      updateFeatures() {
        for (const key in this.features) {
          const feature = this.features[key];
          if (feature.isMounted) {
            feature.update();
          } else {
            feature.mount();
            feature.isMounted = true;
          }
        }
      }
      triggerBuild() {
        this.build(this.renderState, this.latestValues, this.options, this.props);
      }
      measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
      }
      getStaticValue(key) {
        return this.latestValues[key];
      }
      setStaticValue(key, value) {
        this.latestValues[key] = value;
      }
      makeTargetAnimatable(target, canMutate = true) {
        return this.makeTargetAnimatableFromInstance(target, this.props, canMutate);
      }
      update(props, presenceContext) {
        if (props.transformTemplate || this.props.transformTemplate) {
          this.scheduleRender();
        }
        this.prevProps = this.props;
        this.props = props;
        this.prevPresenceContext = this.presenceContext;
        this.presenceContext = presenceContext;
        for (let i = 0; i < propEventHandlers.length; i++) {
          const key = propEventHandlers[i];
          if (this.propEventSubscriptions[key]) {
            this.propEventSubscriptions[key]();
            delete this.propEventSubscriptions[key];
          }
          const listener = props["on" + key];
          if (listener) {
            this.propEventSubscriptions[key] = this.on(key, listener);
          }
        }
        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps), this.prevMotionValues);
        if (this.handleChildMotionValue) {
          this.handleChildMotionValue();
        }
      }
      getProps() {
        return this.props;
      }
      getVariant(name) {
        return this.props.variants ? this.props.variants[name] : void 0;
      }
      getDefaultTransition() {
        return this.props.transition;
      }
      getTransformPagePoint() {
        return this.props.transformPagePoint;
      }
      getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
      }
      getVariantContext(startAtParent = false) {
        if (startAtParent) {
          return this.parent ? this.parent.getVariantContext() : void 0;
        }
        if (!this.isControllingVariants) {
          const context2 = this.parent ? this.parent.getVariantContext() || {} : {};
          if (this.props.initial !== void 0) {
            context2.initial = this.props.initial;
          }
          return context2;
        }
        const context = {};
        for (let i = 0; i < numVariantProps; i++) {
          const name = variantProps[i];
          const prop = this.props[name];
          if (isVariantLabel(prop) || prop === false) {
            context[name] = prop;
          }
        }
        return context;
      }
      addVariantChild(child) {
        const closestVariantNode = this.getClosestVariantNode();
        if (closestVariantNode) {
          closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
          return () => closestVariantNode.variantChildren.delete(child);
        }
      }
      addValue(key, value) {
        if (value !== this.values.get(key)) {
          this.removeValue(key);
          this.bindToMotionValue(key, value);
        }
        this.values.set(key, value);
        this.latestValues[key] = value.get();
      }
      removeValue(key) {
        this.values.delete(key);
        const unsubscribe = this.valueSubscriptions.get(key);
        if (unsubscribe) {
          unsubscribe();
          this.valueSubscriptions.delete(key);
        }
        delete this.latestValues[key];
        this.removeValueFromRenderState(key, this.renderState);
      }
      hasValue(key) {
        return this.values.has(key);
      }
      getValue(key, defaultValue) {
        if (this.props.values && this.props.values[key]) {
          return this.props.values[key];
        }
        let value = this.values.get(key);
        if (value === void 0 && defaultValue !== void 0) {
          value = motionValue(defaultValue, { owner: this });
          this.addValue(key, value);
        }
        return value;
      }
      readValue(key) {
        return this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.readValueFromInstance(this.current, key, this.options);
      }
      setBaseTarget(key, value) {
        this.baseTarget[key] = value;
      }
      getBaseTarget(key) {
        var _a;
        const { initial } = this.props;
        const valueFromInitial = typeof initial === "string" || typeof initial === "object" ? (_a = resolveVariantFromProps(this.props, initial)) === null || _a === void 0 ? void 0 : _a[key] : void 0;
        if (initial && valueFromInitial !== void 0) {
          return valueFromInitial;
        }
        const target = this.getBaseTargetFromProps(this.props, key);
        if (target !== void 0 && !isMotionValue(target))
          return target;
        return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
      }
      on(eventName, callback) {
        if (!this.events[eventName]) {
          this.events[eventName] = new SubscriptionManager();
        }
        return this.events[eventName].add(callback);
      }
      notify(eventName, ...args) {
        if (this.events[eventName]) {
          this.events[eventName].notify(...args);
        }
      }
    };
    var DOMVisualElement = class extends VisualElement {
      sortInstanceNodePosition(a, b) {
        return a.compareDocumentPosition(b) & 2 ? 1 : -1;
      }
      getBaseTargetFromProps(props, key) {
        return props.style ? props.style[key] : void 0;
      }
      removeValueFromRenderState(key, { vars, style }) {
        delete vars[key];
        delete style[key];
      }
      makeTargetAnimatableFromInstance({ transition, transitionEnd, ...target }, { transformValues }, isMounted) {
        let origin = getOrigin(target, transition || {}, this);
        if (transformValues) {
          if (transitionEnd)
            transitionEnd = transformValues(transitionEnd);
          if (target)
            target = transformValues(target);
          if (origin)
            origin = transformValues(origin);
        }
        if (isMounted) {
          checkTargetForNewValues(this, target, origin);
          const parsed = parseDomVariant(this, target, origin, transitionEnd);
          transitionEnd = parsed.transitionEnd;
          target = parsed.target;
        }
        return {
          transition,
          transitionEnd,
          ...target
        };
      }
    };
    var SVGVisualElement = class extends DOMVisualElement {
      constructor() {
        super(...arguments);
        this.isSVGTag = false;
      }
      getBaseTargetFromProps(props, key) {
        return props[key];
      }
      readValueFromInstance(instance, key) {
        if (transformProps.has(key)) {
          const defaultType = getDefaultValueType(key);
          return defaultType ? defaultType.default || 0 : 0;
        }
        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
        return instance.getAttribute(key);
      }
      measureInstanceViewportBox() {
        return createBox();
      }
      scrapeMotionValuesFromProps(props, prevProps) {
        return scrapeMotionValuesFromProps(props, prevProps);
      }
      build(renderState, latestValues, options, props) {
        buildSVGAttrs(renderState, latestValues, options, this.isSVGTag, props.transformTemplate);
      }
      renderInstance(instance, renderState, styleProp, projection) {
        renderSVG(instance, renderState, styleProp, projection);
      }
      mount(instance) {
        this.isSVGTag = isSVGTag(instance.tagName);
        super.mount(instance);
      }
    };
    function getComputedStyle$1(element) {
      return window.getComputedStyle(element);
    }
    var HTMLVisualElement = class extends DOMVisualElement {
      readValueFromInstance(instance, key) {
        if (transformProps.has(key)) {
          const defaultType = getDefaultValueType(key);
          return defaultType ? defaultType.default || 0 : 0;
        } else {
          const computedStyle = getComputedStyle$1(instance);
          const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
          return typeof value === "string" ? value.trim() : value;
        }
      }
      measureInstanceViewportBox(instance, { transformPagePoint }) {
        return measureViewportBox(instance, transformPagePoint);
      }
      build(renderState, latestValues, options, props) {
        buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);
      }
      scrapeMotionValuesFromProps(props, prevProps) {
        return scrapeMotionValuesFromProps$1(props, prevProps);
      }
      handleChildMotionValue() {
        if (this.childSubscription) {
          this.childSubscription();
          delete this.childSubscription;
        }
        const { children } = this.props;
        if (isMotionValue(children)) {
          this.childSubscription = children.on("change", (latest) => {
            if (this.current)
              this.current.textContent = `${latest}`;
          });
        }
      }
      renderInstance(instance, renderState, styleProp, projection) {
        renderHTML(instance, renderState, styleProp, projection);
      }
    };
    function createVisualElement(element) {
      const options = {
        presenceContext: null,
        props: {},
        visualState: {
          renderState: {
            transform: {},
            transformOrigin: {},
            style: {},
            vars: {},
            attrs: {}
          },
          latestValues: {}
        }
      };
      const node = isSVGElement(element) ? new SVGVisualElement(options, {
        enableHardwareAcceleration: false
      }) : new HTMLVisualElement(options, {
        enableHardwareAcceleration: true
      });
      node.mount(element);
      visualElementStore.set(element, node);
    }
    function animateSingleValue(value, keyframes3, options) {
      const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
      motionValue$1.start(animateMotionValue("", motionValue$1, keyframes3, options));
      return motionValue$1.animation;
    }
    function createGeneratorEasing(options, scale2 = 100) {
      const generator = spring({ keyframes: [0, scale2], ...options });
      const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
      return {
        type: "keyframes",
        ease: (progress2) => generator.next(duration * progress2).value / scale2,
        duration: millisecondsToSeconds(duration)
      };
    }
    function calcNextTime(current, next, prev, labels) {
      var _a;
      if (typeof next === "number") {
        return next;
      } else if (next.startsWith("-") || next.startsWith("+")) {
        return Math.max(0, current + parseFloat(next));
      } else if (next === "<") {
        return prev;
      } else {
        return (_a = labels.get(next)) !== null && _a !== void 0 ? _a : current;
      }
    }
    var wrap = (min, max, v) => {
      const rangeSize = max - min;
      return ((v - min) % rangeSize + rangeSize) % rangeSize + min;
    };
    function getEasingForSegment(easing, i) {
      return isEasingArray(easing) ? easing[wrap(0, easing.length, i)] : easing;
    }
    function eraseKeyframes(sequence, startTime, endTime) {
      for (let i = 0; i < sequence.length; i++) {
        const keyframe = sequence[i];
        if (keyframe.at > startTime && keyframe.at < endTime) {
          removeItem(sequence, keyframe);
          i--;
        }
      }
    }
    function addKeyframes(sequence, keyframes3, easing, offset, startTime, endTime) {
      eraseKeyframes(sequence, startTime, endTime);
      for (let i = 0; i < keyframes3.length; i++) {
        sequence.push({
          value: keyframes3[i],
          at: mix(startTime, endTime, offset[i]),
          easing: getEasingForSegment(easing, i)
        });
      }
    }
    function compareByTime(a, b) {
      if (a.at === b.at) {
        if (a.value === null)
          return 1;
        if (b.value === null)
          return -1;
        return 0;
      } else {
        return a.at - b.at;
      }
    }
    var defaultSegmentEasing = "easeInOut";
    function createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope) {
      const defaultDuration = defaultTransition.duration || 0.3;
      const animationDefinitions = /* @__PURE__ */ new Map();
      const sequences = /* @__PURE__ */ new Map();
      const elementCache = {};
      const timeLabels = /* @__PURE__ */ new Map();
      let prevTime = 0;
      let currentTime = 0;
      let totalDuration = 0;
      for (let i = 0; i < sequence.length; i++) {
        const segment = sequence[i];
        if (typeof segment === "string") {
          timeLabels.set(segment, currentTime);
          continue;
        } else if (!Array.isArray(segment)) {
          timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));
          continue;
        }
        let [subject, keyframes3, transition = {}] = segment;
        if (transition.at !== void 0) {
          currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);
        }
        let maxDuration2 = 0;
        const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numElements = 0) => {
          const valueKeyframesAsList = keyframesAsList(valueKeyframes);
          const { delay: delay2 = 0, times = defaultOffset$1(valueKeyframesAsList), type = "keyframes", ...remainingTransition } = valueTransition;
          let { ease: ease2 = defaultTransition.ease || "easeOut", duration } = valueTransition;
          const calculatedDelay = typeof delay2 === "function" ? delay2(elementIndex, numElements) : delay2;
          const numKeyframes = valueKeyframesAsList.length;
          if (numKeyframes <= 2 && type === "spring") {
            let absoluteDelta = 100;
            if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {
              const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];
              absoluteDelta = Math.abs(delta);
            }
            const springTransition = { ...remainingTransition };
            if (duration !== void 0) {
              springTransition.duration = secondsToMilliseconds(duration);
            }
            const springEasing = createGeneratorEasing(springTransition, absoluteDelta);
            ease2 = springEasing.ease;
            duration = springEasing.duration;
          }
          duration !== null && duration !== void 0 ? duration : duration = defaultDuration;
          const startTime = currentTime + calculatedDelay;
          const targetTime = startTime + duration;
          if (times.length === 1 && times[0] === 0) {
            times[1] = 1;
          }
          const remainder = times.length - valueKeyframesAsList.length;
          remainder > 0 && fillOffset(times, remainder);
          valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null);
          addKeyframes(valueSequence, valueKeyframesAsList, ease2, times, startTime, targetTime);
          maxDuration2 = Math.max(calculatedDelay + duration, maxDuration2);
          totalDuration = Math.max(targetTime, totalDuration);
        };
        if (isMotionValue(subject)) {
          const subjectSequence = getSubjectSequence(subject, sequences);
          resolveValueSequence(keyframes3, transition, getValueSequence("default", subjectSequence));
        } else {
          const elements = resolveElements(subject, scope, elementCache);
          const numElements = elements.length;
          for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {
            keyframes3 = keyframes3;
            transition = transition;
            const element = elements[elementIndex];
            const subjectSequence = getSubjectSequence(element, sequences);
            for (const key in keyframes3) {
              resolveValueSequence(keyframes3[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), elementIndex, numElements);
            }
          }
          prevTime = currentTime;
          currentTime += maxDuration2;
        }
      }
      sequences.forEach((valueSequences, element) => {
        for (const key in valueSequences) {
          const valueSequence = valueSequences[key];
          valueSequence.sort(compareByTime);
          const keyframes3 = [];
          const valueOffset = [];
          const valueEasing = [];
          for (let i = 0; i < valueSequence.length; i++) {
            const { at, value, easing } = valueSequence[i];
            keyframes3.push(value);
            valueOffset.push(progress(0, totalDuration, at));
            valueEasing.push(easing || "easeOut");
          }
          if (valueOffset[0] !== 0) {
            valueOffset.unshift(0);
            keyframes3.unshift(keyframes3[0]);
            valueEasing.unshift(defaultSegmentEasing);
          }
          if (valueOffset[valueOffset.length - 1] !== 1) {
            valueOffset.push(1);
            keyframes3.push(null);
          }
          if (!animationDefinitions.has(element)) {
            animationDefinitions.set(element, {
              keyframes: {},
              transition: {}
            });
          }
          const definition = animationDefinitions.get(element);
          definition.keyframes[key] = keyframes3;
          definition.transition[key] = {
            ...defaultTransition,
            duration: totalDuration,
            ease: valueEasing,
            times: valueOffset,
            ...sequenceTransition
          };
        }
      });
      return animationDefinitions;
    }
    function getSubjectSequence(subject, sequences) {
      !sequences.has(subject) && sequences.set(subject, {});
      return sequences.get(subject);
    }
    function getValueSequence(name, sequences) {
      if (!sequences[name])
        sequences[name] = [];
      return sequences[name];
    }
    function keyframesAsList(keyframes3) {
      return Array.isArray(keyframes3) ? keyframes3 : [keyframes3];
    }
    function getValueTransition(transition, key) {
      return transition[key] ? { ...transition, ...transition[key] } : { ...transition };
    }
    var isNumber = (keyframe) => typeof keyframe === "number";
    var isNumberKeyframesArray = (keyframes3) => keyframes3.every(isNumber);
    function animateElements(elementOrSelector, keyframes3, options, scope) {
      const elements = resolveElements(elementOrSelector, scope);
      const numElements = elements.length;
      exports.invariant(Boolean(numElements), "No valid element provided.");
      const animations = [];
      for (let i = 0; i < numElements; i++) {
        const element = elements[i];
        if (!visualElementStore.has(element)) {
          createVisualElement(element);
        }
        const visualElement = visualElementStore.get(element);
        const transition = { ...options };
        if (typeof transition.delay === "function") {
          transition.delay = transition.delay(i, numElements);
        }
        animations.push(...animateTarget(visualElement, { ...keyframes3, transition }, {}));
      }
      return new GroupPlaybackControls(animations);
    }
    var isSequence = (value) => Array.isArray(value) && Array.isArray(value[0]);
    function animateSequence(sequence, options, scope) {
      const animations = [];
      const animationDefinitions = createAnimationsFromSequence(sequence, options, scope);
      animationDefinitions.forEach(({ keyframes: keyframes3, transition }, subject) => {
        let animation;
        if (isMotionValue(subject)) {
          animation = animateSingleValue(subject, keyframes3.default, transition.default);
        } else {
          animation = animateElements(subject, keyframes3, transition);
        }
        animations.push(animation);
      });
      return new GroupPlaybackControls(animations);
    }
    var createScopedAnimate = (scope) => {
      function scopedAnimate(valueOrElementOrSequence, keyframes3, options) {
        let animation;
        if (isSequence(valueOrElementOrSequence)) {
          animation = animateSequence(valueOrElementOrSequence, keyframes3, scope);
        } else if (isDOMKeyframes(keyframes3)) {
          animation = animateElements(valueOrElementOrSequence, keyframes3, options, scope);
        } else {
          animation = animateSingleValue(valueOrElementOrSequence, keyframes3, options);
        }
        if (scope) {
          scope.animations.push(animation);
        }
        return animation;
      }
      return scopedAnimate;
    };
    var animate = createScopedAnimate();
    var resizeHandlers = /* @__PURE__ */ new WeakMap();
    var observer;
    function getElementSize(target, borderBoxSize) {
      if (borderBoxSize) {
        const { inlineSize, blockSize } = borderBoxSize[0];
        return { width: inlineSize, height: blockSize };
      } else if (target instanceof SVGElement && "getBBox" in target) {
        return target.getBBox();
      } else {
        return {
          width: target.offsetWidth,
          height: target.offsetHeight
        };
      }
    }
    function notifyTarget({ target, contentRect, borderBoxSize }) {
      var _a;
      (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach((handler) => {
        handler({
          target,
          contentSize: contentRect,
          get size() {
            return getElementSize(target, borderBoxSize);
          }
        });
      });
    }
    function notifyAll(entries) {
      entries.forEach(notifyTarget);
    }
    function createResizeObserver() {
      if (typeof ResizeObserver === "undefined")
        return;
      observer = new ResizeObserver(notifyAll);
    }
    function resizeElement(target, handler) {
      if (!observer)
        createResizeObserver();
      const elements = resolveElements(target);
      elements.forEach((element) => {
        let elementHandlers = resizeHandlers.get(element);
        if (!elementHandlers) {
          elementHandlers = /* @__PURE__ */ new Set();
          resizeHandlers.set(element, elementHandlers);
        }
        elementHandlers.add(handler);
        observer === null || observer === void 0 ? void 0 : observer.observe(element);
      });
      return () => {
        elements.forEach((element) => {
          const elementHandlers = resizeHandlers.get(element);
          elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);
          if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {
            observer === null || observer === void 0 ? void 0 : observer.unobserve(element);
          }
        });
      };
    }
    var windowCallbacks = /* @__PURE__ */ new Set();
    var windowResizeHandler;
    function createWindowResizeHandler() {
      windowResizeHandler = () => {
        const size = {
          width: window.innerWidth,
          height: window.innerHeight
        };
        const info = {
          target: window,
          size,
          contentSize: size
        };
        windowCallbacks.forEach((callback) => callback(info));
      };
      window.addEventListener("resize", windowResizeHandler);
    }
    function resizeWindow(callback) {
      windowCallbacks.add(callback);
      if (!windowResizeHandler)
        createWindowResizeHandler();
      return () => {
        windowCallbacks.delete(callback);
        if (!windowCallbacks.size && windowResizeHandler) {
          windowResizeHandler = void 0;
        }
      };
    }
    function resize(a, b) {
      return typeof a === "function" ? resizeWindow(a) : resizeElement(a, b);
    }
    var maxElapsed = 50;
    var createAxisInfo = () => ({
      current: 0,
      offset: [],
      progress: 0,
      scrollLength: 0,
      targetOffset: 0,
      targetLength: 0,
      containerLength: 0,
      velocity: 0
    });
    var createScrollInfo = () => ({
      time: 0,
      x: createAxisInfo(),
      y: createAxisInfo()
    });
    var keys = {
      x: {
        length: "Width",
        position: "Left"
      },
      y: {
        length: "Height",
        position: "Top"
      }
    };
    function updateAxisInfo(element, axisName, info, time) {
      const axis = info[axisName];
      const { length, position } = keys[axisName];
      const prev = axis.current;
      const prevTime = info.time;
      axis.current = element["scroll" + position];
      axis.scrollLength = element["scroll" + length] - element["client" + length];
      axis.offset.length = 0;
      axis.offset[0] = 0;
      axis.offset[1] = axis.scrollLength;
      axis.progress = progress(0, axis.scrollLength, axis.current);
      const elapsed = time - prevTime;
      axis.velocity = elapsed > maxElapsed ? 0 : velocityPerSecond(axis.current - prev, elapsed);
    }
    function updateScrollInfo(element, info, time) {
      updateAxisInfo(element, "x", info, time);
      updateAxisInfo(element, "y", info, time);
      info.time = time;
    }
    function calcInset(element, container) {
      let inset = { x: 0, y: 0 };
      let current = element;
      while (current && current !== container) {
        if (current instanceof HTMLElement) {
          inset.x += current.offsetLeft;
          inset.y += current.offsetTop;
          current = current.offsetParent;
        } else if (current instanceof SVGGraphicsElement && "getBBox" in current) {
          const { top, left } = current.getBBox();
          inset.x += left;
          inset.y += top;
          while (current && current.tagName !== "svg") {
            current = current.parentNode;
          }
        }
      }
      return inset;
    }
    var ScrollOffset = {
      Enter: [
        [0, 1],
        [1, 1]
      ],
      Exit: [
        [0, 0],
        [1, 0]
      ],
      Any: [
        [1, 0],
        [0, 1]
      ],
      All: [
        [0, 0],
        [1, 1]
      ]
    };
    var namedEdges = {
      start: 0,
      center: 0.5,
      end: 1
    };
    function resolveEdge(edge, length, inset = 0) {
      let delta = 0;
      if (namedEdges[edge] !== void 0) {
        edge = namedEdges[edge];
      }
      if (typeof edge === "string") {
        const asNumber = parseFloat(edge);
        if (edge.endsWith("px")) {
          delta = asNumber;
        } else if (edge.endsWith("%")) {
          edge = asNumber / 100;
        } else if (edge.endsWith("vw")) {
          delta = asNumber / 100 * document.documentElement.clientWidth;
        } else if (edge.endsWith("vh")) {
          delta = asNumber / 100 * document.documentElement.clientHeight;
        } else {
          edge = asNumber;
        }
      }
      if (typeof edge === "number") {
        delta = length * edge;
      }
      return inset + delta;
    }
    var defaultOffset = [0, 0];
    function resolveOffset(offset, containerLength, targetLength, targetInset) {
      let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;
      let targetPoint = 0;
      let containerPoint = 0;
      if (typeof offset === "number") {
        offsetDefinition = [offset, offset];
      } else if (typeof offset === "string") {
        offset = offset.trim();
        if (offset.includes(" ")) {
          offsetDefinition = offset.split(" ");
        } else {
          offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];
        }
      }
      targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);
      containerPoint = resolveEdge(offsetDefinition[1], containerLength);
      return targetPoint - containerPoint;
    }
    var point = { x: 0, y: 0 };
    function resolveOffsets(container, info, options) {
      let { offset: offsetDefinition = ScrollOffset.All } = options;
      const { target = container, axis = "y" } = options;
      const lengthLabel = axis === "y" ? "height" : "width";
      const inset = target !== container ? calcInset(target, container) : point;
      const targetSize = target === container ? { width: container.scrollWidth, height: container.scrollHeight } : { width: target.clientWidth, height: target.clientHeight };
      const containerSize = {
        width: container.clientWidth,
        height: container.clientHeight
      };
      info[axis].offset.length = 0;
      let hasChanged = !info[axis].interpolate;
      const numOffsets = offsetDefinition.length;
      for (let i = 0; i < numOffsets; i++) {
        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);
        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {
          hasChanged = true;
        }
        info[axis].offset[i] = offset;
      }
      if (hasChanged) {
        info[axis].interpolate = interpolate(info[axis].offset, defaultOffset$1(offsetDefinition));
        info[axis].interpolatorOffsets = [...info[axis].offset];
      }
      info[axis].progress = info[axis].interpolate(info[axis].current);
    }
    function measure(container, target = container, info) {
      info.x.targetOffset = 0;
      info.y.targetOffset = 0;
      if (target !== container) {
        let node = target;
        while (node && node !== container) {
          info.x.targetOffset += node.offsetLeft;
          info.y.targetOffset += node.offsetTop;
          node = node.offsetParent;
        }
      }
      info.x.targetLength = target === container ? target.scrollWidth : target.clientWidth;
      info.y.targetLength = target === container ? target.scrollHeight : target.clientHeight;
      info.x.containerLength = container.clientWidth;
      info.y.containerLength = container.clientHeight;
    }
    function createOnScrollHandler(element, onScroll, info, options = {}) {
      return {
        measure: () => measure(element, options.target, info),
        update: (time) => {
          updateScrollInfo(element, info, time);
          if (options.offset || options.target) {
            resolveOffsets(element, info, options);
          }
        },
        notify: () => onScroll(info)
      };
    }
    var scrollListeners = /* @__PURE__ */ new WeakMap();
    var resizeListeners = /* @__PURE__ */ new WeakMap();
    var onScrollHandlers = /* @__PURE__ */ new WeakMap();
    var getEventTarget = (element) => element === document.documentElement ? window : element;
    function scroll(onScroll, { container = document.documentElement, ...options } = {}) {
      let containerHandlers = onScrollHandlers.get(container);
      if (!containerHandlers) {
        containerHandlers = /* @__PURE__ */ new Set();
        onScrollHandlers.set(container, containerHandlers);
      }
      const info = createScrollInfo();
      const containerHandler = createOnScrollHandler(container, onScroll, info, options);
      containerHandlers.add(containerHandler);
      if (!scrollListeners.has(container)) {
        const measureAll = () => {
          for (const handler of containerHandlers)
            handler.measure();
        };
        const updateAll = () => {
          for (const handler of containerHandlers) {
            handler.update(frameData.timestamp);
          }
        };
        const notifyAll2 = () => {
          for (const handler of containerHandlers)
            handler.notify();
        };
        const listener2 = () => {
          frame.read(measureAll, false, true);
          frame.update(updateAll, false, true);
          frame.update(notifyAll2, false, true);
        };
        scrollListeners.set(container, listener2);
        const target = getEventTarget(container);
        window.addEventListener("resize", listener2, { passive: true });
        if (container !== document.documentElement) {
          resizeListeners.set(container, resize(container, listener2));
        }
        target.addEventListener("scroll", listener2, { passive: true });
      }
      const listener = scrollListeners.get(container);
      frame.read(listener, false, true);
      return () => {
        var _a;
        cancelFrame(listener);
        const currentHandlers = onScrollHandlers.get(container);
        if (!currentHandlers)
          return;
        currentHandlers.delete(containerHandler);
        if (currentHandlers.size)
          return;
        const scrollListener = scrollListeners.get(container);
        scrollListeners.delete(container);
        if (scrollListener) {
          getEventTarget(container).removeEventListener("scroll", scrollListener);
          (_a = resizeListeners.get(container)) === null || _a === void 0 ? void 0 : _a();
          window.removeEventListener("resize", scrollListener);
        }
      };
    }
    var thresholds = {
      any: 0,
      all: 1
    };
    function inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = "any" } = {}) {
      const elements = resolveElements(elementOrSelector);
      const activeIntersections = /* @__PURE__ */ new WeakMap();
      const onIntersectionChange = (entries) => {
        entries.forEach((entry) => {
          const onEnd = activeIntersections.get(entry.target);
          if (entry.isIntersecting === Boolean(onEnd))
            return;
          if (entry.isIntersecting) {
            const newOnEnd = onStart(entry);
            if (typeof newOnEnd === "function") {
              activeIntersections.set(entry.target, newOnEnd);
            } else {
              observer2.unobserve(entry.target);
            }
          } else if (onEnd) {
            onEnd(entry);
            activeIntersections.delete(entry.target);
          }
        });
      };
      const observer2 = new IntersectionObserver(onIntersectionChange, {
        root,
        rootMargin,
        threshold: typeof amount === "number" ? amount : thresholds[amount]
      });
      elements.forEach((element) => observer2.observe(element));
      return () => observer2.disconnect();
    }
    function getOriginIndex(from, total) {
      if (from === "first") {
        return 0;
      } else {
        const lastIndex = total - 1;
        return from === "last" ? lastIndex : lastIndex / 2;
      }
    }
    function stagger(duration = 0.1, { startDelay = 0, from = 0, ease: ease2 } = {}) {
      return (i, total) => {
        const fromIndex = typeof from === "number" ? from : getOriginIndex(from, total);
        const distance2 = Math.abs(fromIndex - i);
        let delay2 = duration * distance2;
        if (ease2) {
          const maxDelay = total * duration;
          const easingFunction = easingDefinitionToFunction(ease2);
          delay2 = easingFunction(delay2 / maxDelay) * maxDelay;
        }
        return startDelay + delay2;
      };
    }
    var isCustomValueType = (v) => {
      return typeof v === "object" && v.mix;
    };
    var getMixer = (v) => isCustomValueType(v) ? v.mix : void 0;
    function transform(...args) {
      const useImmediate = !Array.isArray(args[0]);
      const argOffset = useImmediate ? 0 : -1;
      const inputValue = args[0 + argOffset];
      const inputRange = args[1 + argOffset];
      const outputRange = args[2 + argOffset];
      const options = args[3 + argOffset];
      const interpolator = interpolate(inputRange, outputRange, {
        mixer: getMixer(outputRange[0]),
        ...options
      });
      return useImmediate ? interpolator(inputValue) : interpolator;
    }
    var sync = frame;
    var cancelSync = stepsOrder.reduce((acc, key) => {
      acc[key] = (process2) => cancelFrame(process2);
      return acc;
    }, {});
    exports.HTMLVisualElement = HTMLVisualElement;
    exports.MotionValue = MotionValue;
    exports.SVGVisualElement = SVGVisualElement;
    exports.SubscriptionManager = SubscriptionManager;
    exports.VisualElement = VisualElement;
    exports.addScaleCorrector = addScaleCorrector;
    exports.addUniqueItem = addUniqueItem;
    exports.animate = animate;
    exports.animateMotionValue = animateMotionValue;
    exports.animateSingleValue = animateSingleValue;
    exports.animateStyle = animateStyle;
    exports.animateTarget = animateTarget;
    exports.animateValue = animateValue;
    exports.anticipate = anticipate;
    exports.applyBoxDelta = applyBoxDelta;
    exports.applyTreeDeltas = applyTreeDeltas;
    exports.backIn = backIn;
    exports.backInOut = backInOut;
    exports.backOut = backOut;
    exports.buildHTMLStyles = buildHTMLStyles;
    exports.buildSVGAttrs = buildSVGAttrs;
    exports.buildTransform = buildTransform;
    exports.camelToDash = camelToDash;
    exports.cancelFrame = cancelFrame;
    exports.cancelSync = cancelSync;
    exports.checkTargetForNewValues = checkTargetForNewValues;
    exports.circIn = circIn;
    exports.circInOut = circInOut;
    exports.circOut = circOut;
    exports.clamp = clamp;
    exports.color = color;
    exports.complex = complex;
    exports.convertBoundingBoxToBox = convertBoundingBoxToBox;
    exports.convertBoxToBoundingBox = convertBoxToBoundingBox;
    exports.createBox = createBox;
    exports.createDelta = createDelta;
    exports.createScopedAnimate = createScopedAnimate;
    exports.cubicBezier = cubicBezier;
    exports.delay = delay;
    exports.distance = distance;
    exports.distance2D = distance2D;
    exports.easeIn = easeIn;
    exports.easeInOut = easeInOut;
    exports.easeOut = easeOut;
    exports.featureDefinitions = featureDefinitions;
    exports.frame = frame;
    exports.frameData = frameData;
    exports.getOrigin = getOrigin;
    exports.getValueTransition = getValueTransition$1;
    exports.has2DTranslate = has2DTranslate;
    exports.hasReducedMotionListener = hasReducedMotionListener;
    exports.hasScale = hasScale;
    exports.hasTransform = hasTransform;
    exports.inView = inView;
    exports.initPrefersReducedMotion = initPrefersReducedMotion;
    exports.instantAnimationState = instantAnimationState;
    exports.interpolate = interpolate;
    exports.isAnimationControls = isAnimationControls;
    exports.isBrowser = isBrowser;
    exports.isCSSVariableName = isCSSVariableName;
    exports.isControllingVariants = isControllingVariants;
    exports.isCustomValue = isCustomValue;
    exports.isForcedMotionValue = isForcedMotionValue;
    exports.isKeyframesTarget = isKeyframesTarget;
    exports.isMotionValue = isMotionValue;
    exports.isRefObject = isRefObject;
    exports.isSVGElement = isSVGElement;
    exports.isSVGTag = isSVGTag;
    exports.isVariantLabel = isVariantLabel;
    exports.isVariantNode = isVariantNode;
    exports.measurePageBox = measurePageBox;
    exports.millisecondsToSeconds = millisecondsToSeconds;
    exports.mirrorEasing = mirrorEasing;
    exports.mix = mix;
    exports.motionValue = motionValue;
    exports.moveItem = moveItem;
    exports.noop = noop;
    exports.optimizedAppearDataAttribute = optimizedAppearDataAttribute;
    exports.optimizedAppearDataId = optimizedAppearDataId;
    exports.percent = percent;
    exports.pipe = pipe;
    exports.prefersReducedMotion = prefersReducedMotion;
    exports.progress = progress;
    exports.px = px;
    exports.removeItem = removeItem;
    exports.renderSVG = renderSVG;
    exports.resolveVariant = resolveVariant;
    exports.resolveVariantFromProps = resolveVariantFromProps;
    exports.reverseEasing = reverseEasing;
    exports.scaleCorrectors = scaleCorrectors;
    exports.scalePoint = scalePoint;
    exports.scrapeMotionValuesFromProps = scrapeMotionValuesFromProps;
    exports.scrapeMotionValuesFromProps$1 = scrapeMotionValuesFromProps$1;
    exports.scroll = scroll;
    exports.secondsToMilliseconds = secondsToMilliseconds;
    exports.setValues = setValues;
    exports.spring = spring;
    exports.stagger = stagger;
    exports.steps = steps;
    exports.stepsOrder = stepsOrder;
    exports.sync = sync;
    exports.transform = transform;
    exports.transformBox = transformBox;
    exports.transformProps = transformProps;
    exports.translateAxis = translateAxis;
    exports.variantPriorityOrder = variantPriorityOrder;
    exports.visualElementStore = visualElementStore;
    exports.warnOnce = warnOnce;
    exports.wrap = wrap;
  }
});

// ../../node_modules/framer-motion/dist/cjs/index.js
var require_cjs = __commonJS({
  "../../node_modules/framer-motion/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    var indexLegacy = require_index_legacy_1136d0d0();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespace(React);
    var React__default = _interopDefaultLegacy(React);
    var MotionConfigContext = React.createContext({
      transformPagePoint: (p) => p,
      isStatic: false,
      reducedMotion: "never"
    });
    var MotionContext = React.createContext({});
    var PresenceContext = React.createContext(null);
    var useIsomorphicLayoutEffect = indexLegacy.isBrowser ? React.useLayoutEffect : React.useEffect;
    var LazyContext = React.createContext({ strict: false });
    function useVisualElement(Component, visualState, props, createVisualElement) {
      const { visualElement: parent } = React.useContext(MotionContext);
      const lazyContext = React.useContext(LazyContext);
      const presenceContext = React.useContext(PresenceContext);
      const reducedMotionConfig = React.useContext(MotionConfigContext).reducedMotion;
      const visualElementRef = React.useRef();
      createVisualElement = createVisualElement || lazyContext.renderer;
      if (!visualElementRef.current && createVisualElement) {
        visualElementRef.current = createVisualElement(Component, {
          visualState,
          parent,
          props,
          presenceContext,
          blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
          reducedMotionConfig
        });
      }
      const visualElement = visualElementRef.current;
      React.useInsertionEffect(() => {
        visualElement && visualElement.update(props, presenceContext);
      });
      useIsomorphicLayoutEffect(() => {
        visualElement && visualElement.render();
      });
      React.useEffect(() => {
        visualElement && visualElement.updateFeatures();
      });
      const useAnimateChangesEffect = window.HandoffAppearAnimations ? useIsomorphicLayoutEffect : React.useEffect;
      useAnimateChangesEffect(() => {
        if (visualElement && visualElement.animationState) {
          visualElement.animationState.animateChanges();
        }
      });
      return visualElement;
    }
    function useMotionRef(visualState, visualElement, externalRef) {
      return React.useCallback(
        (instance) => {
          instance && visualState.mount && visualState.mount(instance);
          if (visualElement) {
            instance ? visualElement.mount(instance) : visualElement.unmount();
          }
          if (externalRef) {
            if (typeof externalRef === "function") {
              externalRef(instance);
            } else if (indexLegacy.isRefObject(externalRef)) {
              externalRef.current = instance;
            }
          }
        },
        [visualElement]
      );
    }
    function getCurrentTreeVariants(props, context) {
      if (indexLegacy.isControllingVariants(props)) {
        const { initial, animate } = props;
        return {
          initial: initial === false || indexLegacy.isVariantLabel(initial) ? initial : void 0,
          animate: indexLegacy.isVariantLabel(animate) ? animate : void 0
        };
      }
      return props.inherit !== false ? context : {};
    }
    function useCreateMotionContext(props) {
      const { initial, animate } = getCurrentTreeVariants(props, React.useContext(MotionContext));
      return React.useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
    }
    function variantLabelsAsDependency(prop) {
      return Array.isArray(prop) ? prop.join(" ") : prop;
    }
    function loadFeatures(features) {
      for (const key in features) {
        indexLegacy.featureDefinitions[key] = {
          ...indexLegacy.featureDefinitions[key],
          ...features[key]
        };
      }
    }
    var LayoutGroupContext = React.createContext({});
    var SwitchLayoutGroupContext = React.createContext({});
    var motionComponentSymbol = Symbol.for("motionComponentSymbol");
    function createMotionComponent({ preloadedFeatures: preloadedFeatures2, createVisualElement, useRender, useVisualState: useVisualState2, Component }) {
      preloadedFeatures2 && loadFeatures(preloadedFeatures2);
      function MotionComponent(props, externalRef) {
        let MeasureLayout2;
        const configAndProps = {
          ...React.useContext(MotionConfigContext),
          ...props,
          layoutId: useLayoutId(props)
        };
        const { isStatic } = configAndProps;
        const context = useCreateMotionContext(props);
        const visualState = useVisualState2(props, isStatic);
        if (!isStatic && indexLegacy.isBrowser) {
          context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement);
          const initialLayoutGroupConfig = React.useContext(SwitchLayoutGroupContext);
          const isStrict = React.useContext(LazyContext).strict;
          if (context.visualElement) {
            MeasureLayout2 = context.visualElement.loadFeatures(
              configAndProps,
              isStrict,
              preloadedFeatures2,
              initialLayoutGroupConfig
            );
          }
        }
        return React__namespace.createElement(
          MotionContext.Provider,
          { value: context },
          MeasureLayout2 && context.visualElement ? React__namespace.createElement(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null,
          useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)
        );
      }
      const ForwardRefComponent = React.forwardRef(MotionComponent);
      ForwardRefComponent[motionComponentSymbol] = Component;
      return ForwardRefComponent;
    }
    function useLayoutId({ layoutId }) {
      const layoutGroupId = React.useContext(LayoutGroupContext).id;
      return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
    }
    function createMotionProxy(createConfig) {
      function custom(Component, customMotionComponentConfig = {}) {
        return createMotionComponent(createConfig(Component, customMotionComponentConfig));
      }
      if (typeof Proxy === "undefined") {
        return custom;
      }
      const componentCache = /* @__PURE__ */ new Map();
      return new Proxy(custom, {
        get: (_target, key) => {
          if (!componentCache.has(key)) {
            componentCache.set(key, custom(key));
          }
          return componentCache.get(key);
        }
      });
    }
    var lowercaseSVGElements = [
      "animate",
      "circle",
      "defs",
      "desc",
      "ellipse",
      "g",
      "image",
      "line",
      "filter",
      "marker",
      "mask",
      "metadata",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "rect",
      "stop",
      "switch",
      "symbol",
      "svg",
      "text",
      "tspan",
      "use",
      "view"
    ];
    function isSVGComponent(Component) {
      if (typeof Component !== "string" || Component.includes("-")) {
        return false;
      } else if (lowercaseSVGElements.indexOf(Component) > -1 || /[A-Z]/.test(Component)) {
        return true;
      }
      return false;
    }
    var createHtmlRenderState = () => ({
      style: {},
      transform: {},
      transformOrigin: {},
      vars: {}
    });
    function copyRawValuesOnly(target, source, props) {
      for (const key in source) {
        if (!indexLegacy.isMotionValue(source[key]) && !indexLegacy.isForcedMotionValue(key, props)) {
          target[key] = source[key];
        }
      }
    }
    function useInitialMotionValues({ transformTemplate }, visualState, isStatic) {
      return React.useMemo(() => {
        const state = createHtmlRenderState();
        indexLegacy.buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);
        return Object.assign({}, state.vars, state.style);
      }, [visualState]);
    }
    function useStyle(props, visualState, isStatic) {
      const styleProp = props.style || {};
      const style = {};
      copyRawValuesOnly(style, styleProp, props);
      Object.assign(style, useInitialMotionValues(props, visualState, isStatic));
      return props.transformValues ? props.transformValues(style) : style;
    }
    function useHTMLProps(props, visualState, isStatic) {
      const htmlProps = {};
      const style = useStyle(props, visualState, isStatic);
      if (props.drag && props.dragListener !== false) {
        htmlProps.draggable = false;
        style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
        style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
      }
      if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
        htmlProps.tabIndex = 0;
      }
      htmlProps.style = style;
      return htmlProps;
    }
    var validMotionProps = /* @__PURE__ */ new Set([
      "animate",
      "exit",
      "variants",
      "initial",
      "style",
      "values",
      "variants",
      "transition",
      "transformTemplate",
      "transformValues",
      "custom",
      "inherit",
      "onLayoutAnimationStart",
      "onLayoutAnimationComplete",
      "onLayoutMeasure",
      "onBeforeLayoutMeasure",
      "onAnimationStart",
      "onAnimationComplete",
      "onUpdate",
      "onDragStart",
      "onDrag",
      "onDragEnd",
      "onMeasureDragConstraints",
      "onDirectionLock",
      "onDragTransitionEnd",
      "_dragX",
      "_dragY",
      "onHoverStart",
      "onHoverEnd",
      "onViewportEnter",
      "onViewportLeave",
      "ignoreStrict",
      "viewport"
    ]);
    function isValidMotionProp(key) {
      return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || validMotionProps.has(key);
    }
    var shouldForward = (key) => !isValidMotionProp(key);
    function loadExternalIsValidProp(isValidProp) {
      if (!isValidProp)
        return;
      shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
    }
    try {
      loadExternalIsValidProp((init_is_prop_valid_browser_esm(), __toCommonJS(is_prop_valid_browser_esm_exports)).default);
    } catch (_a) {
    }
    function filterProps(props, isDom, forwardMotionProps) {
      const filteredProps = {};
      for (const key in props) {
        if (key === "values" && typeof props.values === "object")
          continue;
        if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || props["draggable"] && key.startsWith("onDrag")) {
          filteredProps[key] = props[key];
        }
      }
      return filteredProps;
    }
    var createSvgRenderState = () => ({
      ...createHtmlRenderState(),
      attrs: {}
    });
    function useSVGProps(props, visualState, _isStatic, Component) {
      const visualProps = React.useMemo(() => {
        const state = createSvgRenderState();
        indexLegacy.buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, indexLegacy.isSVGTag(Component), props.transformTemplate);
        return {
          ...state.attrs,
          style: { ...state.style }
        };
      }, [visualState]);
      if (props.style) {
        const rawStyles = {};
        copyRawValuesOnly(rawStyles, props.style, props);
        visualProps.style = { ...rawStyles, ...visualProps.style };
      }
      return visualProps;
    }
    function createUseRender(forwardMotionProps = false) {
      const useRender = (Component, props, ref, { latestValues }, isStatic) => {
        const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
        const visualProps = useVisualProps(props, latestValues, isStatic, Component);
        const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
        const elementProps = {
          ...filteredProps,
          ...visualProps,
          ref
        };
        const { children } = props;
        const renderedChildren = React.useMemo(() => indexLegacy.isMotionValue(children) ? children.get() : children, [children]);
        return React.createElement(Component, {
          ...elementProps,
          children: renderedChildren
        });
      };
      return useRender;
    }
    function useConstant(init) {
      const ref = React.useRef(null);
      if (ref.current === null) {
        ref.current = init();
      }
      return ref.current;
    }
    function resolveMotionValue(value) {
      const unwrappedValue = indexLegacy.isMotionValue(value) ? value.get() : value;
      return indexLegacy.isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
    }
    function makeState({ scrapeMotionValuesFromProps, createRenderState, onMount }, props, context, presenceContext) {
      const state = {
        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),
        renderState: createRenderState()
      };
      if (onMount) {
        state.mount = (instance) => onMount(props, instance, state);
      }
      return state;
    }
    var makeUseVisualState = (config) => (props, isStatic) => {
      const context = React.useContext(MotionContext);
      const presenceContext = React.useContext(PresenceContext);
      const make = () => makeState(config, props, context, presenceContext);
      return isStatic ? make() : useConstant(make);
    };
    function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
      const values = {};
      const motionValues = scrapeMotionValues(props, {});
      for (const key in motionValues) {
        values[key] = resolveMotionValue(motionValues[key]);
      }
      let { initial, animate } = props;
      const isControllingVariants = indexLegacy.isControllingVariants(props);
      const isVariantNode = indexLegacy.isVariantNode(props);
      if (context && isVariantNode && !isControllingVariants && props.inherit !== false) {
        if (initial === void 0)
          initial = context.initial;
        if (animate === void 0)
          animate = context.animate;
      }
      let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
      isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
      const variantToSet = isInitialAnimationBlocked ? animate : initial;
      if (variantToSet && typeof variantToSet !== "boolean" && !indexLegacy.isAnimationControls(variantToSet)) {
        const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
        list.forEach((definition) => {
          const resolved = indexLegacy.resolveVariantFromProps(props, definition);
          if (!resolved)
            return;
          const { transitionEnd, transition, ...target } = resolved;
          for (const key in target) {
            let valueTarget = target[key];
            if (Array.isArray(valueTarget)) {
              const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
              valueTarget = valueTarget[index];
            }
            if (valueTarget !== null) {
              values[key] = valueTarget;
            }
          }
          for (const key in transitionEnd)
            values[key] = transitionEnd[key];
        });
      }
      return values;
    }
    var svgMotionConfig = {
      useVisualState: makeUseVisualState({
        scrapeMotionValuesFromProps: indexLegacy.scrapeMotionValuesFromProps,
        createRenderState: createSvgRenderState,
        onMount: (props, instance, { renderState, latestValues }) => {
          try {
            renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
          } catch (e) {
            renderState.dimensions = {
              x: 0,
              y: 0,
              width: 0,
              height: 0
            };
          }
          indexLegacy.buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, indexLegacy.isSVGTag(instance.tagName), props.transformTemplate);
          indexLegacy.renderSVG(instance, renderState);
        }
      })
    };
    var htmlMotionConfig = {
      useVisualState: makeUseVisualState({
        scrapeMotionValuesFromProps: indexLegacy.scrapeMotionValuesFromProps$1,
        createRenderState: createHtmlRenderState
      })
    };
    function createDomMotionConfig(Component, { forwardMotionProps = false }, preloadedFeatures2, createVisualElement) {
      const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;
      return {
        ...baseConfig,
        preloadedFeatures: preloadedFeatures2,
        useRender: createUseRender(forwardMotionProps),
        createVisualElement,
        Component
      };
    }
    function addDomEvent(target, eventName, handler, options = { passive: true }) {
      target.addEventListener(eventName, handler, options);
      return () => target.removeEventListener(eventName, handler);
    }
    var isPrimaryPointer = (event) => {
      if (event.pointerType === "mouse") {
        return typeof event.button !== "number" || event.button <= 0;
      } else {
        return event.isPrimary !== false;
      }
    };
    function extractEventInfo(event, pointType = "page") {
      return {
        point: {
          x: event[pointType + "X"],
          y: event[pointType + "Y"]
        }
      };
    }
    var addPointerInfo = (handler) => {
      return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
    };
    function addPointerEvent(target, eventName, handler, options) {
      return addDomEvent(target, eventName, addPointerInfo(handler), options);
    }
    function createLock(name) {
      let lock = null;
      return () => {
        const openLock = () => {
          lock = null;
        };
        if (lock === null) {
          lock = name;
          return openLock;
        }
        return false;
      };
    }
    var globalHorizontalLock = createLock("dragHorizontal");
    var globalVerticalLock = createLock("dragVertical");
    function getGlobalLock(drag2) {
      let lock = false;
      if (drag2 === "y") {
        lock = globalVerticalLock();
      } else if (drag2 === "x") {
        lock = globalHorizontalLock();
      } else {
        const openHorizontal = globalHorizontalLock();
        const openVertical = globalVerticalLock();
        if (openHorizontal && openVertical) {
          lock = () => {
            openHorizontal();
            openVertical();
          };
        } else {
          if (openHorizontal)
            openHorizontal();
          if (openVertical)
            openVertical();
        }
      }
      return lock;
    }
    function isDragActive() {
      const openGestureLock = getGlobalLock(true);
      if (!openGestureLock)
        return true;
      openGestureLock();
      return false;
    }
    var Feature = class {
      constructor(node) {
        this.isMounted = false;
        this.node = node;
      }
      update() {
      }
    };
    function addHoverEvent(node, isActive) {
      const eventName = "pointer" + (isActive ? "enter" : "leave");
      const callbackName = "onHover" + (isActive ? "Start" : "End");
      const handleEvent = (event, info) => {
        if (event.type === "touch" || isDragActive())
          return;
        const props = node.getProps();
        if (node.animationState && props.whileHover) {
          node.animationState.setActive("whileHover", isActive);
        }
        if (props[callbackName]) {
          indexLegacy.frame.update(() => props[callbackName](event, info));
        }
      };
      return addPointerEvent(node.current, eventName, handleEvent, {
        passive: !node.getProps()[callbackName]
      });
    }
    var HoverGesture = class extends Feature {
      mount() {
        this.unmount = indexLegacy.pipe(addHoverEvent(this.node, true), addHoverEvent(this.node, false));
      }
      unmount() {
      }
    };
    var FocusGesture = class extends Feature {
      constructor() {
        super(...arguments);
        this.isActive = false;
      }
      onFocus() {
        let isFocusVisible = false;
        try {
          isFocusVisible = this.node.current.matches(":focus-visible");
        } catch (e) {
          isFocusVisible = true;
        }
        if (!isFocusVisible || !this.node.animationState)
          return;
        this.node.animationState.setActive("whileFocus", true);
        this.isActive = true;
      }
      onBlur() {
        if (!this.isActive || !this.node.animationState)
          return;
        this.node.animationState.setActive("whileFocus", false);
        this.isActive = false;
      }
      mount() {
        this.unmount = indexLegacy.pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
      }
      unmount() {
      }
    };
    var isNodeOrChild = (parent, child) => {
      if (!child) {
        return false;
      } else if (parent === child) {
        return true;
      } else {
        return isNodeOrChild(parent, child.parentElement);
      }
    };
    function fireSyntheticPointerEvent(name, handler) {
      if (!handler)
        return;
      const syntheticPointerEvent = new PointerEvent("pointer" + name);
      handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));
    }
    var PressGesture = class extends Feature {
      constructor() {
        super(...arguments);
        this.removeStartListeners = indexLegacy.noop;
        this.removeEndListeners = indexLegacy.noop;
        this.removeAccessibleListeners = indexLegacy.noop;
        this.startPointerPress = (startEvent, startInfo) => {
          this.removeEndListeners();
          if (this.isPressing)
            return;
          const props = this.node.getProps();
          const endPointerPress = (endEvent, endInfo) => {
            if (!this.checkPressEnd())
              return;
            const { onTap, onTapCancel } = this.node.getProps();
            indexLegacy.frame.update(() => {
              !isNodeOrChild(this.node.current, endEvent.target) ? onTapCancel && onTapCancel(endEvent, endInfo) : onTap && onTap(endEvent, endInfo);
            });
          };
          const removePointerUpListener = addPointerEvent(window, "pointerup", endPointerPress, { passive: !(props.onTap || props["onPointerUp"]) });
          const removePointerCancelListener = addPointerEvent(window, "pointercancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), { passive: !(props.onTapCancel || props["onPointerCancel"]) });
          this.removeEndListeners = indexLegacy.pipe(removePointerUpListener, removePointerCancelListener);
          this.startPress(startEvent, startInfo);
        };
        this.startAccessiblePress = () => {
          const handleKeydown = (keydownEvent) => {
            if (keydownEvent.key !== "Enter" || this.isPressing)
              return;
            const handleKeyup = (keyupEvent) => {
              if (keyupEvent.key !== "Enter" || !this.checkPressEnd())
                return;
              fireSyntheticPointerEvent("up", (event, info) => {
                const { onTap } = this.node.getProps();
                if (onTap) {
                  indexLegacy.frame.update(() => onTap(event, info));
                }
              });
            };
            this.removeEndListeners();
            this.removeEndListeners = addDomEvent(this.node.current, "keyup", handleKeyup);
            fireSyntheticPointerEvent("down", (event, info) => {
              this.startPress(event, info);
            });
          };
          const removeKeydownListener = addDomEvent(this.node.current, "keydown", handleKeydown);
          const handleBlur = () => {
            if (!this.isPressing)
              return;
            fireSyntheticPointerEvent("cancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));
          };
          const removeBlurListener = addDomEvent(this.node.current, "blur", handleBlur);
          this.removeAccessibleListeners = indexLegacy.pipe(removeKeydownListener, removeBlurListener);
        };
      }
      startPress(event, info) {
        this.isPressing = true;
        const { onTapStart, whileTap } = this.node.getProps();
        if (whileTap && this.node.animationState) {
          this.node.animationState.setActive("whileTap", true);
        }
        if (onTapStart) {
          indexLegacy.frame.update(() => onTapStart(event, info));
        }
      }
      checkPressEnd() {
        this.removeEndListeners();
        this.isPressing = false;
        const props = this.node.getProps();
        if (props.whileTap && this.node.animationState) {
          this.node.animationState.setActive("whileTap", false);
        }
        return !isDragActive();
      }
      cancelPress(event, info) {
        if (!this.checkPressEnd())
          return;
        const { onTapCancel } = this.node.getProps();
        if (onTapCancel) {
          indexLegacy.frame.update(() => onTapCancel(event, info));
        }
      }
      mount() {
        const props = this.node.getProps();
        const removePointerListener = addPointerEvent(this.node.current, "pointerdown", this.startPointerPress, { passive: !(props.onTapStart || props["onPointerStart"]) });
        const removeFocusListener = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
        this.removeStartListeners = indexLegacy.pipe(removePointerListener, removeFocusListener);
      }
      unmount() {
        this.removeStartListeners();
        this.removeEndListeners();
        this.removeAccessibleListeners();
      }
    };
    var observerCallbacks = /* @__PURE__ */ new WeakMap();
    var observers = /* @__PURE__ */ new WeakMap();
    var fireObserverCallback = (entry) => {
      const callback = observerCallbacks.get(entry.target);
      callback && callback(entry);
    };
    var fireAllObserverCallbacks = (entries) => {
      entries.forEach(fireObserverCallback);
    };
    function initIntersectionObserver({ root, ...options }) {
      const lookupRoot = root || document;
      if (!observers.has(lookupRoot)) {
        observers.set(lookupRoot, {});
      }
      const rootObservers = observers.get(lookupRoot);
      const key = JSON.stringify(options);
      if (!rootObservers[key]) {
        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });
      }
      return rootObservers[key];
    }
    function observeIntersection(element, options, callback) {
      const rootInteresectionObserver = initIntersectionObserver(options);
      observerCallbacks.set(element, callback);
      rootInteresectionObserver.observe(element);
      return () => {
        observerCallbacks.delete(element);
        rootInteresectionObserver.unobserve(element);
      };
    }
    var thresholdNames = {
      some: 0,
      all: 1
    };
    var InViewFeature = class extends Feature {
      constructor() {
        super(...arguments);
        this.hasEnteredView = false;
        this.isInView = false;
      }
      startObserver() {
        this.unmount();
        const { viewport = {} } = this.node.getProps();
        const { root, margin: rootMargin, amount = "some", once } = viewport;
        const options = {
          root: root ? root.current : void 0,
          rootMargin,
          threshold: typeof amount === "number" ? amount : thresholdNames[amount]
        };
        const onIntersectionUpdate = (entry) => {
          const { isIntersecting } = entry;
          if (this.isInView === isIntersecting)
            return;
          this.isInView = isIntersecting;
          if (once && !isIntersecting && this.hasEnteredView) {
            return;
          } else if (isIntersecting) {
            this.hasEnteredView = true;
          }
          if (this.node.animationState) {
            this.node.animationState.setActive("whileInView", isIntersecting);
          }
          const { onViewportEnter, onViewportLeave } = this.node.getProps();
          const callback = isIntersecting ? onViewportEnter : onViewportLeave;
          callback && callback(entry);
        };
        return observeIntersection(this.node.current, options, onIntersectionUpdate);
      }
      mount() {
        this.startObserver();
      }
      update() {
        if (typeof IntersectionObserver === "undefined")
          return;
        const { props, prevProps } = this.node;
        const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
        if (hasOptionsChanged) {
          this.startObserver();
        }
      }
      unmount() {
      }
    };
    function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
      return (name) => viewport[name] !== prevViewport[name];
    }
    var gestureAnimations = {
      inView: {
        Feature: InViewFeature
      },
      tap: {
        Feature: PressGesture
      },
      focus: {
        Feature: FocusGesture
      },
      hover: {
        Feature: HoverGesture
      }
    };
    function shallowCompare(next, prev) {
      if (!Array.isArray(prev))
        return false;
      const prevLength = prev.length;
      if (prevLength !== next.length)
        return false;
      for (let i = 0; i < prevLength; i++) {
        if (prev[i] !== next[i])
          return false;
      }
      return true;
    }
    function animateVariant(visualElement, variant, options = {}) {
      const resolved = indexLegacy.resolveVariant(visualElement, variant, options.custom);
      let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
      if (options.transitionOverride) {
        transition = options.transitionOverride;
      }
      const getAnimation = resolved ? () => Promise.all(indexLegacy.animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
      const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
        const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
        return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
      } : () => Promise.resolve();
      const { when } = transition;
      if (when) {
        const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
        return first().then(() => last());
      } else {
        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
      }
    }
    function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
      const animations2 = [];
      const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
      const generateStaggerDuration = staggerDirection === 1 ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;
      Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {
        child.notify("AnimationStart", variant);
        animations2.push(animateVariant(child, variant, {
          ...options,
          delay: delayChildren + generateStaggerDuration(i)
        }).then(() => child.notify("AnimationComplete", variant)));
      });
      return Promise.all(animations2);
    }
    function sortByTreeOrder(a, b) {
      return a.sortNodePosition(b);
    }
    function animateVisualElement(visualElement, definition, options = {}) {
      visualElement.notify("AnimationStart", definition);
      let animation;
      if (Array.isArray(definition)) {
        const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
        animation = Promise.all(animations2);
      } else if (typeof definition === "string") {
        animation = animateVariant(visualElement, definition, options);
      } else {
        const resolvedDefinition = typeof definition === "function" ? indexLegacy.resolveVariant(visualElement, definition, options.custom) : definition;
        animation = Promise.all(indexLegacy.animateTarget(visualElement, resolvedDefinition, options));
      }
      return animation.then(() => visualElement.notify("AnimationComplete", definition));
    }
    var reversePriorityOrder = [...indexLegacy.variantPriorityOrder].reverse();
    var numAnimationTypes = indexLegacy.variantPriorityOrder.length;
    function animateList(visualElement) {
      return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
    }
    function createAnimationState(visualElement) {
      let animate = animateList(visualElement);
      const state = createState();
      let isInitialRender = true;
      const buildResolvedTypeValues = (acc, definition) => {
        const resolved = indexLegacy.resolveVariant(visualElement, definition);
        if (resolved) {
          const { transition, transitionEnd, ...target } = resolved;
          acc = { ...acc, ...target, ...transitionEnd };
        }
        return acc;
      };
      function setAnimateFunction(makeAnimator) {
        animate = makeAnimator(visualElement);
      }
      function animateChanges(options, changedActiveType) {
        const props = visualElement.getProps();
        const context = visualElement.getVariantContext(true) || {};
        const animations2 = [];
        const removedKeys = /* @__PURE__ */ new Set();
        let encounteredKeys = {};
        let removedVariantIndex = Infinity;
        for (let i = 0; i < numAnimationTypes; i++) {
          const type = reversePriorityOrder[i];
          const typeState = state[type];
          const prop = props[type] !== void 0 ? props[type] : context[type];
          const propIsVariant = indexLegacy.isVariantLabel(prop);
          const activeDelta = type === changedActiveType ? typeState.isActive : null;
          if (activeDelta === false)
            removedVariantIndex = i;
          let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
          if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
            isInherited = false;
          }
          typeState.protectedKeys = { ...encounteredKeys };
          if (!typeState.isActive && activeDelta === null || !prop && !typeState.prevProp || indexLegacy.isAnimationControls(prop) || typeof prop === "boolean") {
            continue;
          }
          const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
          let shouldAnimateType = variantDidChange || type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || i > removedVariantIndex && propIsVariant;
          const definitionList = Array.isArray(prop) ? prop : [prop];
          let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
          if (activeDelta === false)
            resolvedValues = {};
          const { prevResolvedValues = {} } = typeState;
          const allKeys = {
            ...prevResolvedValues,
            ...resolvedValues
          };
          const markToAnimate = (key) => {
            shouldAnimateType = true;
            removedKeys.delete(key);
            typeState.needsAnimating[key] = true;
          };
          for (const key in allKeys) {
            const next = resolvedValues[key];
            const prev = prevResolvedValues[key];
            if (encounteredKeys.hasOwnProperty(key))
              continue;
            if (next !== prev) {
              if (indexLegacy.isKeyframesTarget(next) && indexLegacy.isKeyframesTarget(prev)) {
                if (!shallowCompare(next, prev) || variantDidChange) {
                  markToAnimate(key);
                } else {
                  typeState.protectedKeys[key] = true;
                }
              } else if (next !== void 0) {
                markToAnimate(key);
              } else {
                removedKeys.add(key);
              }
            } else if (next !== void 0 && removedKeys.has(key)) {
              markToAnimate(key);
            } else {
              typeState.protectedKeys[key] = true;
            }
          }
          typeState.prevProp = prop;
          typeState.prevResolvedValues = resolvedValues;
          if (typeState.isActive) {
            encounteredKeys = { ...encounteredKeys, ...resolvedValues };
          }
          if (isInitialRender && visualElement.blockInitialAnimation) {
            shouldAnimateType = false;
          }
          if (shouldAnimateType && !isInherited) {
            animations2.push(...definitionList.map((animation) => ({
              animation,
              options: { type, ...options }
            })));
          }
        }
        if (removedKeys.size) {
          const fallbackAnimation = {};
          removedKeys.forEach((key) => {
            const fallbackTarget = visualElement.getBaseTarget(key);
            if (fallbackTarget !== void 0) {
              fallbackAnimation[key] = fallbackTarget;
            }
          });
          animations2.push({ animation: fallbackAnimation });
        }
        let shouldAnimate = Boolean(animations2.length);
        if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {
          shouldAnimate = false;
        }
        isInitialRender = false;
        return shouldAnimate ? animate(animations2) : Promise.resolve();
      }
      function setActive(type, isActive, options) {
        var _a;
        if (state[type].isActive === isActive)
          return Promise.resolve();
        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => {
          var _a2;
          return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);
        });
        state[type].isActive = isActive;
        const animations2 = animateChanges(options, type);
        for (const key in state) {
          state[key].protectedKeys = {};
        }
        return animations2;
      }
      return {
        animateChanges,
        setActive,
        setAnimateFunction,
        getState: () => state
      };
    }
    function checkVariantsDidChange(prev, next) {
      if (typeof next === "string") {
        return next !== prev;
      } else if (Array.isArray(next)) {
        return !shallowCompare(next, prev);
      }
      return false;
    }
    function createTypeState(isActive = false) {
      return {
        isActive,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
      };
    }
    function createState() {
      return {
        animate: createTypeState(true),
        whileInView: createTypeState(),
        whileHover: createTypeState(),
        whileTap: createTypeState(),
        whileDrag: createTypeState(),
        whileFocus: createTypeState(),
        exit: createTypeState()
      };
    }
    var AnimationFeature = class extends Feature {
      constructor(node) {
        super(node);
        node.animationState || (node.animationState = createAnimationState(node));
      }
      updateAnimationControlsSubscription() {
        const { animate } = this.node.getProps();
        this.unmount();
        if (indexLegacy.isAnimationControls(animate)) {
          this.unmount = animate.subscribe(this.node);
        }
      }
      mount() {
        this.updateAnimationControlsSubscription();
      }
      update() {
        const { animate } = this.node.getProps();
        const { animate: prevAnimate } = this.node.prevProps || {};
        if (animate !== prevAnimate) {
          this.updateAnimationControlsSubscription();
        }
      }
      unmount() {
      }
    };
    var id$2 = 0;
    var ExitAnimationFeature = class extends Feature {
      constructor() {
        super(...arguments);
        this.id = id$2++;
      }
      update() {
        if (!this.node.presenceContext)
          return;
        const { isPresent: isPresent2, onExitComplete, custom } = this.node.presenceContext;
        const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
        if (!this.node.animationState || isPresent2 === prevIsPresent) {
          return;
        }
        const exitAnimation = this.node.animationState.setActive("exit", !isPresent2, { custom: custom !== null && custom !== void 0 ? custom : this.node.getProps().custom });
        if (onExitComplete && !isPresent2) {
          exitAnimation.then(() => onExitComplete(this.id));
        }
      }
      mount() {
        const { register } = this.node.presenceContext || {};
        if (register) {
          this.unmount = register(this.id);
        }
      }
      unmount() {
      }
    };
    var animations = {
      animation: {
        Feature: AnimationFeature
      },
      exit: {
        Feature: ExitAnimationFeature
      }
    };
    var PanSession = class {
      constructor(event, handlers, { transformPagePoint } = {}) {
        this.startEvent = null;
        this.lastMoveEvent = null;
        this.lastMoveEventInfo = null;
        this.handlers = {};
        this.updatePoint = () => {
          if (!(this.lastMoveEvent && this.lastMoveEventInfo))
            return;
          const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
          const isPanStarted = this.startEvent !== null;
          const isDistancePastThreshold = indexLegacy.distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
          if (!isPanStarted && !isDistancePastThreshold)
            return;
          const { point: point2 } = info2;
          const { timestamp: timestamp2 } = indexLegacy.frameData;
          this.history.push({ ...point2, timestamp: timestamp2 });
          const { onStart, onMove } = this.handlers;
          if (!isPanStarted) {
            onStart && onStart(this.lastMoveEvent, info2);
            this.startEvent = this.lastMoveEvent;
          }
          onMove && onMove(this.lastMoveEvent, info2);
        };
        this.handlePointerMove = (event2, info2) => {
          this.lastMoveEvent = event2;
          this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
          indexLegacy.frame.update(this.updatePoint, true);
        };
        this.handlePointerUp = (event2, info2) => {
          this.end();
          if (!(this.lastMoveEvent && this.lastMoveEventInfo))
            return;
          const { onEnd, onSessionEnd } = this.handlers;
          const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
          if (this.startEvent && onEnd) {
            onEnd(event2, panInfo);
          }
          onSessionEnd && onSessionEnd(event2, panInfo);
        };
        if (!isPrimaryPointer(event))
          return;
        this.handlers = handlers;
        this.transformPagePoint = transformPagePoint;
        const info = extractEventInfo(event);
        const initialInfo = transformPoint(info, this.transformPagePoint);
        const { point } = initialInfo;
        const { timestamp } = indexLegacy.frameData;
        this.history = [{ ...point, timestamp }];
        const { onSessionStart } = handlers;
        onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
        this.removeListeners = indexLegacy.pipe(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));
      }
      updateHandlers(handlers) {
        this.handlers = handlers;
      }
      end() {
        this.removeListeners && this.removeListeners();
        indexLegacy.cancelFrame(this.updatePoint);
      }
    };
    function transformPoint(info, transformPagePoint) {
      return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
    }
    function subtractPoint(a, b) {
      return { x: a.x - b.x, y: a.y - b.y };
    }
    function getPanInfo({ point }, history) {
      return {
        point,
        delta: subtractPoint(point, lastDevicePoint(history)),
        offset: subtractPoint(point, startDevicePoint(history)),
        velocity: getVelocity(history, 0.1)
      };
    }
    function startDevicePoint(history) {
      return history[0];
    }
    function lastDevicePoint(history) {
      return history[history.length - 1];
    }
    function getVelocity(history, timeDelta) {
      if (history.length < 2) {
        return { x: 0, y: 0 };
      }
      let i = history.length - 1;
      let timestampedPoint = null;
      const lastPoint = lastDevicePoint(history);
      while (i >= 0) {
        timestampedPoint = history[i];
        if (lastPoint.timestamp - timestampedPoint.timestamp > indexLegacy.secondsToMilliseconds(timeDelta)) {
          break;
        }
        i--;
      }
      if (!timestampedPoint) {
        return { x: 0, y: 0 };
      }
      const time = indexLegacy.millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
      if (time === 0) {
        return { x: 0, y: 0 };
      }
      const currentVelocity = {
        x: (lastPoint.x - timestampedPoint.x) / time,
        y: (lastPoint.y - timestampedPoint.y) / time
      };
      if (currentVelocity.x === Infinity) {
        currentVelocity.x = 0;
      }
      if (currentVelocity.y === Infinity) {
        currentVelocity.y = 0;
      }
      return currentVelocity;
    }
    function calcLength(axis) {
      return axis.max - axis.min;
    }
    function isNear(value, target = 0, maxDistance = 0.01) {
      return Math.abs(value - target) <= maxDistance;
    }
    function calcAxisDelta(delta, source, target, origin = 0.5) {
      delta.origin = origin;
      delta.originPoint = indexLegacy.mix(source.min, source.max, delta.origin);
      delta.scale = calcLength(target) / calcLength(source);
      if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))
        delta.scale = 1;
      delta.translate = indexLegacy.mix(target.min, target.max, delta.origin) - delta.originPoint;
      if (isNear(delta.translate) || isNaN(delta.translate))
        delta.translate = 0;
    }
    function calcBoxDelta(delta, source, target, origin) {
      calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
      calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
    }
    function calcRelativeAxis(target, relative, parent) {
      target.min = parent.min + relative.min;
      target.max = target.min + calcLength(relative);
    }
    function calcRelativeBox(target, relative, parent) {
      calcRelativeAxis(target.x, relative.x, parent.x);
      calcRelativeAxis(target.y, relative.y, parent.y);
    }
    function calcRelativeAxisPosition(target, layout2, parent) {
      target.min = layout2.min - parent.min;
      target.max = target.min + calcLength(layout2);
    }
    function calcRelativePosition(target, layout2, parent) {
      calcRelativeAxisPosition(target.x, layout2.x, parent.x);
      calcRelativeAxisPosition(target.y, layout2.y, parent.y);
    }
    function applyConstraints(point, { min, max }, elastic) {
      if (min !== void 0 && point < min) {
        point = elastic ? indexLegacy.mix(min, point, elastic.min) : Math.max(point, min);
      } else if (max !== void 0 && point > max) {
        point = elastic ? indexLegacy.mix(max, point, elastic.max) : Math.min(point, max);
      }
      return point;
    }
    function calcRelativeAxisConstraints(axis, min, max) {
      return {
        min: min !== void 0 ? axis.min + min : void 0,
        max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
      };
    }
    function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
      return {
        x: calcRelativeAxisConstraints(layoutBox.x, left, right),
        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
      };
    }
    function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
      let min = constraintsAxis.min - layoutAxis.min;
      let max = constraintsAxis.max - layoutAxis.max;
      if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
        [min, max] = [max, min];
      }
      return { min, max };
    }
    function calcViewportConstraints(layoutBox, constraintsBox) {
      return {
        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
      };
    }
    function calcOrigin(source, target) {
      let origin = 0.5;
      const sourceLength = calcLength(source);
      const targetLength = calcLength(target);
      if (targetLength > sourceLength) {
        origin = indexLegacy.progress(target.min, target.max - sourceLength, source.min);
      } else if (sourceLength > targetLength) {
        origin = indexLegacy.progress(source.min, source.max - targetLength, target.min);
      }
      return indexLegacy.clamp(0, 1, origin);
    }
    function rebaseAxisConstraints(layout2, constraints) {
      const relativeConstraints = {};
      if (constraints.min !== void 0) {
        relativeConstraints.min = constraints.min - layout2.min;
      }
      if (constraints.max !== void 0) {
        relativeConstraints.max = constraints.max - layout2.min;
      }
      return relativeConstraints;
    }
    var defaultElastic = 0.35;
    function resolveDragElastic(dragElastic = defaultElastic) {
      if (dragElastic === false) {
        dragElastic = 0;
      } else if (dragElastic === true) {
        dragElastic = defaultElastic;
      }
      return {
        x: resolveAxisElastic(dragElastic, "left", "right"),
        y: resolveAxisElastic(dragElastic, "top", "bottom")
      };
    }
    function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
      return {
        min: resolvePointElastic(dragElastic, minLabel),
        max: resolvePointElastic(dragElastic, maxLabel)
      };
    }
    function resolvePointElastic(dragElastic, label) {
      return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
    }
    function eachAxis(callback) {
      return [callback("x"), callback("y")];
    }
    var elementDragControls = /* @__PURE__ */ new WeakMap();
    var VisualElementDragControls = class {
      constructor(visualElement) {
        this.openGlobalLock = null;
        this.isDragging = false;
        this.currentDirection = null;
        this.originPoint = { x: 0, y: 0 };
        this.constraints = false;
        this.hasMutatedConstraints = false;
        this.elastic = indexLegacy.createBox();
        this.visualElement = visualElement;
      }
      start(originEvent, { snapToCursor = false } = {}) {
        const { presenceContext } = this.visualElement;
        if (presenceContext && presenceContext.isPresent === false)
          return;
        const onSessionStart = (event) => {
          this.stopAnimation();
          if (snapToCursor) {
            this.snapToCursor(extractEventInfo(event, "page").point);
          }
        };
        const onStart = (event, info) => {
          const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
          if (drag2 && !dragPropagation) {
            if (this.openGlobalLock)
              this.openGlobalLock();
            this.openGlobalLock = getGlobalLock(drag2);
            if (!this.openGlobalLock)
              return;
          }
          this.isDragging = true;
          this.currentDirection = null;
          this.resolveConstraints();
          if (this.visualElement.projection) {
            this.visualElement.projection.isAnimationBlocked = true;
            this.visualElement.projection.target = void 0;
          }
          eachAxis((axis) => {
            let current = this.getAxisMotionValue(axis).get() || 0;
            if (indexLegacy.percent.test(current)) {
              const { projection } = this.visualElement;
              if (projection && projection.layout) {
                const measuredAxis = projection.layout.layoutBox[axis];
                if (measuredAxis) {
                  const length = calcLength(measuredAxis);
                  current = length * (parseFloat(current) / 100);
                }
              }
            }
            this.originPoint[axis] = current;
          });
          if (onDragStart) {
            indexLegacy.frame.update(() => onDragStart(event, info), false, true);
          }
          const { animationState } = this.visualElement;
          animationState && animationState.setActive("whileDrag", true);
        };
        const onMove = (event, info) => {
          const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
          if (!dragPropagation && !this.openGlobalLock)
            return;
          const { offset } = info;
          if (dragDirectionLock && this.currentDirection === null) {
            this.currentDirection = getCurrentDirection(offset);
            if (this.currentDirection !== null) {
              onDirectionLock && onDirectionLock(this.currentDirection);
            }
            return;
          }
          this.updateAxis("x", info.point, offset);
          this.updateAxis("y", info.point, offset);
          this.visualElement.render();
          onDrag && onDrag(event, info);
        };
        const onSessionEnd = (event, info) => this.stop(event, info);
        this.panSession = new PanSession(originEvent, {
          onSessionStart,
          onStart,
          onMove,
          onSessionEnd
        }, { transformPagePoint: this.visualElement.getTransformPagePoint() });
      }
      stop(event, info) {
        const isDragging = this.isDragging;
        this.cancel();
        if (!isDragging)
          return;
        const { velocity } = info;
        this.startAnimation(velocity);
        const { onDragEnd } = this.getProps();
        if (onDragEnd) {
          indexLegacy.frame.update(() => onDragEnd(event, info));
        }
      }
      cancel() {
        this.isDragging = false;
        const { projection, animationState } = this.visualElement;
        if (projection) {
          projection.isAnimationBlocked = false;
        }
        this.panSession && this.panSession.end();
        this.panSession = void 0;
        const { dragPropagation } = this.getProps();
        if (!dragPropagation && this.openGlobalLock) {
          this.openGlobalLock();
          this.openGlobalLock = null;
        }
        animationState && animationState.setActive("whileDrag", false);
      }
      updateAxis(axis, _point, offset) {
        const { drag: drag2 } = this.getProps();
        if (!offset || !shouldDrag(axis, drag2, this.currentDirection))
          return;
        const axisValue = this.getAxisMotionValue(axis);
        let next = this.originPoint[axis] + offset[axis];
        if (this.constraints && this.constraints[axis]) {
          next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
        }
        axisValue.set(next);
      }
      resolveConstraints() {
        const { dragConstraints, dragElastic } = this.getProps();
        const { layout: layout2 } = this.visualElement.projection || {};
        const prevConstraints = this.constraints;
        if (dragConstraints && indexLegacy.isRefObject(dragConstraints)) {
          if (!this.constraints) {
            this.constraints = this.resolveRefConstraints();
          }
        } else {
          if (dragConstraints && layout2) {
            this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
          } else {
            this.constraints = false;
          }
        }
        this.elastic = resolveDragElastic(dragElastic);
        if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
          eachAxis((axis) => {
            if (this.getAxisMotionValue(axis)) {
              this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
            }
          });
        }
      }
      resolveRefConstraints() {
        const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
        if (!constraints || !indexLegacy.isRefObject(constraints))
          return false;
        const constraintsElement = constraints.current;
        indexLegacy.invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
        const { projection } = this.visualElement;
        if (!projection || !projection.layout)
          return false;
        const constraintsBox = indexLegacy.measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
        let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
        if (onMeasureDragConstraints) {
          const userConstraints = onMeasureDragConstraints(indexLegacy.convertBoxToBoundingBox(measuredConstraints));
          this.hasMutatedConstraints = !!userConstraints;
          if (userConstraints) {
            measuredConstraints = indexLegacy.convertBoundingBoxToBox(userConstraints);
          }
        }
        return measuredConstraints;
      }
      startAnimation(velocity) {
        const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
        const constraints = this.constraints || {};
        const momentumAnimations = eachAxis((axis) => {
          if (!shouldDrag(axis, drag2, this.currentDirection)) {
            return;
          }
          let transition = constraints && constraints[axis] || {};
          if (dragSnapToOrigin)
            transition = { min: 0, max: 0 };
          const bounceStiffness = dragElastic ? 200 : 1e6;
          const bounceDamping = dragElastic ? 40 : 1e7;
          const inertia = {
            type: "inertia",
            velocity: dragMomentum ? velocity[axis] : 0,
            bounceStiffness,
            bounceDamping,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...dragTransition,
            ...transition
          };
          return this.startAxisValueAnimation(axis, inertia);
        });
        return Promise.all(momentumAnimations).then(onDragTransitionEnd);
      }
      startAxisValueAnimation(axis, transition) {
        const axisValue = this.getAxisMotionValue(axis);
        return axisValue.start(indexLegacy.animateMotionValue(axis, axisValue, 0, transition));
      }
      stopAnimation() {
        eachAxis((axis) => this.getAxisMotionValue(axis).stop());
      }
      getAxisMotionValue(axis) {
        const dragKey = "_drag" + axis.toUpperCase();
        const props = this.visualElement.getProps();
        const externalMotionValue = props[dragKey];
        return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
      }
      snapToCursor(point) {
        eachAxis((axis) => {
          const { drag: drag2 } = this.getProps();
          if (!shouldDrag(axis, drag2, this.currentDirection))
            return;
          const { projection } = this.visualElement;
          const axisValue = this.getAxisMotionValue(axis);
          if (projection && projection.layout) {
            const { min, max } = projection.layout.layoutBox[axis];
            axisValue.set(point[axis] - indexLegacy.mix(min, max, 0.5));
          }
        });
      }
      scalePositionWithinConstraints() {
        if (!this.visualElement.current)
          return;
        const { drag: drag2, dragConstraints } = this.getProps();
        const { projection } = this.visualElement;
        if (!indexLegacy.isRefObject(dragConstraints) || !projection || !this.constraints)
          return;
        this.stopAnimation();
        const boxProgress = { x: 0, y: 0 };
        eachAxis((axis) => {
          const axisValue = this.getAxisMotionValue(axis);
          if (axisValue) {
            const latest = axisValue.get();
            boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
          }
        });
        const { transformTemplate } = this.visualElement.getProps();
        this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
        projection.root && projection.root.updateScroll();
        projection.updateLayout();
        this.resolveConstraints();
        eachAxis((axis) => {
          if (!shouldDrag(axis, drag2, null))
            return;
          const axisValue = this.getAxisMotionValue(axis);
          const { min, max } = this.constraints[axis];
          axisValue.set(indexLegacy.mix(min, max, boxProgress[axis]));
        });
      }
      addListeners() {
        if (!this.visualElement.current)
          return;
        elementDragControls.set(this.visualElement, this);
        const element = this.visualElement.current;
        const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
          const { drag: drag2, dragListener = true } = this.getProps();
          drag2 && dragListener && this.start(event);
        });
        const measureDragConstraints = () => {
          const { dragConstraints } = this.getProps();
          if (indexLegacy.isRefObject(dragConstraints)) {
            this.constraints = this.resolveRefConstraints();
          }
        };
        const { projection } = this.visualElement;
        const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
        if (projection && !projection.layout) {
          projection.root && projection.root.updateScroll();
          projection.updateLayout();
        }
        measureDragConstraints();
        const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
        const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
          if (this.isDragging && hasLayoutChanged) {
            eachAxis((axis) => {
              const motionValue = this.getAxisMotionValue(axis);
              if (!motionValue)
                return;
              this.originPoint[axis] += delta[axis].translate;
              motionValue.set(motionValue.get() + delta[axis].translate);
            });
            this.visualElement.render();
          }
        });
        return () => {
          stopResizeListener();
          stopPointerListener();
          stopMeasureLayoutListener();
          stopLayoutUpdateListener && stopLayoutUpdateListener();
        };
      }
      getProps() {
        const props = this.visualElement.getProps();
        const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
        return {
          ...props,
          drag: drag2,
          dragDirectionLock,
          dragPropagation,
          dragConstraints,
          dragElastic,
          dragMomentum
        };
      }
    };
    function shouldDrag(direction, drag2, currentDirection) {
      return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
    }
    function getCurrentDirection(offset, lockThreshold = 10) {
      let direction = null;
      if (Math.abs(offset.y) > lockThreshold) {
        direction = "y";
      } else if (Math.abs(offset.x) > lockThreshold) {
        direction = "x";
      }
      return direction;
    }
    var DragGesture = class extends Feature {
      constructor(node) {
        super(node);
        this.removeGroupControls = indexLegacy.noop;
        this.removeListeners = indexLegacy.noop;
        this.controls = new VisualElementDragControls(node);
      }
      mount() {
        const { dragControls } = this.node.getProps();
        if (dragControls) {
          this.removeGroupControls = dragControls.subscribe(this.controls);
        }
        this.removeListeners = this.controls.addListeners() || indexLegacy.noop;
      }
      unmount() {
        this.removeGroupControls();
        this.removeListeners();
      }
    };
    var asyncHandler = (handler) => (event, info) => {
      if (handler) {
        indexLegacy.frame.update(() => handler(event, info));
      }
    };
    var PanGesture = class extends Feature {
      constructor() {
        super(...arguments);
        this.removePointerDownListener = indexLegacy.noop;
      }
      onPointerDown(pointerDownEvent) {
        this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint() });
      }
      createPanHandlers() {
        const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
        return {
          onSessionStart: asyncHandler(onPanSessionStart),
          onStart: asyncHandler(onPanStart),
          onMove: onPan,
          onEnd: (event, info) => {
            delete this.session;
            if (onPanEnd) {
              indexLegacy.frame.update(() => onPanEnd(event, info));
            }
          }
        };
      }
      mount() {
        this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
      }
      update() {
        this.session && this.session.updateHandlers(this.createPanHandlers());
      }
      unmount() {
        this.removePointerDownListener();
        this.session && this.session.end();
      }
    };
    var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
    var numBorders = borders.length;
    var asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
    var isPx = (value) => typeof value === "number" || indexLegacy.px.test(value);
    function mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {
      if (shouldCrossfadeOpacity) {
        target.opacity = indexLegacy.mix(
          0,
          lead.opacity !== void 0 ? lead.opacity : 1,
          easeCrossfadeIn(progress)
        );
        target.opacityExit = indexLegacy.mix(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress));
      } else if (isOnlyMember) {
        target.opacity = indexLegacy.mix(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress);
      }
      for (let i = 0; i < numBorders; i++) {
        const borderLabel = `border${borders[i]}Radius`;
        let followRadius = getRadius(follow, borderLabel);
        let leadRadius = getRadius(lead, borderLabel);
        if (followRadius === void 0 && leadRadius === void 0)
          continue;
        followRadius || (followRadius = 0);
        leadRadius || (leadRadius = 0);
        const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
        if (canMix) {
          target[borderLabel] = Math.max(indexLegacy.mix(asNumber(followRadius), asNumber(leadRadius), progress), 0);
          if (indexLegacy.percent.test(leadRadius) || indexLegacy.percent.test(followRadius)) {
            target[borderLabel] += "%";
          }
        } else {
          target[borderLabel] = leadRadius;
        }
      }
      if (follow.rotate || lead.rotate) {
        target.rotate = indexLegacy.mix(follow.rotate || 0, lead.rotate || 0, progress);
      }
    }
    function getRadius(values, radiusName) {
      return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
    }
    var easeCrossfadeIn = compress(0, 0.5, indexLegacy.circOut);
    var easeCrossfadeOut = compress(0.5, 0.95, indexLegacy.noop);
    function compress(min, max, easing) {
      return (p) => {
        if (p < min)
          return 0;
        if (p > max)
          return 1;
        return easing(indexLegacy.progress(min, max, p));
      };
    }
    function copyAxisInto(axis, originAxis) {
      axis.min = originAxis.min;
      axis.max = originAxis.max;
    }
    function copyBoxInto(box, originBox) {
      copyAxisInto(box.x, originBox.x);
      copyAxisInto(box.y, originBox.y);
    }
    function removePointDelta(point, translate, scale, originPoint, boxScale) {
      point -= translate;
      point = indexLegacy.scalePoint(point, 1 / scale, originPoint);
      if (boxScale !== void 0) {
        point = indexLegacy.scalePoint(point, 1 / boxScale, originPoint);
      }
      return point;
    }
    function removeAxisDelta(axis, translate = 0, scale = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
      if (indexLegacy.percent.test(translate)) {
        translate = parseFloat(translate);
        const relativeProgress = indexLegacy.mix(sourceAxis.min, sourceAxis.max, translate / 100);
        translate = relativeProgress - sourceAxis.min;
      }
      if (typeof translate !== "number")
        return;
      let originPoint = indexLegacy.mix(originAxis.min, originAxis.max, origin);
      if (axis === originAxis)
        originPoint -= translate;
      axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);
      axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);
    }
    function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
      removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
    }
    var xKeys = ["x", "scaleX", "originX"];
    var yKeys = ["y", "scaleY", "originY"];
    function removeBoxTransforms(box, transforms, originBox, sourceBox) {
      removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
      removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
    }
    function isAxisDeltaZero(delta) {
      return delta.translate === 0 && delta.scale === 1;
    }
    function isDeltaZero(delta) {
      return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
    }
    function boxEquals(a, b) {
      return a.x.min === b.x.min && a.x.max === b.x.max && a.y.min === b.y.min && a.y.max === b.y.max;
    }
    function aspectRatio(box) {
      return calcLength(box.x) / calcLength(box.y);
    }
    var NodeStack = class {
      constructor() {
        this.members = [];
      }
      add(node) {
        indexLegacy.addUniqueItem(this.members, node);
        node.scheduleRender();
      }
      remove(node) {
        indexLegacy.removeItem(this.members, node);
        if (node === this.prevLead) {
          this.prevLead = void 0;
        }
        if (node === this.lead) {
          const prevLead = this.members[this.members.length - 1];
          if (prevLead) {
            this.promote(prevLead);
          }
        }
      }
      relegate(node) {
        const indexOfNode = this.members.findIndex((member) => node === member);
        if (indexOfNode === 0)
          return false;
        let prevLead;
        for (let i = indexOfNode; i >= 0; i--) {
          const member = this.members[i];
          if (member.isPresent !== false) {
            prevLead = member;
            break;
          }
        }
        if (prevLead) {
          this.promote(prevLead);
          return true;
        } else {
          return false;
        }
      }
      promote(node, preserveFollowOpacity) {
        const prevLead = this.lead;
        if (node === prevLead)
          return;
        this.prevLead = prevLead;
        this.lead = node;
        node.show();
        if (prevLead) {
          prevLead.instance && prevLead.scheduleRender();
          node.scheduleRender();
          node.resumeFrom = prevLead;
          if (preserveFollowOpacity) {
            node.resumeFrom.preserveOpacity = true;
          }
          if (prevLead.snapshot) {
            node.snapshot = prevLead.snapshot;
            node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
          }
          if (node.root && node.root.isUpdating) {
            node.isLayoutDirty = true;
          }
          const { crossfade } = node.options;
          if (crossfade === false) {
            prevLead.hide();
          }
        }
      }
      exitAnimationComplete() {
        this.members.forEach((node) => {
          const { options, resumingFrom } = node;
          options.onExitComplete && options.onExitComplete();
          if (resumingFrom) {
            resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
          }
        });
      }
      scheduleRender() {
        this.members.forEach((node) => {
          node.instance && node.scheduleRender(false);
        });
      }
      removeLeadSnapshot() {
        if (this.lead && this.lead.snapshot) {
          this.lead.snapshot = void 0;
        }
      }
    };
    function buildProjectionTransform(delta, treeScale, latestTransform) {
      let transform = "";
      const xTranslate = delta.x.translate / treeScale.x;
      const yTranslate = delta.y.translate / treeScale.y;
      if (xTranslate || yTranslate) {
        transform = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `;
      }
      if (treeScale.x !== 1 || treeScale.y !== 1) {
        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
      }
      if (latestTransform) {
        const { rotate, rotateX, rotateY } = latestTransform;
        if (rotate)
          transform += `rotate(${rotate}deg) `;
        if (rotateX)
          transform += `rotateX(${rotateX}deg) `;
        if (rotateY)
          transform += `rotateY(${rotateY}deg) `;
      }
      const elementScaleX = delta.x.scale * treeScale.x;
      const elementScaleY = delta.y.scale * treeScale.y;
      if (elementScaleX !== 1 || elementScaleY !== 1) {
        transform += `scale(${elementScaleX}, ${elementScaleY})`;
      }
      return transform || "none";
    }
    var compareByDepth = (a, b) => a.depth - b.depth;
    var FlatTree = class {
      constructor() {
        this.children = [];
        this.isDirty = false;
      }
      add(child) {
        indexLegacy.addUniqueItem(this.children, child);
        this.isDirty = true;
      }
      remove(child) {
        indexLegacy.removeItem(this.children, child);
        this.isDirty = true;
      }
      forEach(callback) {
        this.isDirty && this.children.sort(compareByDepth);
        this.isDirty = false;
        this.children.forEach(callback);
      }
    };
    var globalProjectionState = {
      hasAnimatedSinceResize: true,
      hasEverUpdated: false
    };
    function record(data) {
      if (window.MotionDebug) {
        window.MotionDebug.record(data);
      }
    }
    var transformAxes = ["", "X", "Y", "Z"];
    var animationTarget = 1e3;
    var id$1 = 0;
    var projectionFrameData = {
      type: "projectionFrame",
      totalNodes: 0,
      resolvedTargetDeltas: 0,
      recalculatedProjection: 0
    };
    function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
      return class ProjectionNode {
        constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
          this.id = id$1++;
          this.animationId = 0;
          this.children = /* @__PURE__ */ new Set();
          this.options = {};
          this.isTreeAnimating = false;
          this.isAnimationBlocked = false;
          this.isLayoutDirty = false;
          this.isProjectionDirty = false;
          this.isSharedProjectionDirty = false;
          this.isTransformDirty = false;
          this.updateManuallyBlocked = false;
          this.updateBlockedByResize = false;
          this.isUpdating = false;
          this.isSVG = false;
          this.needsReset = false;
          this.shouldResetTransform = false;
          this.treeScale = { x: 1, y: 1 };
          this.eventHandlers = /* @__PURE__ */ new Map();
          this.hasTreeAnimated = false;
          this.updateScheduled = false;
          this.checkUpdateFailed = () => {
            if (this.isUpdating) {
              this.isUpdating = false;
              this.clearAllSnapshots();
            }
          };
          this.updateProjection = () => {
            projectionFrameData.totalNodes = projectionFrameData.resolvedTargetDeltas = projectionFrameData.recalculatedProjection = 0;
            this.nodes.forEach(propagateDirtyNodes);
            this.nodes.forEach(resolveTargetDelta);
            this.nodes.forEach(calcProjection);
            this.nodes.forEach(cleanDirtyNodes);
            record(projectionFrameData);
          };
          this.hasProjected = false;
          this.isVisible = true;
          this.animationProgress = 0;
          this.sharedNodes = /* @__PURE__ */ new Map();
          this.latestValues = latestValues;
          this.root = parent ? parent.root || parent : this;
          this.path = parent ? [...parent.path, parent] : [];
          this.parent = parent;
          this.depth = parent ? parent.depth + 1 : 0;
          for (let i = 0; i < this.path.length; i++) {
            this.path[i].shouldResetTransform = true;
          }
          if (this.root === this)
            this.nodes = new FlatTree();
        }
        addEventListener(name, handler) {
          if (!this.eventHandlers.has(name)) {
            this.eventHandlers.set(name, new indexLegacy.SubscriptionManager());
          }
          return this.eventHandlers.get(name).add(handler);
        }
        notifyListeners(name, ...args) {
          const subscriptionManager = this.eventHandlers.get(name);
          subscriptionManager && subscriptionManager.notify(...args);
        }
        hasListeners(name) {
          return this.eventHandlers.has(name);
        }
        mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {
          if (this.instance)
            return;
          this.isSVG = indexLegacy.isSVGElement(instance);
          this.instance = instance;
          const { layoutId, layout: layout2, visualElement } = this.options;
          if (visualElement && !visualElement.current) {
            visualElement.mount(instance);
          }
          this.root.nodes.add(this);
          this.parent && this.parent.children.add(this);
          if (isLayoutDirty && (layout2 || layoutId)) {
            this.isLayoutDirty = true;
          }
          if (attachResizeListener) {
            let cancelDelay;
            const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
            attachResizeListener(instance, () => {
              this.root.updateBlockedByResize = true;
              cancelDelay && cancelDelay();
              cancelDelay = indexLegacy.delay(resizeUnblockUpdate, 250);
              if (globalProjectionState.hasAnimatedSinceResize) {
                globalProjectionState.hasAnimatedSinceResize = false;
                this.nodes.forEach(finishAnimation);
              }
            });
          }
          if (layoutId) {
            this.root.registerSharedNode(layoutId, this);
          }
          if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
            this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
              if (this.isTreeAnimationBlocked()) {
                this.target = void 0;
                this.relativeTarget = void 0;
                return;
              }
              const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
              const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
              const targetChanged = !this.targetLayout || !boxEquals(this.targetLayout, newLayout) || hasRelativeTargetChanged;
              const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
              if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
                if (this.resumeFrom) {
                  this.resumingFrom = this.resumeFrom;
                  this.resumingFrom.resumingFrom = void 0;
                }
                this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
                const animationOptions = {
                  ...indexLegacy.getValueTransition(layoutTransition, "layout"),
                  onPlay: onLayoutAnimationStart,
                  onComplete: onLayoutAnimationComplete
                };
                if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
                  animationOptions.delay = 0;
                  animationOptions.type = false;
                }
                this.startAnimation(animationOptions);
              } else {
                if (!hasLayoutChanged) {
                  finishAnimation(this);
                }
                if (this.isLead() && this.options.onExitComplete) {
                  this.options.onExitComplete();
                }
              }
              this.targetLayout = newLayout;
            });
          }
        }
        unmount() {
          this.options.layoutId && this.willUpdate();
          this.root.nodes.remove(this);
          const stack = this.getStack();
          stack && stack.remove(this);
          this.parent && this.parent.children.delete(this);
          this.instance = void 0;
          indexLegacy.cancelFrame(this.updateProjection);
        }
        blockUpdate() {
          this.updateManuallyBlocked = true;
        }
        unblockUpdate() {
          this.updateManuallyBlocked = false;
        }
        isUpdateBlocked() {
          return this.updateManuallyBlocked || this.updateBlockedByResize;
        }
        isTreeAnimationBlocked() {
          return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
        }
        startUpdate() {
          if (this.isUpdateBlocked())
            return;
          this.isUpdating = true;
          this.nodes && this.nodes.forEach(resetRotation);
          this.animationId++;
        }
        getTransformTemplate() {
          const { visualElement } = this.options;
          return visualElement && visualElement.getProps().transformTemplate;
        }
        willUpdate(shouldNotifyListeners = true) {
          this.root.hasTreeAnimated = true;
          if (this.root.isUpdateBlocked()) {
            this.options.onExitComplete && this.options.onExitComplete();
            return;
          }
          !this.root.isUpdating && this.root.startUpdate();
          if (this.isLayoutDirty)
            return;
          this.isLayoutDirty = true;
          for (let i = 0; i < this.path.length; i++) {
            const node = this.path[i];
            node.shouldResetTransform = true;
            node.updateScroll("snapshot");
            if (node.options.layoutRoot) {
              node.willUpdate(false);
            }
          }
          const { layoutId, layout: layout2 } = this.options;
          if (layoutId === void 0 && !layout2)
            return;
          const transformTemplate = this.getTransformTemplate();
          this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
          this.updateSnapshot();
          shouldNotifyListeners && this.notifyListeners("willUpdate");
        }
        update() {
          this.updateScheduled = false;
          const updateWasBlocked = this.isUpdateBlocked();
          if (updateWasBlocked) {
            this.unblockUpdate();
            this.clearAllSnapshots();
            this.nodes.forEach(clearMeasurements);
            return;
          }
          if (!this.isUpdating) {
            this.nodes.forEach(clearIsLayoutDirty);
          }
          this.isUpdating = false;
          this.nodes.forEach(resetTransformStyle);
          this.nodes.forEach(updateLayout);
          this.nodes.forEach(notifyLayoutUpdate);
          this.clearAllSnapshots();
          const now = performance.now();
          indexLegacy.frameData.delta = indexLegacy.clamp(0, 1e3 / 60, now - indexLegacy.frameData.timestamp);
          indexLegacy.frameData.timestamp = now;
          indexLegacy.frameData.isProcessing = true;
          indexLegacy.steps.update.process(indexLegacy.frameData);
          indexLegacy.steps.preRender.process(indexLegacy.frameData);
          indexLegacy.steps.render.process(indexLegacy.frameData);
          indexLegacy.frameData.isProcessing = false;
        }
        didUpdate() {
          if (!this.updateScheduled) {
            this.updateScheduled = true;
            queueMicrotask(() => this.update());
          }
        }
        clearAllSnapshots() {
          this.nodes.forEach(clearSnapshot);
          this.sharedNodes.forEach(removeLeadSnapshots);
        }
        scheduleUpdateProjection() {
          indexLegacy.frame.preRender(this.updateProjection, false, true);
        }
        scheduleCheckAfterUnmount() {
          indexLegacy.frame.postRender(() => {
            if (this.isLayoutDirty) {
              this.root.didUpdate();
            } else {
              this.root.checkUpdateFailed();
            }
          });
        }
        updateSnapshot() {
          if (this.snapshot || !this.instance)
            return;
          this.snapshot = this.measure();
        }
        updateLayout() {
          if (!this.instance)
            return;
          this.updateScroll();
          if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
            return;
          }
          if (this.resumeFrom && !this.resumeFrom.instance) {
            for (let i = 0; i < this.path.length; i++) {
              const node = this.path[i];
              node.updateScroll();
            }
          }
          const prevLayout = this.layout;
          this.layout = this.measure(false);
          this.layoutCorrected = indexLegacy.createBox();
          this.isLayoutDirty = false;
          this.projectionDelta = void 0;
          this.notifyListeners("measure", this.layout.layoutBox);
          const { visualElement } = this.options;
          visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
        }
        updateScroll(phase = "measure") {
          let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
          if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
            needsMeasurement = false;
          }
          if (needsMeasurement) {
            this.scroll = {
              animationId: this.root.animationId,
              phase,
              isRoot: checkIsScrollRoot(this.instance),
              offset: measureScroll(this.instance)
            };
          }
        }
        resetTransform() {
          if (!resetTransform)
            return;
          const isResetRequested = this.isLayoutDirty || this.shouldResetTransform;
          const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
          const transformTemplate = this.getTransformTemplate();
          const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
          const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
          if (isResetRequested && (hasProjection || indexLegacy.hasTransform(this.latestValues) || transformTemplateHasChanged)) {
            resetTransform(this.instance, transformTemplateValue);
            this.shouldResetTransform = false;
            this.scheduleRender();
          }
        }
        measure(removeTransform = true) {
          const pageBox = this.measurePageBox();
          let layoutBox = this.removeElementScroll(pageBox);
          if (removeTransform) {
            layoutBox = this.removeTransform(layoutBox);
          }
          roundBox(layoutBox);
          return {
            animationId: this.root.animationId,
            measuredBox: pageBox,
            layoutBox,
            latestValues: {},
            source: this.id
          };
        }
        measurePageBox() {
          const { visualElement } = this.options;
          if (!visualElement)
            return indexLegacy.createBox();
          const box = visualElement.measureViewportBox();
          const { scroll } = this.root;
          if (scroll) {
            indexLegacy.translateAxis(box.x, scroll.offset.x);
            indexLegacy.translateAxis(box.y, scroll.offset.y);
          }
          return box;
        }
        removeElementScroll(box) {
          const boxWithoutScroll = indexLegacy.createBox();
          copyBoxInto(boxWithoutScroll, box);
          for (let i = 0; i < this.path.length; i++) {
            const node = this.path[i];
            const { scroll, options } = node;
            if (node !== this.root && scroll && options.layoutScroll) {
              if (scroll.isRoot) {
                copyBoxInto(boxWithoutScroll, box);
                const { scroll: rootScroll } = this.root;
                if (rootScroll) {
                  indexLegacy.translateAxis(boxWithoutScroll.x, -rootScroll.offset.x);
                  indexLegacy.translateAxis(boxWithoutScroll.y, -rootScroll.offset.y);
                }
              }
              indexLegacy.translateAxis(boxWithoutScroll.x, scroll.offset.x);
              indexLegacy.translateAxis(boxWithoutScroll.y, scroll.offset.y);
            }
          }
          return boxWithoutScroll;
        }
        applyTransform(box, transformOnly = false) {
          const withTransforms = indexLegacy.createBox();
          copyBoxInto(withTransforms, box);
          for (let i = 0; i < this.path.length; i++) {
            const node = this.path[i];
            if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
              indexLegacy.transformBox(withTransforms, {
                x: -node.scroll.offset.x,
                y: -node.scroll.offset.y
              });
            }
            if (!indexLegacy.hasTransform(node.latestValues))
              continue;
            indexLegacy.transformBox(withTransforms, node.latestValues);
          }
          if (indexLegacy.hasTransform(this.latestValues)) {
            indexLegacy.transformBox(withTransforms, this.latestValues);
          }
          return withTransforms;
        }
        removeTransform(box) {
          const boxWithoutTransform = indexLegacy.createBox();
          copyBoxInto(boxWithoutTransform, box);
          for (let i = 0; i < this.path.length; i++) {
            const node = this.path[i];
            if (!node.instance)
              continue;
            if (!indexLegacy.hasTransform(node.latestValues))
              continue;
            indexLegacy.hasScale(node.latestValues) && node.updateSnapshot();
            const sourceBox = indexLegacy.createBox();
            const nodeBox = node.measurePageBox();
            copyBoxInto(sourceBox, nodeBox);
            removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);
          }
          if (indexLegacy.hasTransform(this.latestValues)) {
            removeBoxTransforms(boxWithoutTransform, this.latestValues);
          }
          return boxWithoutTransform;
        }
        setTargetDelta(delta) {
          this.targetDelta = delta;
          this.root.scheduleUpdateProjection();
          this.isProjectionDirty = true;
        }
        setOptions(options) {
          this.options = {
            ...this.options,
            ...options,
            crossfade: options.crossfade !== void 0 ? options.crossfade : true
          };
        }
        clearMeasurements() {
          this.scroll = void 0;
          this.layout = void 0;
          this.snapshot = void 0;
          this.prevTransformTemplateValue = void 0;
          this.targetDelta = void 0;
          this.target = void 0;
          this.isLayoutDirty = false;
        }
        forceRelativeParentToResolveTarget() {
          if (!this.relativeParent)
            return;
          if (this.relativeParent.resolvedRelativeTargetAt !== indexLegacy.frameData.timestamp) {
            this.relativeParent.resolveTargetDelta(true);
          }
        }
        resolveTargetDelta(forceRecalculation = false) {
          var _a;
          const lead = this.getLead();
          this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
          this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
          this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
          const isShared = Boolean(this.resumingFrom) || this !== lead;
          const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) || this.attemptToResolveRelativeTarget);
          if (canSkip)
            return;
          const { layout: layout2, layoutId } = this.options;
          if (!this.layout || !(layout2 || layoutId))
            return;
          this.resolvedRelativeTargetAt = indexLegacy.frameData.timestamp;
          if (!this.targetDelta && !this.relativeTarget) {
            const relativeParent = this.getClosestProjectingParent();
            if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
              this.relativeParent = relativeParent;
              this.forceRelativeParentToResolveTarget();
              this.relativeTarget = indexLegacy.createBox();
              this.relativeTargetOrigin = indexLegacy.createBox();
              calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
              copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
            } else {
              this.relativeParent = this.relativeTarget = void 0;
            }
          }
          if (!this.relativeTarget && !this.targetDelta)
            return;
          if (!this.target) {
            this.target = indexLegacy.createBox();
            this.targetWithTransforms = indexLegacy.createBox();
          }
          if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
            this.forceRelativeParentToResolveTarget();
            calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
          } else if (this.targetDelta) {
            if (Boolean(this.resumingFrom)) {
              this.target = this.applyTransform(this.layout.layoutBox);
            } else {
              copyBoxInto(this.target, this.layout.layoutBox);
            }
            indexLegacy.applyBoxDelta(this.target, this.targetDelta);
          } else {
            copyBoxInto(this.target, this.layout.layoutBox);
          }
          if (this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = false;
            const relativeParent = this.getClosestProjectingParent();
            if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
              this.relativeParent = relativeParent;
              this.forceRelativeParentToResolveTarget();
              this.relativeTarget = indexLegacy.createBox();
              this.relativeTargetOrigin = indexLegacy.createBox();
              calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
              copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
            } else {
              this.relativeParent = this.relativeTarget = void 0;
            }
          }
          projectionFrameData.resolvedTargetDeltas++;
        }
        getClosestProjectingParent() {
          if (!this.parent || indexLegacy.hasScale(this.parent.latestValues) || indexLegacy.has2DTranslate(this.parent.latestValues)) {
            return void 0;
          }
          if (this.parent.isProjecting()) {
            return this.parent;
          } else {
            return this.parent.getClosestProjectingParent();
          }
        }
        isProjecting() {
          return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
        }
        calcProjection() {
          var _a;
          const lead = this.getLead();
          const isShared = Boolean(this.resumingFrom) || this !== lead;
          let canSkip = true;
          if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {
            canSkip = false;
          }
          if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
            canSkip = false;
          }
          if (this.resolvedRelativeTargetAt === indexLegacy.frameData.timestamp) {
            canSkip = false;
          }
          if (canSkip)
            return;
          const { layout: layout2, layoutId } = this.options;
          this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
          if (!this.isTreeAnimating) {
            this.targetDelta = this.relativeTarget = void 0;
          }
          if (!this.layout || !(layout2 || layoutId))
            return;
          copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
          const prevTreeScaleX = this.treeScale.x;
          const prevTreeScaleY = this.treeScale.y;
          indexLegacy.applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
          if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
            lead.target = lead.layout.layoutBox;
          }
          const { target } = lead;
          if (!target) {
            if (this.projectionTransform) {
              this.projectionDelta = indexLegacy.createDelta();
              this.projectionTransform = "none";
              this.scheduleRender();
            }
            return;
          }
          if (!this.projectionDelta) {
            this.projectionDelta = indexLegacy.createDelta();
            this.projectionDeltaWithTransform = indexLegacy.createDelta();
          }
          const prevProjectionTransform = this.projectionTransform;
          calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
          this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);
          if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {
            this.hasProjected = true;
            this.scheduleRender();
            this.notifyListeners("projectionUpdate", target);
          }
          projectionFrameData.recalculatedProjection++;
        }
        hide() {
          this.isVisible = false;
        }
        show() {
          this.isVisible = true;
        }
        scheduleRender(notifyAll = true) {
          this.options.scheduleRender && this.options.scheduleRender();
          if (notifyAll) {
            const stack = this.getStack();
            stack && stack.scheduleRender();
          }
          if (this.resumingFrom && !this.resumingFrom.instance) {
            this.resumingFrom = void 0;
          }
        }
        setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
          const snapshot = this.snapshot;
          const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
          const mixedValues = { ...this.latestValues };
          const targetDelta = indexLegacy.createDelta();
          if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
            this.relativeTarget = this.relativeTargetOrigin = void 0;
          }
          this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
          const relativeLayout = indexLegacy.createBox();
          const snapshotSource = snapshot ? snapshot.source : void 0;
          const layoutSource = this.layout ? this.layout.source : void 0;
          const isSharedLayoutAnimation = snapshotSource !== layoutSource;
          const stack = this.getStack();
          const isOnlyMember = !stack || stack.members.length <= 1;
          const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
          this.animationProgress = 0;
          let prevRelativeTarget;
          this.mixTargetDelta = (latest) => {
            const progress = latest / 1e3;
            mixAxisDelta(targetDelta.x, delta.x, progress);
            mixAxisDelta(targetDelta.y, delta.y, progress);
            this.setTargetDelta(targetDelta);
            if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
              calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
              mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress);
              if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
                this.isProjectionDirty = false;
              }
              if (!prevRelativeTarget)
                prevRelativeTarget = indexLegacy.createBox();
              copyBoxInto(prevRelativeTarget, this.relativeTarget);
            }
            if (isSharedLayoutAnimation) {
              this.animationValues = mixedValues;
              mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);
            }
            this.root.scheduleUpdateProjection();
            this.scheduleRender();
            this.animationProgress = progress;
          };
          this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
        }
        startAnimation(options) {
          this.notifyListeners("animationStart");
          this.currentAnimation && this.currentAnimation.stop();
          if (this.resumingFrom && this.resumingFrom.currentAnimation) {
            this.resumingFrom.currentAnimation.stop();
          }
          if (this.pendingAnimation) {
            indexLegacy.cancelFrame(this.pendingAnimation);
            this.pendingAnimation = void 0;
          }
          this.pendingAnimation = indexLegacy.frame.update(() => {
            globalProjectionState.hasAnimatedSinceResize = true;
            this.currentAnimation = indexLegacy.animateSingleValue(0, animationTarget, {
              ...options,
              onUpdate: (latest) => {
                this.mixTargetDelta(latest);
                options.onUpdate && options.onUpdate(latest);
              },
              onComplete: () => {
                options.onComplete && options.onComplete();
                this.completeAnimation();
              }
            });
            if (this.resumingFrom) {
              this.resumingFrom.currentAnimation = this.currentAnimation;
            }
            this.pendingAnimation = void 0;
          });
        }
        completeAnimation() {
          if (this.resumingFrom) {
            this.resumingFrom.currentAnimation = void 0;
            this.resumingFrom.preserveOpacity = void 0;
          }
          const stack = this.getStack();
          stack && stack.exitAnimationComplete();
          this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
          this.notifyListeners("animationComplete");
        }
        finishAnimation() {
          if (this.currentAnimation) {
            this.mixTargetDelta && this.mixTargetDelta(animationTarget);
            this.currentAnimation.stop();
          }
          this.completeAnimation();
        }
        applyTransformsToTarget() {
          const lead = this.getLead();
          let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
          if (!targetWithTransforms || !target || !layout2)
            return;
          if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
            target = this.target || indexLegacy.createBox();
            const xLength = calcLength(this.layout.layoutBox.x);
            target.x.min = lead.target.x.min;
            target.x.max = target.x.min + xLength;
            const yLength = calcLength(this.layout.layoutBox.y);
            target.y.min = lead.target.y.min;
            target.y.max = target.y.min + yLength;
          }
          copyBoxInto(targetWithTransforms, target);
          indexLegacy.transformBox(targetWithTransforms, latestValues);
          calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
        }
        registerSharedNode(layoutId, node) {
          if (!this.sharedNodes.has(layoutId)) {
            this.sharedNodes.set(layoutId, new NodeStack());
          }
          const stack = this.sharedNodes.get(layoutId);
          stack.add(node);
          const config = node.options.initialPromotionConfig;
          node.promote({
            transition: config ? config.transition : void 0,
            preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node) : void 0
          });
        }
        isLead() {
          const stack = this.getStack();
          return stack ? stack.lead === this : true;
        }
        getLead() {
          var _a;
          const { layoutId } = this.options;
          return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;
        }
        getPrevLead() {
          var _a;
          const { layoutId } = this.options;
          return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : void 0;
        }
        getStack() {
          const { layoutId } = this.options;
          if (layoutId)
            return this.root.sharedNodes.get(layoutId);
        }
        promote({ needsReset, transition, preserveFollowOpacity } = {}) {
          const stack = this.getStack();
          if (stack)
            stack.promote(this, preserveFollowOpacity);
          if (needsReset) {
            this.projectionDelta = void 0;
            this.needsReset = true;
          }
          if (transition)
            this.setOptions({ transition });
        }
        relegate() {
          const stack = this.getStack();
          if (stack) {
            return stack.relegate(this);
          } else {
            return false;
          }
        }
        resetRotation() {
          const { visualElement } = this.options;
          if (!visualElement)
            return;
          let hasRotate = false;
          const { latestValues } = visualElement;
          if (latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ) {
            hasRotate = true;
          }
          if (!hasRotate)
            return;
          const resetValues = {};
          for (let i = 0; i < transformAxes.length; i++) {
            const key = "rotate" + transformAxes[i];
            if (latestValues[key]) {
              resetValues[key] = latestValues[key];
              visualElement.setStaticValue(key, 0);
            }
          }
          visualElement.render();
          for (const key in resetValues) {
            visualElement.setStaticValue(key, resetValues[key]);
          }
          visualElement.scheduleRender();
        }
        getProjectionStyles(styleProp = {}) {
          var _a, _b;
          const styles = {};
          if (!this.instance || this.isSVG)
            return styles;
          if (!this.isVisible) {
            return { visibility: "hidden" };
          } else {
            styles.visibility = "";
          }
          const transformTemplate = this.getTransformTemplate();
          if (this.needsReset) {
            this.needsReset = false;
            styles.opacity = "";
            styles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
            styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
            return styles;
          }
          const lead = this.getLead();
          if (!this.projectionDelta || !this.layout || !lead.target) {
            const emptyStyles = {};
            if (this.options.layoutId) {
              emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
              emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
            }
            if (this.hasProjected && !indexLegacy.hasTransform(this.latestValues)) {
              emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
              this.hasProjected = false;
            }
            return emptyStyles;
          }
          const valuesToRender = lead.animationValues || lead.latestValues;
          this.applyTransformsToTarget();
          styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
          if (transformTemplate) {
            styles.transform = transformTemplate(valuesToRender, styles.transform);
          }
          const { x, y } = this.projectionDelta;
          styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
          if (lead.animationValues) {
            styles.opacity = lead === this ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
          } else {
            styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
          }
          for (const key in indexLegacy.scaleCorrectors) {
            if (valuesToRender[key] === void 0)
              continue;
            const { correct, applyTo } = indexLegacy.scaleCorrectors[key];
            const corrected = styles.transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
            if (applyTo) {
              const num = applyTo.length;
              for (let i = 0; i < num; i++) {
                styles[applyTo[i]] = corrected;
              }
            } else {
              styles[key] = corrected;
            }
          }
          if (this.options.layoutId) {
            styles.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || "" : "none";
          }
          return styles;
        }
        clearSnapshot() {
          this.resumeFrom = this.snapshot = void 0;
        }
        resetTree() {
          this.root.nodes.forEach((node) => {
            var _a;
            return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();
          });
          this.root.nodes.forEach(clearMeasurements);
          this.root.sharedNodes.clear();
        }
      };
    }
    function updateLayout(node) {
      node.updateLayout();
    }
    function notifyLayoutUpdate(node) {
      var _a;
      const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;
      if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
        const { layoutBox: layout2, measuredBox: measuredLayout } = node.layout;
        const { animationType } = node.options;
        const isShared = snapshot.source !== node.layout.source;
        if (animationType === "size") {
          eachAxis((axis) => {
            const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
            const length = calcLength(axisSnapshot);
            axisSnapshot.min = layout2[axis].min;
            axisSnapshot.max = axisSnapshot.min + length;
          });
        } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
          eachAxis((axis) => {
            const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
            const length = calcLength(layout2[axis]);
            axisSnapshot.max = axisSnapshot.min + length;
            if (node.relativeTarget && !node.currentAnimation) {
              node.isProjectionDirty = true;
              node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
            }
          });
        }
        const layoutDelta = indexLegacy.createDelta();
        calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
        const visualDelta = indexLegacy.createDelta();
        if (isShared) {
          calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
        } else {
          calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
        }
        const hasLayoutChanged = !isDeltaZero(layoutDelta);
        let hasRelativeTargetChanged = false;
        if (!node.resumeFrom) {
          const relativeParent = node.getClosestProjectingParent();
          if (relativeParent && !relativeParent.resumeFrom) {
            const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
            if (parentSnapshot && parentLayout) {
              const relativeSnapshot = indexLegacy.createBox();
              calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
              const relativeLayout = indexLegacy.createBox();
              calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
              if (!boxEquals(relativeSnapshot, relativeLayout)) {
                hasRelativeTargetChanged = true;
              }
              if (relativeParent.options.layoutRoot) {
                node.relativeTarget = relativeLayout;
                node.relativeTargetOrigin = relativeSnapshot;
                node.relativeParent = relativeParent;
              }
            }
          }
        }
        node.notifyListeners("didUpdate", {
          layout: layout2,
          snapshot,
          delta: visualDelta,
          layoutDelta,
          hasLayoutChanged,
          hasRelativeTargetChanged
        });
      } else if (node.isLead()) {
        const { onExitComplete } = node.options;
        onExitComplete && onExitComplete();
      }
      node.options.transition = void 0;
    }
    function propagateDirtyNodes(node) {
      projectionFrameData.totalNodes++;
      if (!node.parent)
        return;
      if (!node.isProjecting()) {
        node.isProjectionDirty = node.parent.isProjectionDirty;
      }
      node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));
      node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
    }
    function cleanDirtyNodes(node) {
      node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
    }
    function clearSnapshot(node) {
      node.clearSnapshot();
    }
    function clearMeasurements(node) {
      node.clearMeasurements();
    }
    function clearIsLayoutDirty(node) {
      node.isLayoutDirty = false;
    }
    function resetTransformStyle(node) {
      const { visualElement } = node.options;
      if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
        visualElement.notify("BeforeLayoutMeasure");
      }
      node.resetTransform();
    }
    function finishAnimation(node) {
      node.finishAnimation();
      node.targetDelta = node.relativeTarget = node.target = void 0;
      node.isProjectionDirty = true;
    }
    function resolveTargetDelta(node) {
      node.resolveTargetDelta();
    }
    function calcProjection(node) {
      node.calcProjection();
    }
    function resetRotation(node) {
      node.resetRotation();
    }
    function removeLeadSnapshots(stack) {
      stack.removeLeadSnapshot();
    }
    function mixAxisDelta(output, delta, p) {
      output.translate = indexLegacy.mix(delta.translate, 0, p);
      output.scale = indexLegacy.mix(delta.scale, 1, p);
      output.origin = delta.origin;
      output.originPoint = delta.originPoint;
    }
    function mixAxis(output, from, to, p) {
      output.min = indexLegacy.mix(from.min, to.min, p);
      output.max = indexLegacy.mix(from.max, to.max, p);
    }
    function mixBox(output, from, to, p) {
      mixAxis(output.x, from.x, to.x, p);
      mixAxis(output.y, from.y, to.y, p);
    }
    function hasOpacityCrossfade(node) {
      return node.animationValues && node.animationValues.opacityExit !== void 0;
    }
    var defaultLayoutTransition = {
      duration: 0.45,
      ease: [0.4, 0, 0.1, 1]
    };
    function roundAxis(axis) {
      axis.min = Math.round(axis.min);
      axis.max = Math.round(axis.max);
    }
    function roundBox(box) {
      roundAxis(box.x);
      roundAxis(box.y);
    }
    function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
      return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
    }
    var DocumentProjectionNode = createProjectionNode({
      attachResizeListener: (ref, notify2) => addDomEvent(ref, "resize", notify2),
      measureScroll: () => ({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop
      }),
      checkIsScrollRoot: () => true
    });
    var rootProjectionNode = {
      current: void 0
    };
    var HTMLProjectionNode = createProjectionNode({
      measureScroll: (instance) => ({
        x: instance.scrollLeft,
        y: instance.scrollTop
      }),
      defaultParent: () => {
        if (!rootProjectionNode.current) {
          const documentNode = new DocumentProjectionNode({});
          documentNode.mount(window);
          documentNode.setOptions({ layoutScroll: true });
          rootProjectionNode.current = documentNode;
        }
        return rootProjectionNode.current;
      },
      resetTransform: (instance, value) => {
        instance.style.transform = value !== void 0 ? value : "none";
      },
      checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
    });
    var notify = (node) => !node.isLayoutDirty && node.willUpdate(false);
    function nodeGroup() {
      const nodes = /* @__PURE__ */ new Set();
      const subscriptions = /* @__PURE__ */ new WeakMap();
      const dirtyAll = () => nodes.forEach(notify);
      return {
        add: (node) => {
          nodes.add(node);
          subscriptions.set(node, node.addEventListener("willUpdate", dirtyAll));
        },
        remove: (node) => {
          nodes.delete(node);
          const unsubscribe = subscriptions.get(node);
          if (unsubscribe) {
            unsubscribe();
            subscriptions.delete(node);
          }
          dirtyAll();
        },
        dirty: dirtyAll
      };
    }
    function pixelsToPercent(pixels, axis) {
      if (axis.max === axis.min)
        return 0;
      return pixels / (axis.max - axis.min) * 100;
    }
    var correctBorderRadius = {
      correct: (latest, node) => {
        if (!node.target)
          return latest;
        if (typeof latest === "string") {
          if (indexLegacy.px.test(latest)) {
            latest = parseFloat(latest);
          } else {
            return latest;
          }
        }
        const x = pixelsToPercent(latest, node.target.x);
        const y = pixelsToPercent(latest, node.target.y);
        return `${x}% ${y}%`;
      }
    };
    var correctBoxShadow = {
      correct: (latest, { treeScale, projectionDelta }) => {
        const original = latest;
        const shadow = indexLegacy.complex.parse(latest);
        if (shadow.length > 5)
          return original;
        const template = indexLegacy.complex.createTransformer(latest);
        const offset = typeof shadow[0] !== "number" ? 1 : 0;
        const xScale = projectionDelta.x.scale * treeScale.x;
        const yScale = projectionDelta.y.scale * treeScale.y;
        shadow[0 + offset] /= xScale;
        shadow[1 + offset] /= yScale;
        const averageScale = indexLegacy.mix(xScale, yScale, 0.5);
        if (typeof shadow[2 + offset] === "number")
          shadow[2 + offset] /= averageScale;
        if (typeof shadow[3 + offset] === "number")
          shadow[3 + offset] /= averageScale;
        return template(shadow);
      }
    };
    function usePresence() {
      const context = React.useContext(PresenceContext);
      if (context === null)
        return [true, null];
      const { isPresent: isPresent2, onExitComplete, register } = context;
      const id2 = React.useId();
      React.useEffect(() => register(id2), []);
      const safeToRemove = () => onExitComplete && onExitComplete(id2);
      return !isPresent2 && onExitComplete ? [false, safeToRemove] : [true];
    }
    function useIsPresent() {
      return isPresent(React.useContext(PresenceContext));
    }
    function isPresent(context) {
      return context === null ? true : context.isPresent;
    }
    var MeasureLayoutWithContext = class extends React__default["default"].Component {
      componentDidMount() {
        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
        const { projection } = visualElement;
        indexLegacy.addScaleCorrector(defaultScaleCorrectors);
        if (projection) {
          if (layoutGroup.group)
            layoutGroup.group.add(projection);
          if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
            switchLayoutGroup.register(projection);
          }
          projection.root.didUpdate();
          projection.addEventListener("animationComplete", () => {
            this.safeToRemove();
          });
          projection.setOptions({
            ...projection.options,
            onExitComplete: () => this.safeToRemove()
          });
        }
        globalProjectionState.hasEverUpdated = true;
      }
      getSnapshotBeforeUpdate(prevProps) {
        const { layoutDependency, visualElement, drag: drag2, isPresent: isPresent2 } = this.props;
        const projection = visualElement.projection;
        if (!projection)
          return null;
        projection.isPresent = isPresent2;
        if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
          projection.willUpdate();
        } else {
          this.safeToRemove();
        }
        if (prevProps.isPresent !== isPresent2) {
          if (isPresent2) {
            projection.promote();
          } else if (!projection.relegate()) {
            indexLegacy.frame.postRender(() => {
              const stack = projection.getStack();
              if (!stack || !stack.members.length) {
                this.safeToRemove();
              }
            });
          }
        }
        return null;
      }
      componentDidUpdate() {
        const { projection } = this.props.visualElement;
        if (projection) {
          projection.root.didUpdate();
          queueMicrotask(() => {
            if (!projection.currentAnimation && projection.isLead()) {
              this.safeToRemove();
            }
          });
        }
      }
      componentWillUnmount() {
        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
        const { projection } = visualElement;
        if (projection) {
          projection.scheduleCheckAfterUnmount();
          if (layoutGroup && layoutGroup.group)
            layoutGroup.group.remove(projection);
          if (promoteContext && promoteContext.deregister)
            promoteContext.deregister(projection);
        }
      }
      safeToRemove() {
        const { safeToRemove } = this.props;
        safeToRemove && safeToRemove();
      }
      render() {
        return null;
      }
    };
    function MeasureLayout(props) {
      const [isPresent2, safeToRemove] = usePresence();
      const layoutGroup = React.useContext(LayoutGroupContext);
      return React__default["default"].createElement(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: React.useContext(SwitchLayoutGroupContext), isPresent: isPresent2, safeToRemove });
    }
    var defaultScaleCorrectors = {
      borderRadius: {
        ...correctBorderRadius,
        applyTo: [
          "borderTopLeftRadius",
          "borderTopRightRadius",
          "borderBottomLeftRadius",
          "borderBottomRightRadius"
        ]
      },
      borderTopLeftRadius: correctBorderRadius,
      borderTopRightRadius: correctBorderRadius,
      borderBottomLeftRadius: correctBorderRadius,
      borderBottomRightRadius: correctBorderRadius,
      boxShadow: correctBoxShadow
    };
    var drag = {
      pan: {
        Feature: PanGesture
      },
      drag: {
        Feature: DragGesture,
        ProjectionNode: HTMLProjectionNode,
        MeasureLayout
      }
    };
    var createDomVisualElement = (Component, options) => {
      return isSVGComponent(Component) ? new indexLegacy.SVGVisualElement(options, { enableHardwareAcceleration: false }) : new indexLegacy.HTMLVisualElement(options, { enableHardwareAcceleration: true });
    };
    var layout = {
      layout: {
        ProjectionNode: HTMLProjectionNode,
        MeasureLayout
      }
    };
    var preloadedFeatures = {
      ...animations,
      ...gestureAnimations,
      ...drag,
      ...layout
    };
    var motion = createMotionProxy((Component, config) => createDomMotionConfig(Component, config, preloadedFeatures, createDomVisualElement));
    function createDomMotionComponent(key) {
      return createMotionComponent(createDomMotionConfig(key, { forwardMotionProps: false }, preloadedFeatures, createDomVisualElement));
    }
    var m = createMotionProxy(createDomMotionConfig);
    function useIsMounted() {
      const isMounted = React.useRef(false);
      useIsomorphicLayoutEffect(() => {
        isMounted.current = true;
        return () => {
          isMounted.current = false;
        };
      }, []);
      return isMounted;
    }
    function useForceUpdate() {
      const isMounted = useIsMounted();
      const [forcedRenderCount, setForcedRenderCount] = React.useState(0);
      const forceRender = React.useCallback(() => {
        isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
      }, [forcedRenderCount]);
      const deferredForceRender = React.useCallback(() => indexLegacy.frame.postRender(forceRender), [forceRender]);
      return [deferredForceRender, forcedRenderCount];
    }
    var PopChildMeasure = class extends React__namespace.Component {
      getSnapshotBeforeUpdate(prevProps) {
        const element = this.props.childRef.current;
        if (element && prevProps.isPresent && !this.props.isPresent) {
          const size = this.props.sizeRef.current;
          size.height = element.offsetHeight || 0;
          size.width = element.offsetWidth || 0;
          size.top = element.offsetTop;
          size.left = element.offsetLeft;
        }
        return null;
      }
      componentDidUpdate() {
      }
      render() {
        return this.props.children;
      }
    };
    function PopChild({ children, isPresent: isPresent2 }) {
      const id2 = React.useId();
      const ref = React.useRef(null);
      const size = React.useRef({
        width: 0,
        height: 0,
        top: 0,
        left: 0
      });
      React.useInsertionEffect(() => {
        const { width, height, top, left } = size.current;
        if (isPresent2 || !ref.current || !width || !height)
          return;
        ref.current.dataset.motionPopId = id2;
        const style = document.createElement("style");
        document.head.appendChild(style);
        if (style.sheet) {
          style.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top}px !important;
            left: ${left}px !important;
          }
        `);
        }
        return () => {
          document.head.removeChild(style);
        };
      }, [isPresent2]);
      return React__namespace.createElement(PopChildMeasure, { isPresent: isPresent2, childRef: ref, sizeRef: size }, React__namespace.cloneElement(children, { ref }));
    }
    var PresenceChild = ({ children, initial, isPresent: isPresent2, onExitComplete, custom, presenceAffectsLayout, mode }) => {
      const presenceChildren = useConstant(newChildrenMap);
      const id2 = React.useId();
      const context = React.useMemo(
        () => ({
          id: id2,
          initial,
          isPresent: isPresent2,
          custom,
          onExitComplete: (childId) => {
            presenceChildren.set(childId, true);
            for (const isComplete of presenceChildren.values()) {
              if (!isComplete)
                return;
            }
            onExitComplete && onExitComplete();
          },
          register: (childId) => {
            presenceChildren.set(childId, false);
            return () => presenceChildren.delete(childId);
          }
        }),
        presenceAffectsLayout ? void 0 : [isPresent2]
      );
      React.useMemo(() => {
        presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
      }, [isPresent2]);
      React__namespace.useEffect(() => {
        !isPresent2 && !presenceChildren.size && onExitComplete && onExitComplete();
      }, [isPresent2]);
      if (mode === "popLayout") {
        children = React__namespace.createElement(PopChild, { isPresent: isPresent2 }, children);
      }
      return React__namespace.createElement(PresenceContext.Provider, { value: context }, children);
    };
    function newChildrenMap() {
      return /* @__PURE__ */ new Map();
    }
    function useUnmountEffect(callback) {
      return React.useEffect(() => () => callback(), []);
    }
    var getChildKey = (child) => child.key || "";
    function updateChildLookup(children, allChildren) {
      children.forEach((child) => {
        const key = getChildKey(child);
        allChildren.set(key, child);
      });
    }
    function onlyElements(children) {
      const filtered = [];
      React.Children.forEach(children, (child) => {
        if (React.isValidElement(child))
          filtered.push(child);
      });
      return filtered;
    }
    var AnimatePresence = ({ children, custom, initial = true, onExitComplete, exitBeforeEnter, presenceAffectsLayout = true, mode = "sync" }) => {
      indexLegacy.invariant(!exitBeforeEnter, "Replace exitBeforeEnter with mode='wait'");
      const forceRender = React.useContext(LayoutGroupContext).forceRender || useForceUpdate()[0];
      const isMounted = useIsMounted();
      const filteredChildren = onlyElements(children);
      let childrenToRender = filteredChildren;
      const exitingChildren = React.useRef(/* @__PURE__ */ new Map()).current;
      const presentChildren = React.useRef(childrenToRender);
      const allChildren = React.useRef(/* @__PURE__ */ new Map()).current;
      const isInitialRender = React.useRef(true);
      useIsomorphicLayoutEffect(() => {
        isInitialRender.current = false;
        updateChildLookup(filteredChildren, allChildren);
        presentChildren.current = childrenToRender;
      });
      useUnmountEffect(() => {
        isInitialRender.current = true;
        allChildren.clear();
        exitingChildren.clear();
      });
      if (isInitialRender.current) {
        return React__namespace.createElement(React__namespace.Fragment, null, childrenToRender.map((child) => React__namespace.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? void 0 : false, presenceAffectsLayout, mode }, child)));
      }
      childrenToRender = [...childrenToRender];
      const presentKeys = presentChildren.current.map(getChildKey);
      const targetKeys = filteredChildren.map(getChildKey);
      const numPresent = presentKeys.length;
      for (let i = 0; i < numPresent; i++) {
        const key = presentKeys[i];
        if (targetKeys.indexOf(key) === -1 && !exitingChildren.has(key)) {
          exitingChildren.set(key, void 0);
        }
      }
      if (mode === "wait" && exitingChildren.size) {
        childrenToRender = [];
      }
      exitingChildren.forEach((component, key) => {
        if (targetKeys.indexOf(key) !== -1)
          return;
        const child = allChildren.get(key);
        if (!child)
          return;
        const insertionIndex = presentKeys.indexOf(key);
        let exitingComponent = component;
        if (!exitingComponent) {
          const onExit = () => {
            allChildren.delete(key);
            exitingChildren.delete(key);
            const removeIndex = presentChildren.current.findIndex((presentChild) => presentChild.key === key);
            presentChildren.current.splice(removeIndex, 1);
            if (!exitingChildren.size) {
              presentChildren.current = filteredChildren;
              if (isMounted.current === false)
                return;
              forceRender();
              onExitComplete && onExitComplete();
            }
          };
          exitingComponent = React__namespace.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom, presenceAffectsLayout, mode }, child);
          exitingChildren.set(key, exitingComponent);
        }
        childrenToRender.splice(insertionIndex, 0, exitingComponent);
      });
      childrenToRender = childrenToRender.map((child) => {
        const key = child.key;
        return exitingChildren.has(key) ? child : React__namespace.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout, mode }, child);
      });
      if (mode === "wait" && childrenToRender.length > 1) {
        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
      }
      return React__namespace.createElement(React__namespace.Fragment, null, exitingChildren.size ? childrenToRender : childrenToRender.map((child) => React.cloneElement(child)));
    };
    function MotionConfig({ children, isValidProp, ...config }) {
      isValidProp && loadExternalIsValidProp(isValidProp);
      config = { ...React.useContext(MotionConfigContext), ...config };
      config.isStatic = useConstant(() => config.isStatic);
      const context = React.useMemo(() => config, [JSON.stringify(config.transition), config.transformPagePoint, config.reducedMotion]);
      return React__namespace.createElement(MotionConfigContext.Provider, { value: context }, children);
    }
    function LazyMotion({ children, features, strict = false }) {
      const [, setIsLoaded] = React.useState(!isLazyBundle(features));
      const loadedRenderer = React.useRef(void 0);
      if (!isLazyBundle(features)) {
        const { renderer, ...loadedFeatures } = features;
        loadedRenderer.current = renderer;
        loadFeatures(loadedFeatures);
      }
      React.useEffect(() => {
        if (isLazyBundle(features)) {
          features().then(({ renderer, ...loadedFeatures }) => {
            loadFeatures(loadedFeatures);
            loadedRenderer.current = renderer;
            setIsLoaded(true);
          });
        }
      }, []);
      return React__namespace.createElement(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict } }, children);
    }
    function isLazyBundle(features) {
      return typeof features === "function";
    }
    var DeprecatedLayoutGroupContext = React.createContext(null);
    var shouldInheritGroup = (inherit) => inherit === true;
    var shouldInheritId = (inherit) => shouldInheritGroup(inherit === true) || inherit === "id";
    var LayoutGroup = ({ children, id: id2, inherit = true }) => {
      const layoutGroupContext = React.useContext(LayoutGroupContext);
      const deprecatedLayoutGroupContext = React.useContext(DeprecatedLayoutGroupContext);
      const [forceRender, key] = useForceUpdate();
      const context = React.useRef(null);
      const upstreamId = layoutGroupContext.id || deprecatedLayoutGroupContext;
      if (context.current === null) {
        if (shouldInheritId(inherit) && upstreamId) {
          id2 = id2 ? upstreamId + "-" + id2 : upstreamId;
        }
        context.current = {
          id: id2,
          group: shouldInheritGroup(inherit) ? layoutGroupContext.group || nodeGroup() : nodeGroup()
        };
      }
      const memoizedContext = React.useMemo(() => ({ ...context.current, forceRender }), [key]);
      return React__namespace.createElement(LayoutGroupContext.Provider, { value: memoizedContext }, children);
    };
    var ReorderContext = React.createContext(null);
    function checkReorder(order, value, offset, velocity) {
      if (!velocity)
        return order;
      const index = order.findIndex((item2) => item2.value === value);
      if (index === -1)
        return order;
      const nextOffset = velocity > 0 ? 1 : -1;
      const nextItem = order[index + nextOffset];
      if (!nextItem)
        return order;
      const item = order[index];
      const nextLayout = nextItem.layout;
      const nextItemCenter = indexLegacy.mix(nextLayout.min, nextLayout.max, 0.5);
      if (nextOffset === 1 && item.layout.max + offset > nextItemCenter || nextOffset === -1 && item.layout.min + offset < nextItemCenter) {
        return indexLegacy.moveItem(order, index, index + nextOffset);
      }
      return order;
    }
    function ReorderGroup({ children, as = "ul", axis = "y", onReorder, values, ...props }, externalRef) {
      const Component = useConstant(() => motion(as));
      const order = [];
      const isReordering = React.useRef(false);
      indexLegacy.invariant(Boolean(values), "Reorder.Group must be provided a values prop");
      const context = {
        axis,
        registerItem: (value, layout2) => {
          if (layout2 && order.findIndex((entry) => value === entry.value) === -1) {
            order.push({ value, layout: layout2[axis] });
            order.sort(compareMin);
          }
        },
        updateOrder: (id2, offset, velocity) => {
          if (isReordering.current)
            return;
          const newOrder = checkReorder(order, id2, offset, velocity);
          if (order !== newOrder) {
            isReordering.current = true;
            onReorder(newOrder.map(getValue).filter((value) => values.indexOf(value) !== -1));
          }
        }
      };
      React.useEffect(() => {
        isReordering.current = false;
      });
      return React__namespace.createElement(
        Component,
        { ...props, ref: externalRef, ignoreStrict: true },
        React__namespace.createElement(ReorderContext.Provider, { value: context }, children)
      );
    }
    var Group = React.forwardRef(ReorderGroup);
    function getValue(item) {
      return item.value;
    }
    function compareMin(a, b) {
      return a.layout.min - b.layout.min;
    }
    function useMotionValue(initial) {
      const value = useConstant(() => indexLegacy.motionValue(initial));
      const { isStatic } = React.useContext(MotionConfigContext);
      if (isStatic) {
        const [, setLatest] = React.useState(initial);
        React.useEffect(() => value.on("change", setLatest), []);
      }
      return value;
    }
    function useCombineMotionValues(values, combineValues) {
      const value = useMotionValue(combineValues());
      const updateValue = () => value.set(combineValues());
      updateValue();
      useIsomorphicLayoutEffect(() => {
        const scheduleUpdate = () => indexLegacy.frame.update(updateValue, false, true);
        const subscriptions = values.map((v) => v.on("change", scheduleUpdate));
        return () => {
          subscriptions.forEach((unsubscribe) => unsubscribe());
          indexLegacy.cancelFrame(updateValue);
        };
      });
      return value;
    }
    function useTransform(input, inputRangeOrTransformer, outputRange, options) {
      const transformer = typeof inputRangeOrTransformer === "function" ? inputRangeOrTransformer : indexLegacy.transform(inputRangeOrTransformer, outputRange, options);
      return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([input], ([latest]) => transformer(latest));
    }
    function useListTransform(values, transformer) {
      const latest = useConstant(() => []);
      return useCombineMotionValues(values, () => {
        latest.length = 0;
        const numValues = values.length;
        for (let i = 0; i < numValues; i++) {
          latest[i] = values[i].get();
        }
        return transformer(latest);
      });
    }
    function useDefaultMotionValue(value, defaultValue = 0) {
      return indexLegacy.isMotionValue(value) ? value : useMotionValue(defaultValue);
    }
    function ReorderItem({ children, style = {}, value, as = "li", onDrag, layout: layout2 = true, ...props }, externalRef) {
      const Component = useConstant(() => motion(as));
      const context = React.useContext(ReorderContext);
      const point = {
        x: useDefaultMotionValue(style.x),
        y: useDefaultMotionValue(style.y)
      };
      const zIndex = useTransform([point.x, point.y], ([latestX, latestY]) => latestX || latestY ? 1 : "unset");
      const measuredLayout = React.useRef(null);
      indexLegacy.invariant(Boolean(context), "Reorder.Item must be a child of Reorder.Group");
      const { axis, registerItem, updateOrder } = context;
      React.useEffect(() => {
        registerItem(value, measuredLayout.current);
      }, [context]);
      return React__namespace.createElement(Component, { drag: axis, ...props, dragSnapToOrigin: true, style: { ...style, x: point.x, y: point.y, zIndex }, layout: layout2, onDrag: (event, gesturePoint) => {
        const { velocity } = gesturePoint;
        velocity[axis] && updateOrder(value, point[axis].get(), velocity[axis]);
        onDrag && onDrag(event, gesturePoint);
      }, onLayoutMeasure: (measured) => {
        measuredLayout.current = measured;
      }, ref: externalRef, ignoreStrict: true }, children);
    }
    var Item = React.forwardRef(ReorderItem);
    var Reorder = {
      Group,
      Item
    };
    var domAnimation = {
      renderer: createDomVisualElement,
      ...animations,
      ...gestureAnimations
    };
    var domMax = {
      ...domAnimation,
      ...drag,
      ...layout
    };
    function useMotionTemplate(fragments, ...values) {
      const numFragments = fragments.length;
      function buildValue() {
        let output = ``;
        for (let i = 0; i < numFragments; i++) {
          output += fragments[i];
          const value = values[i];
          if (value) {
            output += indexLegacy.isMotionValue(value) ? value.get() : value;
          }
        }
        return output;
      }
      return useCombineMotionValues(values.filter(indexLegacy.isMotionValue), buildValue);
    }
    function useSpring(source, config = {}) {
      const { isStatic } = React.useContext(MotionConfigContext);
      const activeSpringAnimation = React.useRef(null);
      const value = useMotionValue(indexLegacy.isMotionValue(source) ? source.get() : source);
      const stopAnimation2 = () => {
        if (activeSpringAnimation.current) {
          activeSpringAnimation.current.stop();
        }
      };
      React.useInsertionEffect(() => {
        return value.attach((v, set) => {
          if (isStatic)
            return set(v);
          stopAnimation2();
          activeSpringAnimation.current = indexLegacy.animateValue({
            keyframes: [value.get(), v],
            velocity: value.getVelocity(),
            type: "spring",
            restDelta: 1e-3,
            restSpeed: 0.01,
            ...config,
            onUpdate: set
          });
          if (!indexLegacy.frameData.isProcessing) {
            const delta = performance.now() - indexLegacy.frameData.timestamp;
            if (delta < 30) {
              activeSpringAnimation.current.time = indexLegacy.millisecondsToSeconds(delta);
            }
          }
          return value.get();
        }, stopAnimation2);
      }, [JSON.stringify(config)]);
      useIsomorphicLayoutEffect(() => {
        if (indexLegacy.isMotionValue(source)) {
          return source.on("change", (v) => value.set(parseFloat(v)));
        }
      }, [value]);
      return value;
    }
    function useMotionValueEvent(value, event, callback) {
      React.useInsertionEffect(() => value.on(event, callback), [value, event, callback]);
    }
    function useVelocity(value) {
      const velocity = useMotionValue(value.getVelocity());
      useMotionValueEvent(value, "velocityChange", (newVelocity) => {
        velocity.set(newVelocity);
      });
      return velocity;
    }
    function refWarning(name, ref) {
      indexLegacy.warning(Boolean(!ref || ref.current), `You have defined a ${name} options but the provided ref is not yet hydrated, probably because it's defined higher up the tree. Try calling useScroll() in the same component as the ref, or setting its \`layoutEffect: false\` option.`);
    }
    var createScrollMotionValues = () => ({
      scrollX: indexLegacy.motionValue(0),
      scrollY: indexLegacy.motionValue(0),
      scrollXProgress: indexLegacy.motionValue(0),
      scrollYProgress: indexLegacy.motionValue(0)
    });
    function useScroll({ container, target, layoutEffect = true, ...options } = {}) {
      const values = useConstant(createScrollMotionValues);
      const useLifecycleEffect = layoutEffect ? useIsomorphicLayoutEffect : React.useEffect;
      useLifecycleEffect(() => {
        refWarning("target", target);
        refWarning("container", container);
        return indexLegacy.scroll(({ x, y }) => {
          values.scrollX.set(x.current);
          values.scrollXProgress.set(x.progress);
          values.scrollY.set(y.current);
          values.scrollYProgress.set(y.progress);
        }, {
          ...options,
          container: (container === null || container === void 0 ? void 0 : container.current) || void 0,
          target: (target === null || target === void 0 ? void 0 : target.current) || void 0
        });
      }, []);
      return values;
    }
    function useElementScroll(ref) {
      if (true) {
        indexLegacy.warnOnce(false, "useElementScroll is deprecated. Convert to useScroll({ container: ref }).");
      }
      return useScroll({ container: ref });
    }
    function useViewportScroll() {
      if (true) {
        indexLegacy.warnOnce(false, "useViewportScroll is deprecated. Convert to useScroll().");
      }
      return useScroll();
    }
    function useAnimationFrame(callback) {
      const initialTimestamp = React.useRef(0);
      const { isStatic } = React.useContext(MotionConfigContext);
      React.useEffect(() => {
        if (isStatic)
          return;
        const provideTimeSinceStart = ({ timestamp, delta }) => {
          if (!initialTimestamp.current)
            initialTimestamp.current = timestamp;
          callback(timestamp - initialTimestamp.current, delta);
        };
        indexLegacy.frame.update(provideTimeSinceStart, true);
        return () => indexLegacy.cancelFrame(provideTimeSinceStart);
      }, [callback]);
    }
    function useTime() {
      const time = useMotionValue(0);
      useAnimationFrame((t) => time.set(t));
      return time;
    }
    var WillChangeMotionValue = class extends indexLegacy.MotionValue {
      constructor() {
        super(...arguments);
        this.members = [];
        this.transforms = /* @__PURE__ */ new Set();
      }
      add(name) {
        let memberName;
        if (indexLegacy.transformProps.has(name)) {
          this.transforms.add(name);
          memberName = "transform";
        } else if (!name.startsWith("origin") && !indexLegacy.isCSSVariableName(name) && name !== "willChange") {
          memberName = indexLegacy.camelToDash(name);
        }
        if (memberName) {
          indexLegacy.addUniqueItem(this.members, memberName);
          this.update();
        }
      }
      remove(name) {
        if (indexLegacy.transformProps.has(name)) {
          this.transforms.delete(name);
          if (!this.transforms.size) {
            indexLegacy.removeItem(this.members, "transform");
          }
        } else {
          indexLegacy.removeItem(this.members, indexLegacy.camelToDash(name));
        }
        this.update();
      }
      update() {
        this.set(this.members.length ? this.members.join(", ") : "auto");
      }
    };
    function useWillChange() {
      return useConstant(() => new WillChangeMotionValue("auto"));
    }
    function useReducedMotion() {
      !indexLegacy.hasReducedMotionListener.current && indexLegacy.initPrefersReducedMotion();
      const [shouldReduceMotion] = React.useState(indexLegacy.prefersReducedMotion.current);
      if (true) {
        indexLegacy.warnOnce(shouldReduceMotion !== true, "You have Reduced Motion enabled on your device. Animations may not appear as expected.");
      }
      return shouldReduceMotion;
    }
    function useReducedMotionConfig() {
      const reducedMotionPreference = useReducedMotion();
      const { reducedMotion } = React.useContext(MotionConfigContext);
      if (reducedMotion === "never") {
        return false;
      } else if (reducedMotion === "always") {
        return true;
      } else {
        return reducedMotionPreference;
      }
    }
    function stopAnimation(visualElement) {
      visualElement.values.forEach((value) => value.stop());
    }
    function animationControls() {
      let hasMounted = false;
      const subscribers = /* @__PURE__ */ new Set();
      const controls = {
        subscribe(visualElement) {
          subscribers.add(visualElement);
          return () => void subscribers.delete(visualElement);
        },
        start(definition, transitionOverride) {
          indexLegacy.invariant(hasMounted, "controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.");
          const animations2 = [];
          subscribers.forEach((visualElement) => {
            animations2.push(animateVisualElement(visualElement, definition, {
              transitionOverride
            }));
          });
          return Promise.all(animations2);
        },
        set(definition) {
          indexLegacy.invariant(hasMounted, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.");
          return subscribers.forEach((visualElement) => {
            indexLegacy.setValues(visualElement, definition);
          });
        },
        stop() {
          subscribers.forEach((visualElement) => {
            stopAnimation(visualElement);
          });
        },
        mount() {
          hasMounted = true;
          return () => {
            hasMounted = false;
            controls.stop();
          };
        }
      };
      return controls;
    }
    function useAnimate() {
      const scope = useConstant(() => ({
        current: null,
        animations: []
      }));
      const animate = useConstant(() => indexLegacy.createScopedAnimate(scope));
      useUnmountEffect(() => {
        scope.animations.forEach((animation) => animation.stop());
      });
      return [scope, animate];
    }
    function useAnimationControls() {
      const controls = useConstant(animationControls);
      useIsomorphicLayoutEffect(controls.mount, []);
      return controls;
    }
    var useAnimation = useAnimationControls;
    function useCycle(...items) {
      const index = React.useRef(0);
      const [item, setItem] = React.useState(items[index.current]);
      const runCycle = React.useCallback(
        (next) => {
          index.current = typeof next !== "number" ? indexLegacy.wrap(0, items.length, index.current + 1) : next;
          setItem(items[index.current]);
        },
        [items.length, ...items]
      );
      return [item, runCycle];
    }
    function useInView(ref, { root, margin, amount, once = false } = {}) {
      const [isInView, setInView] = React.useState(false);
      React.useEffect(() => {
        if (!ref.current || once && isInView)
          return;
        const onEnter = () => {
          setInView(true);
          return once ? void 0 : () => setInView(false);
        };
        const options = {
          root: root && root.current || void 0,
          margin,
          amount: amount === "some" ? "any" : amount
        };
        return indexLegacy.inView(ref.current, onEnter, options);
      }, [root, ref, margin, once]);
      return isInView;
    }
    var DragControls = class {
      constructor() {
        this.componentControls = /* @__PURE__ */ new Set();
      }
      subscribe(controls) {
        this.componentControls.add(controls);
        return () => this.componentControls.delete(controls);
      }
      start(event, options) {
        this.componentControls.forEach((controls) => {
          controls.start(event.nativeEvent || event, options);
        });
      }
    };
    var createDragControls = () => new DragControls();
    function useDragControls() {
      return useConstant(createDragControls);
    }
    function useDomEvent(ref, eventName, handler, options) {
      React.useEffect(() => {
        const element = ref.current;
        if (handler && element) {
          return addDomEvent(element, eventName, handler, options);
        }
      }, [ref, eventName, handler, options]);
    }
    function isMotionComponent(component) {
      return component !== null && typeof component === "object" && motionComponentSymbol in component;
    }
    function unwrapMotionComponent(component) {
      if (isMotionComponent(component)) {
        return component[motionComponentSymbol];
      }
      return void 0;
    }
    function useInstantLayoutTransition() {
      return startTransition;
    }
    function startTransition(callback) {
      if (!rootProjectionNode.current)
        return;
      rootProjectionNode.current.isUpdating = false;
      rootProjectionNode.current.blockUpdate();
      callback && callback();
    }
    function useInstantTransition() {
      const [forceUpdate, forcedRenderCount] = useForceUpdate();
      const startInstantLayoutTransition = useInstantLayoutTransition();
      React.useEffect(() => {
        indexLegacy.frame.postRender(() => indexLegacy.frame.postRender(() => indexLegacy.instantAnimationState.current = false));
      }, [forcedRenderCount]);
      return (callback) => {
        startInstantLayoutTransition(() => {
          indexLegacy.instantAnimationState.current = true;
          forceUpdate();
          callback();
        });
      };
    }
    function useResetProjection() {
      const reset = React__namespace.useCallback(() => {
        const root = rootProjectionNode.current;
        if (!root)
          return;
        root.resetTree();
      }, []);
      return reset;
    }
    var appearStoreId = (id2, value) => `${id2}: ${value}`;
    var appearAnimationStore = /* @__PURE__ */ new Map();
    function handoffOptimizedAppearAnimation(id2, name, value, frame) {
      const storeId = appearStoreId(id2, indexLegacy.transformProps.has(name) ? "transform" : name);
      const appearAnimation = appearAnimationStore.get(storeId);
      if (!appearAnimation)
        return 0;
      const { animation, startTime } = appearAnimation;
      const cancelOptimisedAnimation = () => {
        appearAnimationStore.delete(storeId);
        try {
          animation.cancel();
        } catch (e) {
        }
      };
      if (startTime !== null) {
        const sampledTime = performance.now();
        frame.update(() => {
          if (value.animation) {
            value.animation.time = indexLegacy.millisecondsToSeconds(performance.now() - sampledTime);
          }
        });
        frame.render(cancelOptimisedAnimation);
        return sampledTime - startTime || 0;
      } else {
        cancelOptimisedAnimation();
        return 0;
      }
    }
    function startOptimizedAppearAnimation(element, name, keyframes2, options, onReady) {
      const id2 = element.dataset[indexLegacy.optimizedAppearDataId];
      if (!id2)
        return;
      window.HandoffAppearAnimations = handoffOptimizedAppearAnimation;
      const storeId = appearStoreId(id2, name);
      const readyAnimation = indexLegacy.animateStyle(
        element,
        name,
        [keyframes2[0], keyframes2[0]],
        { duration: 1e4, ease: "linear" }
      );
      appearAnimationStore.set(storeId, {
        animation: readyAnimation,
        startTime: null
      });
      const startAnimation = () => {
        readyAnimation.cancel();
        const appearAnimation = indexLegacy.animateStyle(element, name, keyframes2, options);
        if (document.timeline) {
          appearAnimation.startTime = document.timeline.currentTime;
        }
        appearAnimationStore.set(storeId, {
          animation: appearAnimation,
          startTime: performance.now()
        });
        if (onReady)
          onReady(appearAnimation);
      };
      if (readyAnimation.ready) {
        readyAnimation.ready.then(startAnimation).catch(indexLegacy.noop);
      } else {
        startAnimation();
      }
    }
    var createObject = () => ({});
    var StateVisualElement = class extends indexLegacy.VisualElement {
      build() {
      }
      measureInstanceViewportBox() {
        return indexLegacy.createBox();
      }
      resetTransform() {
      }
      restoreTransform() {
      }
      removeValueFromRenderState() {
      }
      renderInstance() {
      }
      scrapeMotionValuesFromProps() {
        return createObject();
      }
      getBaseTargetFromProps() {
        return void 0;
      }
      readValueFromInstance(_state, key, options) {
        return options.initialState[key] || 0;
      }
      sortInstanceNodePosition() {
        return 0;
      }
      makeTargetAnimatableFromInstance({ transition, transitionEnd, ...target }) {
        const origin = indexLegacy.getOrigin(target, transition || {}, this);
        indexLegacy.checkTargetForNewValues(this, target, origin);
        return { transition, transitionEnd, ...target };
      }
    };
    var useVisualState = makeUseVisualState({
      scrapeMotionValuesFromProps: createObject,
      createRenderState: createObject
    });
    function useAnimatedState(initialState) {
      const [animationState, setAnimationState] = React.useState(initialState);
      const visualState = useVisualState({}, false);
      const element = useConstant(() => {
        return new StateVisualElement({ props: {}, visualState, presenceContext: null }, { initialState });
      });
      React.useEffect(() => {
        element.mount({});
        return () => element.unmount();
      }, [element]);
      React.useEffect(() => {
        element.update({
          onUpdate: (v) => {
            setAnimationState({ ...v });
          }
        }, null);
      }, [setAnimationState, element]);
      const startAnimation = useConstant(() => (animationDefinition) => {
        return animateVisualElement(element, animationDefinition);
      });
      return [animationState, startAnimation];
    }
    var maxScale = 1e5;
    var invertScale = (scale) => scale > 1e-3 ? 1 / scale : maxScale;
    var hasWarned = false;
    function useInvertedScale(scale) {
      let parentScaleX = useMotionValue(1);
      let parentScaleY = useMotionValue(1);
      const { visualElement } = React.useContext(MotionContext);
      indexLegacy.invariant(!!(scale || visualElement), "If no scale values are provided, useInvertedScale must be used within a child of another motion component.");
      indexLegacy.warning(hasWarned, "useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.");
      hasWarned = true;
      if (scale) {
        parentScaleX = scale.scaleX || parentScaleX;
        parentScaleY = scale.scaleY || parentScaleY;
      } else if (visualElement) {
        parentScaleX = visualElement.getValue("scaleX", 1);
        parentScaleY = visualElement.getValue("scaleY", 1);
      }
      const scaleX = useTransform(parentScaleX, invertScale);
      const scaleY = useTransform(parentScaleY, invertScale);
      return { scaleX, scaleY };
    }
    var id = 0;
    var AnimateSharedLayout = ({ children }) => {
      React__namespace.useEffect(() => {
        indexLegacy.invariant(false, "AnimateSharedLayout is deprecated: https://www.framer.com/docs/guide-upgrade/##shared-layout-animations");
      }, []);
      return React__namespace.createElement(LayoutGroup, { id: useConstant(() => `asl-${id++}`) }, children);
    };
    exports.MotionValue = indexLegacy.MotionValue;
    exports.VisualElement = indexLegacy.VisualElement;
    exports.addScaleCorrector = indexLegacy.addScaleCorrector;
    exports.animate = indexLegacy.animate;
    exports.animateValue = indexLegacy.animateValue;
    exports.anticipate = indexLegacy.anticipate;
    exports.backIn = indexLegacy.backIn;
    exports.backInOut = indexLegacy.backInOut;
    exports.backOut = indexLegacy.backOut;
    exports.buildTransform = indexLegacy.buildTransform;
    exports.cancelFrame = indexLegacy.cancelFrame;
    exports.cancelSync = indexLegacy.cancelSync;
    exports.checkTargetForNewValues = indexLegacy.checkTargetForNewValues;
    exports.circIn = indexLegacy.circIn;
    exports.circInOut = indexLegacy.circInOut;
    exports.circOut = indexLegacy.circOut;
    exports.clamp = indexLegacy.clamp;
    exports.color = indexLegacy.color;
    exports.complex = indexLegacy.complex;
    exports.createBox = indexLegacy.createBox;
    exports.createScopedAnimate = indexLegacy.createScopedAnimate;
    exports.cubicBezier = indexLegacy.cubicBezier;
    exports.delay = indexLegacy.delay;
    exports.distance = indexLegacy.distance;
    exports.distance2D = indexLegacy.distance2D;
    exports.easeIn = indexLegacy.easeIn;
    exports.easeInOut = indexLegacy.easeInOut;
    exports.easeOut = indexLegacy.easeOut;
    exports.frame = indexLegacy.frame;
    exports.frameData = indexLegacy.frameData;
    exports.inView = indexLegacy.inView;
    exports.interpolate = indexLegacy.interpolate;
    Object.defineProperty(exports, "invariant", {
      enumerable: true,
      get: function() {
        return indexLegacy.invariant;
      }
    });
    exports.isBrowser = indexLegacy.isBrowser;
    exports.isMotionValue = indexLegacy.isMotionValue;
    exports.mirrorEasing = indexLegacy.mirrorEasing;
    exports.mix = indexLegacy.mix;
    exports.motionValue = indexLegacy.motionValue;
    exports.optimizedAppearDataAttribute = indexLegacy.optimizedAppearDataAttribute;
    exports.pipe = indexLegacy.pipe;
    exports.progress = indexLegacy.progress;
    exports.px = indexLegacy.px;
    exports.reverseEasing = indexLegacy.reverseEasing;
    exports.scroll = indexLegacy.scroll;
    exports.spring = indexLegacy.spring;
    exports.stagger = indexLegacy.stagger;
    exports.steps = indexLegacy.steps;
    exports.stepsOrder = indexLegacy.stepsOrder;
    exports.sync = indexLegacy.sync;
    exports.transform = indexLegacy.transform;
    exports.visualElementStore = indexLegacy.visualElementStore;
    Object.defineProperty(exports, "warning", {
      enumerable: true,
      get: function() {
        return indexLegacy.warning;
      }
    });
    exports.wrap = indexLegacy.wrap;
    exports.AnimatePresence = AnimatePresence;
    exports.AnimateSharedLayout = AnimateSharedLayout;
    exports.DeprecatedLayoutGroupContext = DeprecatedLayoutGroupContext;
    exports.DragControls = DragControls;
    exports.FlatTree = FlatTree;
    exports.LayoutGroup = LayoutGroup;
    exports.LayoutGroupContext = LayoutGroupContext;
    exports.LazyMotion = LazyMotion;
    exports.MotionConfig = MotionConfig;
    exports.MotionConfigContext = MotionConfigContext;
    exports.MotionContext = MotionContext;
    exports.PresenceContext = PresenceContext;
    exports.Reorder = Reorder;
    exports.SwitchLayoutGroupContext = SwitchLayoutGroupContext;
    exports.addPointerEvent = addPointerEvent;
    exports.addPointerInfo = addPointerInfo;
    exports.animateVisualElement = animateVisualElement;
    exports.animationControls = animationControls;
    exports.animations = animations;
    exports.calcLength = calcLength;
    exports.createDomMotionComponent = createDomMotionComponent;
    exports.createMotionComponent = createMotionComponent;
    exports.domAnimation = domAnimation;
    exports.domMax = domMax;
    exports.filterProps = filterProps;
    exports.isDragActive = isDragActive;
    exports.isMotionComponent = isMotionComponent;
    exports.isValidMotionProp = isValidMotionProp;
    exports.m = m;
    exports.makeUseVisualState = makeUseVisualState;
    exports.motion = motion;
    exports.resolveMotionValue = resolveMotionValue;
    exports.startOptimizedAppearAnimation = startOptimizedAppearAnimation;
    exports.unwrapMotionComponent = unwrapMotionComponent;
    exports.useAnimate = useAnimate;
    exports.useAnimation = useAnimation;
    exports.useAnimationControls = useAnimationControls;
    exports.useAnimationFrame = useAnimationFrame;
    exports.useCycle = useCycle;
    exports.useDeprecatedAnimatedState = useAnimatedState;
    exports.useDeprecatedInvertedScale = useInvertedScale;
    exports.useDomEvent = useDomEvent;
    exports.useDragControls = useDragControls;
    exports.useElementScroll = useElementScroll;
    exports.useForceUpdate = useForceUpdate;
    exports.useInView = useInView;
    exports.useInstantLayoutTransition = useInstantLayoutTransition;
    exports.useInstantTransition = useInstantTransition;
    exports.useIsPresent = useIsPresent;
    exports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;
    exports.useMotionTemplate = useMotionTemplate;
    exports.useMotionValue = useMotionValue;
    exports.useMotionValueEvent = useMotionValueEvent;
    exports.usePresence = usePresence;
    exports.useReducedMotion = useReducedMotion;
    exports.useReducedMotionConfig = useReducedMotionConfig;
    exports.useResetProjection = useResetProjection;
    exports.useScroll = useScroll;
    exports.useSpring = useSpring;
    exports.useTime = useTime;
    exports.useTransform = useTransform;
    exports.useUnmountEffect = useUnmountEffect;
    exports.useVelocity = useVelocity;
    exports.useViewportScroll = useViewportScroll;
    exports.useWillChange = useWillChange;
  }
});

// ../../node_modules/@chakra-ui/transition/dist/index.js
var require_dist19 = __commonJS({
  "../../node_modules/@chakra-ui/transition/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Collapse: () => Collapse,
      EASINGS: () => TRANSITION_EASINGS,
      Fade: () => Fade,
      ScaleFade: () => ScaleFade,
      Slide: () => Slide,
      SlideFade: () => SlideFade,
      fadeConfig: () => fadeConfig,
      getSlideTransition: () => getSlideTransition,
      scaleFadeConfig: () => scaleFadeConfig,
      slideFadeConfig: () => slideFadeConfig,
      withDelay: () => withDelay
    });
    module.exports = __toCommonJS2(src_exports);
    var import_shared_utils = require_dist3();
    var import_framer_motion = require_cjs();
    var import_react = require_react();
    var TRANSITION_EASINGS = {
      ease: [0.25, 0.1, 0.25, 1],
      easeIn: [0.4, 0, 1, 1],
      easeOut: [0, 0, 0.2, 1],
      easeInOut: [0.4, 0, 0.2, 1]
    };
    var TRANSITION_VARIANTS = {
      scale: {
        enter: { scale: 1 },
        exit: { scale: 0.95 }
      },
      fade: {
        enter: { opacity: 1 },
        exit: { opacity: 0 }
      },
      pushLeft: {
        enter: { x: "100%" },
        exit: { x: "-30%" }
      },
      pushRight: {
        enter: { x: "-100%" },
        exit: { x: "30%" }
      },
      pushUp: {
        enter: { y: "100%" },
        exit: { y: "-30%" }
      },
      pushDown: {
        enter: { y: "-100%" },
        exit: { y: "30%" }
      },
      slideLeft: {
        position: { left: 0, top: 0, bottom: 0, width: "100%" },
        enter: { x: 0, y: 0 },
        exit: { x: "-100%", y: 0 }
      },
      slideRight: {
        position: { right: 0, top: 0, bottom: 0, width: "100%" },
        enter: { x: 0, y: 0 },
        exit: { x: "100%", y: 0 }
      },
      slideUp: {
        position: { top: 0, left: 0, right: 0, maxWidth: "100vw" },
        enter: { x: 0, y: 0 },
        exit: { x: 0, y: "-100%" }
      },
      slideDown: {
        position: { bottom: 0, left: 0, right: 0, maxWidth: "100vw" },
        enter: { x: 0, y: 0 },
        exit: { x: 0, y: "100%" }
      }
    };
    function getSlideTransition(options) {
      var _a;
      const side = (_a = options == null ? void 0 : options.direction) != null ? _a : "right";
      switch (side) {
        case "right":
          return TRANSITION_VARIANTS.slideRight;
        case "left":
          return TRANSITION_VARIANTS.slideLeft;
        case "bottom":
          return TRANSITION_VARIANTS.slideDown;
        case "top":
          return TRANSITION_VARIANTS.slideUp;
        default:
          return TRANSITION_VARIANTS.slideRight;
      }
    }
    var TRANSITION_DEFAULTS = {
      enter: {
        duration: 0.2,
        ease: TRANSITION_EASINGS.easeOut
      },
      exit: {
        duration: 0.1,
        ease: TRANSITION_EASINGS.easeIn
      }
    };
    var withDelay = {
      enter: (transition, delay) => ({
        ...transition,
        delay: typeof delay === "number" ? delay : delay == null ? void 0 : delay["enter"]
      }),
      exit: (transition, delay) => ({
        ...transition,
        delay: typeof delay === "number" ? delay : delay == null ? void 0 : delay["exit"]
      })
    };
    var import_jsx_runtime = require_jsx_runtime();
    var isNumeric = (value) => value != null && parseInt(value.toString(), 10) > 0;
    var defaultTransitions = {
      exit: {
        height: { duration: 0.2, ease: TRANSITION_EASINGS.ease },
        opacity: { duration: 0.3, ease: TRANSITION_EASINGS.ease }
      },
      enter: {
        height: { duration: 0.3, ease: TRANSITION_EASINGS.ease },
        opacity: { duration: 0.4, ease: TRANSITION_EASINGS.ease }
      }
    };
    var variants = {
      exit: ({
        animateOpacity,
        startingHeight,
        transition,
        transitionEnd,
        delay
      }) => {
        var _a;
        return {
          ...animateOpacity && { opacity: isNumeric(startingHeight) ? 1 : 0 },
          height: startingHeight,
          transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit,
          transition: (_a = transition == null ? void 0 : transition.exit) != null ? _a : withDelay.exit(defaultTransitions.exit, delay)
        };
      },
      enter: ({
        animateOpacity,
        endingHeight,
        transition,
        transitionEnd,
        delay
      }) => {
        var _a;
        return {
          ...animateOpacity && { opacity: 1 },
          height: endingHeight,
          transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter,
          transition: (_a = transition == null ? void 0 : transition.enter) != null ? _a : withDelay.enter(defaultTransitions.enter, delay)
        };
      }
    };
    var Collapse = (0, import_react.forwardRef)(
      (props, ref) => {
        const {
          in: isOpen,
          unmountOnExit,
          animateOpacity = true,
          startingHeight = 0,
          endingHeight = "auto",
          style,
          className,
          transition,
          transitionEnd,
          ...rest
        } = props;
        const [mounted, setMounted] = (0, import_react.useState)(false);
        (0, import_react.useEffect)(() => {
          const timeout = setTimeout(() => {
            setMounted(true);
          });
          return () => clearTimeout(timeout);
        }, []);
        (0, import_shared_utils.warn)({
          condition: Number(startingHeight) > 0 && !!unmountOnExit,
          message: `startingHeight and unmountOnExit are mutually exclusive. You can't use them together`
        });
        const hasStartingHeight = parseFloat(startingHeight.toString()) > 0;
        const custom = {
          startingHeight,
          endingHeight,
          animateOpacity,
          transition: !mounted ? { enter: { duration: 0 } } : transition,
          transitionEnd: {
            enter: transitionEnd == null ? void 0 : transitionEnd.enter,
            exit: unmountOnExit ? transitionEnd == null ? void 0 : transitionEnd.exit : {
              ...transitionEnd == null ? void 0 : transitionEnd.exit,
              display: hasStartingHeight ? "block" : "none"
            }
          }
        };
        const show = unmountOnExit ? isOpen : true;
        const animate = isOpen || unmountOnExit ? "enter" : "exit";
        return (0, import_jsx_runtime.jsx)(import_framer_motion.AnimatePresence, { initial: false, custom, children: show && (0, import_jsx_runtime.jsx)(
          import_framer_motion.motion.div,
          {
            ref,
            ...rest,
            className: (0, import_shared_utils.cx)("chakra-collapse", className),
            style: {
              overflow: "hidden",
              display: "block",
              ...style
            },
            custom,
            variants,
            initial: unmountOnExit ? "exit" : false,
            animate,
            exit: "exit"
          }
        ) });
      }
    );
    Collapse.displayName = "Collapse";
    var import_shared_utils2 = require_dist3();
    var import_framer_motion2 = require_cjs();
    var import_react2 = require_react();
    var import_jsx_runtime2 = require_jsx_runtime();
    var variants2 = {
      enter: ({ transition, transitionEnd, delay } = {}) => {
        var _a;
        return {
          opacity: 1,
          transition: (_a = transition == null ? void 0 : transition.enter) != null ? _a : withDelay.enter(TRANSITION_DEFAULTS.enter, delay),
          transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter
        };
      },
      exit: ({ transition, transitionEnd, delay } = {}) => {
        var _a;
        return {
          opacity: 0,
          transition: (_a = transition == null ? void 0 : transition.exit) != null ? _a : withDelay.exit(TRANSITION_DEFAULTS.exit, delay),
          transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit
        };
      }
    };
    var fadeConfig = {
      initial: "exit",
      animate: "enter",
      exit: "exit",
      variants: variants2
    };
    var Fade = (0, import_react2.forwardRef)(function Fade2(props, ref) {
      const {
        unmountOnExit,
        in: isOpen,
        className,
        transition,
        transitionEnd,
        delay,
        ...rest
      } = props;
      const animate = isOpen || unmountOnExit ? "enter" : "exit";
      const show = unmountOnExit ? isOpen && unmountOnExit : true;
      const custom = { transition, transitionEnd, delay };
      return (0, import_jsx_runtime2.jsx)(import_framer_motion2.AnimatePresence, { custom, children: show && (0, import_jsx_runtime2.jsx)(
        import_framer_motion2.motion.div,
        {
          ref,
          className: (0, import_shared_utils2.cx)("chakra-fade", className),
          custom,
          ...fadeConfig,
          animate,
          ...rest
        }
      ) });
    });
    Fade.displayName = "Fade";
    var import_shared_utils3 = require_dist3();
    var import_framer_motion3 = require_cjs();
    var import_react3 = require_react();
    var import_jsx_runtime3 = require_jsx_runtime();
    var variants3 = {
      exit: ({ reverse, initialScale, transition, transitionEnd, delay }) => {
        var _a;
        return {
          opacity: 0,
          ...reverse ? { scale: initialScale, transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit } : { transitionEnd: { scale: initialScale, ...transitionEnd == null ? void 0 : transitionEnd.exit } },
          transition: (_a = transition == null ? void 0 : transition.exit) != null ? _a : withDelay.exit(TRANSITION_DEFAULTS.exit, delay)
        };
      },
      enter: ({ transitionEnd, transition, delay }) => {
        var _a;
        return {
          opacity: 1,
          scale: 1,
          transition: (_a = transition == null ? void 0 : transition.enter) != null ? _a : withDelay.enter(TRANSITION_DEFAULTS.enter, delay),
          transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter
        };
      }
    };
    var scaleFadeConfig = {
      initial: "exit",
      animate: "enter",
      exit: "exit",
      variants: variants3
    };
    var ScaleFade = (0, import_react3.forwardRef)(
      function ScaleFade2(props, ref) {
        const {
          unmountOnExit,
          in: isOpen,
          reverse = true,
          initialScale = 0.95,
          className,
          transition,
          transitionEnd,
          delay,
          ...rest
        } = props;
        const show = unmountOnExit ? isOpen && unmountOnExit : true;
        const animate = isOpen || unmountOnExit ? "enter" : "exit";
        const custom = { initialScale, reverse, transition, transitionEnd, delay };
        return (0, import_jsx_runtime3.jsx)(import_framer_motion3.AnimatePresence, { custom, children: show && (0, import_jsx_runtime3.jsx)(
          import_framer_motion3.motion.div,
          {
            ref,
            className: (0, import_shared_utils3.cx)("chakra-offset-slide", className),
            ...scaleFadeConfig,
            animate,
            custom,
            ...rest
          }
        ) });
      }
    );
    ScaleFade.displayName = "ScaleFade";
    var import_shared_utils4 = require_dist3();
    var import_framer_motion4 = require_cjs();
    var import_react4 = require_react();
    var import_jsx_runtime4 = require_jsx_runtime();
    var defaultTransition = {
      exit: {
        duration: 0.15,
        ease: TRANSITION_EASINGS.easeInOut
      },
      enter: {
        type: "spring",
        damping: 25,
        stiffness: 180
      }
    };
    var variants4 = {
      exit: ({ direction, transition, transitionEnd, delay }) => {
        var _a;
        const { exit: exitStyles } = getSlideTransition({ direction });
        return {
          ...exitStyles,
          transition: (_a = transition == null ? void 0 : transition.exit) != null ? _a : withDelay.exit(defaultTransition.exit, delay),
          transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit
        };
      },
      enter: ({ direction, transitionEnd, transition, delay }) => {
        var _a;
        const { enter: enterStyles } = getSlideTransition({ direction });
        return {
          ...enterStyles,
          transition: (_a = transition == null ? void 0 : transition.enter) != null ? _a : withDelay.enter(defaultTransition.enter, delay),
          transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter
        };
      }
    };
    var Slide = (0, import_react4.forwardRef)(function Slide2(props, ref) {
      const {
        direction = "right",
        style,
        unmountOnExit,
        in: isOpen,
        className,
        transition,
        transitionEnd,
        delay,
        motionProps,
        ...rest
      } = props;
      const transitionStyles = getSlideTransition({ direction });
      const computedStyle = Object.assign(
        { position: "fixed" },
        transitionStyles.position,
        style
      );
      const show = unmountOnExit ? isOpen && unmountOnExit : true;
      const animate = isOpen || unmountOnExit ? "enter" : "exit";
      const custom = { transitionEnd, transition, direction, delay };
      return (0, import_jsx_runtime4.jsx)(import_framer_motion4.AnimatePresence, { custom, children: show && (0, import_jsx_runtime4.jsx)(
        import_framer_motion4.motion.div,
        {
          ...rest,
          ref,
          initial: "exit",
          className: (0, import_shared_utils4.cx)("chakra-slide", className),
          animate,
          exit: "exit",
          custom,
          variants: variants4,
          style: computedStyle,
          ...motionProps
        }
      ) });
    });
    Slide.displayName = "Slide";
    var import_shared_utils5 = require_dist3();
    var import_framer_motion5 = require_cjs();
    var import_react5 = require_react();
    var import_jsx_runtime5 = require_jsx_runtime();
    var variants5 = {
      initial: ({ offsetX, offsetY, transition, transitionEnd, delay }) => {
        var _a;
        return {
          opacity: 0,
          x: offsetX,
          y: offsetY,
          transition: (_a = transition == null ? void 0 : transition.exit) != null ? _a : withDelay.exit(TRANSITION_DEFAULTS.exit, delay),
          transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit
        };
      },
      enter: ({ transition, transitionEnd, delay }) => {
        var _a;
        return {
          opacity: 1,
          x: 0,
          y: 0,
          transition: (_a = transition == null ? void 0 : transition.enter) != null ? _a : withDelay.enter(TRANSITION_DEFAULTS.enter, delay),
          transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter
        };
      },
      exit: ({ offsetY, offsetX, transition, transitionEnd, reverse, delay }) => {
        var _a;
        const offset = { x: offsetX, y: offsetY };
        return {
          opacity: 0,
          transition: (_a = transition == null ? void 0 : transition.exit) != null ? _a : withDelay.exit(TRANSITION_DEFAULTS.exit, delay),
          ...reverse ? { ...offset, transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit } : { transitionEnd: { ...offset, ...transitionEnd == null ? void 0 : transitionEnd.exit } }
        };
      }
    };
    var slideFadeConfig = {
      initial: "initial",
      animate: "enter",
      exit: "exit",
      variants: variants5
    };
    var SlideFade = (0, import_react5.forwardRef)(
      function SlideFade2(props, ref) {
        const {
          unmountOnExit,
          in: isOpen,
          reverse = true,
          className,
          offsetX = 0,
          offsetY = 8,
          transition,
          transitionEnd,
          delay,
          ...rest
        } = props;
        const show = unmountOnExit ? isOpen && unmountOnExit : true;
        const animate = isOpen || unmountOnExit ? "enter" : "exit";
        const custom = {
          offsetX,
          offsetY,
          reverse,
          transition,
          transitionEnd,
          delay
        };
        return (0, import_jsx_runtime5.jsx)(import_framer_motion5.AnimatePresence, { custom, children: show && (0, import_jsx_runtime5.jsx)(
          import_framer_motion5.motion.div,
          {
            ref,
            className: (0, import_shared_utils5.cx)("chakra-offset-slide", className),
            custom,
            ...slideFadeConfig,
            animate,
            ...rest
          }
        ) });
      }
    );
    SlideFade.displayName = "SlideFade";
  }
});

// ../../node_modules/@chakra-ui/accordion/dist/index.js
var require_dist20 = __commonJS({
  "../../node_modules/@chakra-ui/accordion/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Accordion: () => Accordion,
      AccordionButton: () => AccordionButton,
      AccordionIcon: () => AccordionIcon,
      AccordionItem: () => AccordionItem,
      AccordionPanel: () => AccordionPanel,
      AccordionProvider: () => AccordionProvider,
      useAccordion: () => useAccordion,
      useAccordionContext: () => useAccordionContext,
      useAccordionItem: () => useAccordionItem,
      useAccordionItemState: () => useAccordionItemState,
      useAccordionStyles: () => useAccordionStyles
    });
    module.exports = __toCommonJS2(src_exports);
    var import_system = require_dist12();
    var import_shared_utils2 = require_dist3();
    var import_react2 = require_react();
    var import_descendant = require_dist15();
    var import_react_context = require_dist13();
    var [AccordionStylesProvider, useAccordionStyles] = (0, import_react_context.createContext)({
      name: "AccordionStylesContext",
      hookName: "useAccordionStyles",
      providerName: "<Accordion />"
    });
    var [AccordionItemProvider, useAccordionItemContext] = (0, import_react_context.createContext)({
      name: "AccordionItemContext",
      hookName: "useAccordionItemContext",
      providerName: "<AccordionItem />"
    });
    var [
      AccordionDescendantsProvider,
      useAccordionDescendantsContext,
      useAccordionDescendants,
      useAccordionDescendant
    ] = (0, import_descendant.createDescendantContext)();
    var import_react_context2 = require_dist13();
    var import_react_use_controllable_state = require_dist17();
    var import_react_use_merge_refs = require_dist14();
    var import_shared_utils = require_dist3();
    var import_react = require_react();
    function useAccordion(props) {
      const {
        onChange,
        defaultIndex,
        index: indexProp,
        allowMultiple,
        allowToggle,
        ...htmlProps
      } = props;
      allowMultipleWarning(props);
      allowMultipleAndAllowToggleWarning(props);
      const descendants = useAccordionDescendants();
      const [focusedIndex, setFocusedIndex] = (0, import_react.useState)(-1);
      (0, import_react.useEffect)(() => {
        return () => {
          setFocusedIndex(-1);
        };
      }, []);
      const [index, setIndex] = (0, import_react_use_controllable_state.useControllableState)({
        value: indexProp,
        defaultValue() {
          if (allowMultiple)
            return defaultIndex != null ? defaultIndex : [];
          return defaultIndex != null ? defaultIndex : -1;
        },
        onChange
      });
      const getAccordionItemProps = (idx) => {
        let isOpen = false;
        if (idx !== null) {
          isOpen = Array.isArray(index) ? index.includes(idx) : index === idx;
        }
        const onChange2 = (isOpen2) => {
          if (idx === null)
            return;
          if (allowMultiple && Array.isArray(index)) {
            const nextState = isOpen2 ? index.concat(idx) : index.filter((i) => i !== idx);
            setIndex(nextState);
          } else if (isOpen2) {
            setIndex(idx);
          } else if (allowToggle) {
            setIndex(-1);
          }
        };
        return { isOpen, onChange: onChange2 };
      };
      return {
        index,
        setIndex,
        htmlProps,
        getAccordionItemProps,
        focusedIndex,
        setFocusedIndex,
        descendants
      };
    }
    var [AccordionProvider, useAccordionContext] = (0, import_react_context2.createContext)({
      name: "AccordionContext",
      hookName: "useAccordionContext",
      providerName: "Accordion"
    });
    function useAccordionItem(props) {
      const { isDisabled, isFocusable, id, ...htmlProps } = props;
      const { getAccordionItemProps, setFocusedIndex } = useAccordionContext();
      const buttonRef = (0, import_react.useRef)(null);
      const reactId = (0, import_react.useId)();
      const uid = id != null ? id : reactId;
      const buttonId = `accordion-button-${uid}`;
      const panelId = `accordion-panel-${uid}`;
      focusableNotDisabledWarning(props);
      const { register, index, descendants } = useAccordionDescendant({
        disabled: isDisabled && !isFocusable
      });
      const { isOpen, onChange } = getAccordionItemProps(
        index === -1 ? null : index
      );
      warnIfOpenAndDisabled({ isOpen, isDisabled });
      const onOpen = () => {
        onChange == null ? void 0 : onChange(true);
      };
      const onClose = () => {
        onChange == null ? void 0 : onChange(false);
      };
      const onClick = (0, import_react.useCallback)(() => {
        onChange == null ? void 0 : onChange(!isOpen);
        setFocusedIndex(index);
      }, [index, setFocusedIndex, isOpen, onChange]);
      const onKeyDown = (0, import_react.useCallback)(
        (event) => {
          const keyMap = {
            ArrowDown: () => {
              const next = descendants.nextEnabled(index);
              next == null ? void 0 : next.node.focus();
            },
            ArrowUp: () => {
              const prev = descendants.prevEnabled(index);
              prev == null ? void 0 : prev.node.focus();
            },
            Home: () => {
              const first = descendants.firstEnabled();
              first == null ? void 0 : first.node.focus();
            },
            End: () => {
              const last = descendants.lastEnabled();
              last == null ? void 0 : last.node.focus();
            }
          };
          const action = keyMap[event.key];
          if (action) {
            event.preventDefault();
            action(event);
          }
        },
        [descendants, index]
      );
      const onFocus = (0, import_react.useCallback)(() => {
        setFocusedIndex(index);
      }, [setFocusedIndex, index]);
      const getButtonProps = (0, import_react.useCallback)(
        function getButtonProps2(props2 = {}, ref = null) {
          return {
            ...props2,
            type: "button",
            ref: (0, import_react_use_merge_refs.mergeRefs)(register, buttonRef, ref),
            id: buttonId,
            disabled: !!isDisabled,
            "aria-expanded": !!isOpen,
            "aria-controls": panelId,
            onClick: (0, import_shared_utils.callAllHandlers)(props2.onClick, onClick),
            onFocus: (0, import_shared_utils.callAllHandlers)(props2.onFocus, onFocus),
            onKeyDown: (0, import_shared_utils.callAllHandlers)(props2.onKeyDown, onKeyDown)
          };
        },
        [
          buttonId,
          isDisabled,
          isOpen,
          onClick,
          onFocus,
          onKeyDown,
          panelId,
          register
        ]
      );
      const getPanelProps = (0, import_react.useCallback)(
        function getPanelProps2(props2 = {}, ref = null) {
          return {
            ...props2,
            ref,
            role: "region",
            id: panelId,
            "aria-labelledby": buttonId,
            hidden: !isOpen
          };
        },
        [buttonId, isOpen, panelId]
      );
      return {
        isOpen,
        isDisabled,
        isFocusable,
        onOpen,
        onClose,
        getButtonProps,
        getPanelProps,
        htmlProps
      };
    }
    function allowMultipleWarning(props) {
      const index = props.index || props.defaultIndex;
      const condition = index != null && !Array.isArray(index) && props.allowMultiple;
      (0, import_shared_utils.warn)({
        condition: !!condition,
        message: `If 'allowMultiple' is passed, then 'index' or 'defaultIndex' must be an array. You passed: ${typeof index},`
      });
    }
    function allowMultipleAndAllowToggleWarning(props) {
      (0, import_shared_utils.warn)({
        condition: !!(props.allowMultiple && props.allowToggle),
        message: `If 'allowMultiple' is passed, 'allowToggle' will be ignored. Either remove 'allowToggle' or 'allowMultiple' depending on whether you want multiple accordions visible or not`
      });
    }
    function focusableNotDisabledWarning(props) {
      (0, import_shared_utils.warn)({
        condition: !!(props.isFocusable && !props.isDisabled),
        message: `Using only 'isFocusable', this prop is reserved for situations where you pass 'isDisabled' but you still want the element to receive focus (A11y). Either remove it or pass 'isDisabled' as well.
    `
      });
    }
    function warnIfOpenAndDisabled(props) {
      (0, import_shared_utils.warn)({
        condition: props.isOpen && !!props.isDisabled,
        message: "Cannot open a disabled accordion item"
      });
    }
    var import_jsx_runtime = require_jsx_runtime();
    var Accordion = (0, import_system.forwardRef)(function Accordion2({ children, reduceMotion, ...props }, ref) {
      const styles = (0, import_system.useMultiStyleConfig)("Accordion", props);
      const ownProps = (0, import_system.omitThemingProps)(props);
      const { htmlProps, descendants, ...context } = useAccordion(ownProps);
      const ctx = (0, import_react2.useMemo)(
        () => ({ ...context, reduceMotion: !!reduceMotion }),
        [context, reduceMotion]
      );
      return (0, import_jsx_runtime.jsx)(AccordionDescendantsProvider, { value: descendants, children: (0, import_jsx_runtime.jsx)(AccordionProvider, { value: ctx, children: (0, import_jsx_runtime.jsx)(AccordionStylesProvider, { value: styles, children: (0, import_jsx_runtime.jsx)(
        import_system.chakra.div,
        {
          ref,
          ...htmlProps,
          className: (0, import_shared_utils2.cx)("chakra-accordion", props.className),
          __css: styles.root,
          children
        }
      ) }) }) });
    });
    Accordion.displayName = "Accordion";
    var import_system2 = require_dist12();
    var import_shared_utils3 = require_dist3();
    var import_jsx_runtime2 = require_jsx_runtime();
    var AccordionButton = (0, import_system2.forwardRef)(
      function AccordionButton2(props, ref) {
        const { getButtonProps } = useAccordionItemContext();
        const buttonProps = getButtonProps(props, ref);
        const styles = useAccordionStyles();
        const buttonStyles = {
          display: "flex",
          alignItems: "center",
          width: "100%",
          outline: 0,
          ...styles.button
        };
        return (0, import_jsx_runtime2.jsx)(
          import_system2.chakra.button,
          {
            ...buttonProps,
            className: (0, import_shared_utils3.cx)("chakra-accordion__button", props.className),
            __css: buttonStyles
          }
        );
      }
    );
    AccordionButton.displayName = "AccordionButton";
    var import_icon = require_dist18();
    var import_shared_utils4 = require_dist3();
    var import_jsx_runtime3 = require_jsx_runtime();
    function AccordionIcon(props) {
      const { isOpen, isDisabled } = useAccordionItemContext();
      const { reduceMotion } = useAccordionContext();
      const _className = (0, import_shared_utils4.cx)("chakra-accordion__icon", props.className);
      const styles = useAccordionStyles();
      const iconStyles = {
        opacity: isDisabled ? 0.4 : 1,
        transform: isOpen ? "rotate(-180deg)" : void 0,
        transition: reduceMotion ? void 0 : "transform 0.2s",
        transformOrigin: "center",
        ...styles.icon
      };
      return (0, import_jsx_runtime3.jsx)(
        import_icon.Icon,
        {
          viewBox: "0 0 24 24",
          "aria-hidden": true,
          className: _className,
          __css: iconStyles,
          ...props,
          children: (0, import_jsx_runtime3.jsx)(
            "path",
            {
              fill: "currentColor",
              d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
            }
          )
        }
      );
    }
    AccordionIcon.displayName = "AccordionIcon";
    var import_system3 = require_dist12();
    var import_shared_utils5 = require_dist3();
    var import_react3 = require_react();
    var import_jsx_runtime4 = require_jsx_runtime();
    var AccordionItem = (0, import_system3.forwardRef)(
      function AccordionItem2(props, ref) {
        const { children, className } = props;
        const { htmlProps, ...context } = useAccordionItem(props);
        const styles = useAccordionStyles();
        const containerStyles = {
          ...styles.container,
          overflowAnchor: "none"
        };
        const ctx = (0, import_react3.useMemo)(() => context, [context]);
        return (0, import_jsx_runtime4.jsx)(AccordionItemProvider, { value: ctx, children: (0, import_jsx_runtime4.jsx)(
          import_system3.chakra.div,
          {
            ref,
            ...htmlProps,
            className: (0, import_shared_utils5.cx)("chakra-accordion__item", className),
            __css: containerStyles,
            children: typeof children === "function" ? children({
              isExpanded: !!context.isOpen,
              isDisabled: !!context.isDisabled
            }) : children
          }
        ) });
      }
    );
    AccordionItem.displayName = "AccordionItem";
    var import_system4 = require_dist12();
    var import_transition = require_dist19();
    var import_shared_utils6 = require_dist3();
    var import_jsx_runtime5 = require_jsx_runtime();
    var AccordionPanel = (0, import_system4.forwardRef)(
      function AccordionPanel2(props, ref) {
        const { className, motionProps, ...rest } = props;
        const { reduceMotion } = useAccordionContext();
        const { getPanelProps, isOpen } = useAccordionItemContext();
        const panelProps = getPanelProps(rest, ref);
        const _className = (0, import_shared_utils6.cx)("chakra-accordion__panel", className);
        const styles = useAccordionStyles();
        if (!reduceMotion) {
          delete panelProps.hidden;
        }
        const child = (0, import_jsx_runtime5.jsx)(import_system4.chakra.div, { ...panelProps, __css: styles.panel, className: _className });
        if (!reduceMotion) {
          return (0, import_jsx_runtime5.jsx)(import_transition.Collapse, { in: isOpen, ...motionProps, children: child });
        }
        return child;
      }
    );
    AccordionPanel.displayName = "AccordionPanel";
    function useAccordionItemState() {
      const { isOpen, isDisabled, onClose, onOpen } = useAccordionItemContext();
      return { isOpen, onClose, isDisabled, onOpen };
    }
  }
});

// ../../node_modules/@chakra-ui/spinner/dist/index.js
var require_dist21 = __commonJS({
  "../../node_modules/@chakra-ui/spinner/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Spinner: () => Spinner
    });
    module.exports = __toCommonJS2(src_exports);
    var import_system = require_dist12();
    var import_shared_utils = require_dist3();
    var import_jsx_runtime = require_jsx_runtime();
    var spin = (0, import_system.keyframes)({
      "0%": {
        transform: "rotate(0deg)"
      },
      "100%": {
        transform: "rotate(360deg)"
      }
    });
    var Spinner = (0, import_system.forwardRef)((props, ref) => {
      const styles = (0, import_system.useStyleConfig)("Spinner", props);
      const {
        label = "Loading...",
        thickness = "2px",
        speed = "0.45s",
        emptyColor = "transparent",
        className,
        ...rest
      } = (0, import_system.omitThemingProps)(props);
      const _className = (0, import_shared_utils.cx)("chakra-spinner", className);
      const spinnerStyles = {
        display: "inline-block",
        borderColor: "currentColor",
        borderStyle: "solid",
        borderRadius: "99999px",
        borderWidth: thickness,
        borderBottomColor: emptyColor,
        borderLeftColor: emptyColor,
        animation: `${spin} ${speed} linear infinite`,
        ...styles
      };
      return (0, import_jsx_runtime.jsx)(
        import_system.chakra.div,
        {
          ref,
          __css: spinnerStyles,
          className: _className,
          ...rest,
          children: label && (0, import_jsx_runtime.jsx)(import_system.chakra.span, { srOnly: true, children: label })
        }
      );
    });
    Spinner.displayName = "Spinner";
  }
});

// ../../node_modules/@chakra-ui/alert/dist/index.js
var require_dist22 = __commonJS({
  "../../node_modules/@chakra-ui/alert/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Alert: () => Alert,
      AlertDescription: () => AlertDescription,
      AlertIcon: () => AlertIcon,
      AlertTitle: () => AlertTitle,
      useAlertStyles: () => useAlertStyles
    });
    module.exports = __toCommonJS2(src_exports);
    var import_shared_utils = require_dist3();
    var import_system = require_dist12();
    var import_react_context = require_dist13();
    var import_icon = require_dist18();
    var import_jsx_runtime = require_jsx_runtime();
    function CheckIcon(props) {
      return (0, import_jsx_runtime.jsx)(import_icon.Icon, { viewBox: "0 0 24 24", ...props, children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          fill: "currentColor",
          d: "M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z"
        }
      ) });
    }
    function InfoIcon(props) {
      return (0, import_jsx_runtime.jsx)(import_icon.Icon, { viewBox: "0 0 24 24", ...props, children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          fill: "currentColor",
          d: "M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z"
        }
      ) });
    }
    function WarningIcon(props) {
      return (0, import_jsx_runtime.jsx)(import_icon.Icon, { viewBox: "0 0 24 24", ...props, children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          fill: "currentColor",
          d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
        }
      ) });
    }
    var import_spinner = require_dist21();
    var [AlertProvider, useAlertContext] = (0, import_react_context.createContext)({
      name: "AlertContext",
      hookName: "useAlertContext",
      providerName: "<Alert />"
    });
    var [AlertStylesProvider, useAlertStyles] = (0, import_react_context.createContext)({
      name: `AlertStylesContext`,
      hookName: `useAlertStyles`,
      providerName: "<Alert />"
    });
    var STATUSES = {
      info: { icon: InfoIcon, colorScheme: "blue" },
      warning: { icon: WarningIcon, colorScheme: "orange" },
      success: { icon: CheckIcon, colorScheme: "green" },
      error: { icon: WarningIcon, colorScheme: "red" },
      loading: { icon: import_spinner.Spinner, colorScheme: "blue" }
    };
    function getStatusColorScheme(status) {
      return STATUSES[status].colorScheme;
    }
    function getStatusIcon(status) {
      return STATUSES[status].icon;
    }
    var import_jsx_runtime2 = require_jsx_runtime();
    var Alert = (0, import_system.forwardRef)(function Alert2(props, ref) {
      var _a;
      const { status = "info", addRole = true, ...rest } = (0, import_system.omitThemingProps)(props);
      const colorScheme = (_a = props.colorScheme) != null ? _a : getStatusColorScheme(status);
      const styles = (0, import_system.useMultiStyleConfig)("Alert", { ...props, colorScheme });
      const alertStyles = {
        width: "100%",
        display: "flex",
        alignItems: "center",
        position: "relative",
        overflow: "hidden",
        ...styles.container
      };
      return (0, import_jsx_runtime2.jsx)(AlertProvider, { value: { status }, children: (0, import_jsx_runtime2.jsx)(AlertStylesProvider, { value: styles, children: (0, import_jsx_runtime2.jsx)(
        import_system.chakra.div,
        {
          "data-status": status,
          role: addRole ? "alert" : void 0,
          ref,
          ...rest,
          className: (0, import_shared_utils.cx)("chakra-alert", props.className),
          __css: alertStyles
        }
      ) }) });
    });
    Alert.displayName = "Alert";
    var import_shared_utils2 = require_dist3();
    var import_system2 = require_dist12();
    var import_jsx_runtime3 = require_jsx_runtime();
    var AlertDescription = (0, import_system2.forwardRef)(
      function AlertDescription2(props, ref) {
        const styles = useAlertStyles();
        const { status } = useAlertContext();
        const descriptionStyles = {
          display: "inline",
          ...styles.description
        };
        return (0, import_jsx_runtime3.jsx)(
          import_system2.chakra.div,
          {
            ref,
            "data-status": status,
            ...props,
            className: (0, import_shared_utils2.cx)("chakra-alert__desc", props.className),
            __css: descriptionStyles
          }
        );
      }
    );
    AlertDescription.displayName = "AlertDescription";
    var import_shared_utils3 = require_dist3();
    var import_system3 = require_dist12();
    var import_jsx_runtime4 = require_jsx_runtime();
    function AlertIcon(props) {
      const { status } = useAlertContext();
      const BaseIcon = getStatusIcon(status);
      const styles = useAlertStyles();
      const css = status === "loading" ? styles.spinner : styles.icon;
      return (0, import_jsx_runtime4.jsx)(
        import_system3.chakra.span,
        {
          display: "inherit",
          "data-status": status,
          ...props,
          className: (0, import_shared_utils3.cx)("chakra-alert__icon", props.className),
          __css: css,
          children: props.children || (0, import_jsx_runtime4.jsx)(BaseIcon, { h: "100%", w: "100%" })
        }
      );
    }
    AlertIcon.displayName = "AlertIcon";
    var import_shared_utils4 = require_dist3();
    var import_system4 = require_dist12();
    var import_jsx_runtime5 = require_jsx_runtime();
    var AlertTitle = (0, import_system4.forwardRef)(
      function AlertTitle2(props, ref) {
        const styles = useAlertStyles();
        const { status } = useAlertContext();
        return (0, import_jsx_runtime5.jsx)(
          import_system4.chakra.div,
          {
            ref,
            "data-status": status,
            ...props,
            className: (0, import_shared_utils4.cx)("chakra-alert__title", props.className),
            __css: styles.title
          }
        );
      }
    );
    AlertTitle.displayName = "AlertTitle";
  }
});

// ../../node_modules/@chakra-ui/image/dist/index.js
var require_dist23 = __commonJS({
  "../../node_modules/@chakra-ui/image/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Image: () => Image2,
      Img: () => Img,
      useImage: () => useImage
    });
    module.exports = __toCommonJS2(src_exports);
    var import_system2 = require_dist12();
    function omit(object, keysToOmit = []) {
      const clone = Object.assign({}, object);
      for (const key of keysToOmit) {
        if (key in clone) {
          delete clone[key];
        }
      }
      return clone;
    }
    var import_react_use_safe_layout_effect = require_dist();
    var import_react = require_react();
    function useImage(props) {
      const {
        loading,
        src,
        srcSet,
        onLoad,
        onError,
        crossOrigin,
        sizes,
        ignoreFallback
      } = props;
      const [status, setStatus] = (0, import_react.useState)("pending");
      (0, import_react.useEffect)(() => {
        setStatus(src ? "loading" : "pending");
      }, [src]);
      const imageRef = (0, import_react.useRef)();
      const load = (0, import_react.useCallback)(() => {
        if (!src)
          return;
        flush();
        const img = new Image();
        img.src = src;
        if (crossOrigin)
          img.crossOrigin = crossOrigin;
        if (srcSet)
          img.srcset = srcSet;
        if (sizes)
          img.sizes = sizes;
        if (loading)
          img.loading = loading;
        img.onload = (event) => {
          flush();
          setStatus("loaded");
          onLoad == null ? void 0 : onLoad(event);
        };
        img.onerror = (error) => {
          flush();
          setStatus("failed");
          onError == null ? void 0 : onError(error);
        };
        imageRef.current = img;
      }, [src, crossOrigin, srcSet, sizes, onLoad, onError, loading]);
      const flush = () => {
        if (imageRef.current) {
          imageRef.current.onload = null;
          imageRef.current.onerror = null;
          imageRef.current = null;
        }
      };
      (0, import_react_use_safe_layout_effect.useSafeLayoutEffect)(() => {
        if (ignoreFallback)
          return void 0;
        if (status === "loading") {
          load();
        }
        return () => {
          flush();
        };
      }, [status, load, ignoreFallback]);
      return ignoreFallback ? "loaded" : status;
    }
    var shouldShowFallbackImage = (status, fallbackStrategy) => status !== "loaded" && fallbackStrategy === "beforeLoadOrError" || status === "failed" && fallbackStrategy === "onError";
    var import_system = require_dist12();
    var import_jsx_runtime = require_jsx_runtime();
    var NativeImage = (0, import_system.forwardRef)(function NativeImage2(props, ref) {
      const { htmlWidth, htmlHeight, alt, ...rest } = props;
      return (0, import_jsx_runtime.jsx)("img", { width: htmlWidth, height: htmlHeight, ref, alt, ...rest });
    });
    NativeImage.displayName = "NativeImage";
    var import_jsx_runtime2 = require_jsx_runtime();
    var Image2 = (0, import_system2.forwardRef)(function Image3(props, ref) {
      const {
        fallbackSrc,
        fallback,
        src,
        srcSet,
        align,
        fit,
        loading,
        ignoreFallback,
        crossOrigin,
        fallbackStrategy = "beforeLoadOrError",
        referrerPolicy,
        ...rest
      } = props;
      const providedFallback = fallbackSrc !== void 0 || fallback !== void 0;
      const shouldIgnoreFallbackImage = loading != null || ignoreFallback || !providedFallback;
      const status = useImage({
        ...props,
        crossOrigin,
        ignoreFallback: shouldIgnoreFallbackImage
      });
      const showFallbackImage = shouldShowFallbackImage(status, fallbackStrategy);
      const shared = {
        ref,
        objectFit: fit,
        objectPosition: align,
        ...shouldIgnoreFallbackImage ? rest : omit(rest, ["onError", "onLoad"])
      };
      if (showFallbackImage) {
        if (fallback)
          return fallback;
        return (0, import_jsx_runtime2.jsx)(
          import_system2.chakra.img,
          {
            as: NativeImage,
            className: "chakra-image__placeholder",
            src: fallbackSrc,
            ...shared
          }
        );
      }
      return (0, import_jsx_runtime2.jsx)(
        import_system2.chakra.img,
        {
          as: NativeImage,
          src,
          srcSet,
          crossOrigin,
          loading,
          referrerPolicy,
          className: "chakra-image",
          ...shared
        }
      );
    });
    Image2.displayName = "Image";
    var import_system3 = require_dist12();
    var import_jsx_runtime3 = require_jsx_runtime();
    var Img = (0, import_system3.forwardRef)((props, ref) => (0, import_jsx_runtime3.jsx)(import_system3.chakra.img, { ref, as: NativeImage, className: "chakra-image", ...props }));
  }
});

// ../../node_modules/@chakra-ui/react-children-utils/dist/index.js
var require_dist24 = __commonJS({
  "../../node_modules/@chakra-ui/react-children-utils/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      getValidChildren: () => getValidChildren
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react = require_react();
    function getValidChildren(children) {
      return import_react.Children.toArray(children).filter(
        (child) => (0, import_react.isValidElement)(child)
      );
    }
  }
});

// ../../node_modules/@chakra-ui/avatar/dist/index.js
var require_dist25 = __commonJS({
  "../../node_modules/@chakra-ui/avatar/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Avatar: () => Avatar,
      AvatarBadge: () => AvatarBadge,
      AvatarGroup: () => AvatarGroup,
      GenericAvatarIcon: () => GenericAvatarIcon,
      useAvatarStyles: () => useAvatarStyles
    });
    module.exports = __toCommonJS2(src_exports);
    var import_system4 = require_dist12();
    var import_shared_utils = require_dist3();
    var import_react_context = require_dist13();
    var [AvatarStylesProvider, useAvatarStyles] = (0, import_react_context.createContext)({
      name: `AvatarStylesContext`,
      hookName: `useAvatarStyles`,
      providerName: "<Avatar/>"
    });
    var import_image = require_dist23();
    var import_system3 = require_dist12();
    var import_react = require_react();
    var import_system = require_dist12();
    var import_jsx_runtime = require_jsx_runtime();
    function initials(name) {
      var _a;
      const names = name.split(" ");
      const firstName = (_a = names.at(0)) != null ? _a : "";
      const lastName = names.length > 1 ? names.at(-1) : "";
      return firstName && lastName ? `${firstName.charAt(0)}${lastName.charAt(0)}` : firstName.charAt(0);
    }
    function AvatarName(props) {
      const { name, getInitials, ...rest } = props;
      const styles = useAvatarStyles();
      return (0, import_jsx_runtime.jsx)(import_system.chakra.div, { role: "img", "aria-label": name, ...rest, __css: styles.label, children: name ? getInitials == null ? void 0 : getInitials(name) : null });
    }
    AvatarName.displayName = "AvatarName";
    var import_system2 = require_dist12();
    var import_jsx_runtime2 = require_jsx_runtime();
    var GenericAvatarIcon = (props) => (0, import_jsx_runtime2.jsxs)(
      import_system2.chakra.svg,
      {
        viewBox: "0 0 128 128",
        color: "#fff",
        width: "100%",
        height: "100%",
        className: "chakra-avatar__svg",
        ...props,
        children: [
          (0, import_jsx_runtime2.jsx)(
            "path",
            {
              fill: "currentColor",
              d: "M103,102.1388 C93.094,111.92 79.3504,118 64.1638,118 C48.8056,118 34.9294,111.768 25,101.7892 L25,95.2 C25,86.8096 31.981,80 40.6,80 L87.4,80 C96.019,80 103,86.8096 103,95.2 L103,102.1388 Z"
            }
          ),
          (0, import_jsx_runtime2.jsx)(
            "path",
            {
              fill: "currentColor",
              d: "M63.9961647,24 C51.2938136,24 41,34.2938136 41,46.9961647 C41,59.7061864 51.2938136,70 63.9961647,70 C76.6985159,70 87,59.7061864 87,46.9961647 C87,34.2938136 76.6985159,24 63.9961647,24"
            }
          )
        ]
      }
    );
    var import_jsx_runtime3 = require_jsx_runtime();
    function AvatarImage(props) {
      const {
        src,
        srcSet,
        onError,
        onLoad,
        getInitials,
        name,
        borderRadius,
        loading,
        iconLabel,
        icon = (0, import_jsx_runtime3.jsx)(GenericAvatarIcon, {}),
        ignoreFallback,
        referrerPolicy,
        crossOrigin
      } = props;
      const status = (0, import_image.useImage)({ src, onError, crossOrigin, ignoreFallback });
      const hasLoaded = status === "loaded";
      const showFallback = !src || !hasLoaded;
      if (showFallback) {
        return name ? (0, import_jsx_runtime3.jsx)(
          AvatarName,
          {
            className: "chakra-avatar__initials",
            getInitials,
            name
          }
        ) : (0, import_react.cloneElement)(icon, {
          role: "img",
          "aria-label": iconLabel
        });
      }
      return (0, import_jsx_runtime3.jsx)(
        import_system3.chakra.img,
        {
          src,
          srcSet,
          alt: name,
          onLoad,
          referrerPolicy,
          crossOrigin: crossOrigin != null ? crossOrigin : void 0,
          className: "chakra-avatar__img",
          loading,
          __css: {
            width: "100%",
            height: "100%",
            objectFit: "cover",
            borderRadius
          }
        }
      );
    }
    AvatarImage.displayName = "AvatarImage";
    var import_react2 = require_react();
    var import_jsx_runtime4 = require_jsx_runtime();
    var baseStyle = {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      textAlign: "center",
      textTransform: "uppercase",
      fontWeight: "medium",
      position: "relative",
      flexShrink: 0
    };
    var Avatar = (0, import_system4.forwardRef)((props, ref) => {
      const styles = (0, import_system4.useMultiStyleConfig)("Avatar", props);
      const [isLoaded, setIsLoaded] = (0, import_react2.useState)(false);
      const {
        src,
        srcSet,
        name,
        showBorder,
        borderRadius = "full",
        onError,
        onLoad: onLoadProp,
        getInitials = initials,
        icon = (0, import_jsx_runtime4.jsx)(GenericAvatarIcon, {}),
        iconLabel = " avatar",
        loading,
        children,
        borderColor,
        ignoreFallback,
        crossOrigin,
        ...rest
      } = (0, import_system4.omitThemingProps)(props);
      const avatarStyles = {
        borderRadius,
        borderWidth: showBorder ? "2px" : void 0,
        ...baseStyle,
        ...styles.container
      };
      if (borderColor) {
        avatarStyles.borderColor = borderColor;
      }
      return (0, import_jsx_runtime4.jsx)(
        import_system4.chakra.span,
        {
          ref,
          ...rest,
          className: (0, import_shared_utils.cx)("chakra-avatar", props.className),
          "data-loaded": (0, import_shared_utils.dataAttr)(isLoaded),
          __css: avatarStyles,
          children: (0, import_jsx_runtime4.jsxs)(AvatarStylesProvider, { value: styles, children: [
            (0, import_jsx_runtime4.jsx)(
              AvatarImage,
              {
                src,
                srcSet,
                loading,
                onLoad: (0, import_shared_utils.callAllHandlers)(onLoadProp, () => {
                  setIsLoaded(true);
                }),
                onError,
                getInitials,
                name,
                borderRadius,
                icon,
                iconLabel,
                ignoreFallback,
                crossOrigin
              }
            ),
            children
          ] })
        }
      );
    });
    Avatar.displayName = "Avatar";
    var import_system5 = require_dist12();
    var import_shared_utils2 = require_dist3();
    var import_jsx_runtime5 = require_jsx_runtime();
    var placementMap = {
      "top-start": {
        top: "0",
        insetStart: "0",
        transform: "translate(-25%, -25%)"
      },
      "top-end": {
        top: "0",
        insetEnd: "0",
        transform: "translate(25%, -25%)"
      },
      "bottom-start": {
        bottom: "0",
        insetStart: "0",
        transform: "translate(-25%, 25%)"
      },
      "bottom-end": {
        bottom: "0",
        insetEnd: "0",
        transform: "translate(25%, 25%)"
      }
    };
    var AvatarBadge = (0, import_system5.forwardRef)(
      function AvatarBadge2(props, ref) {
        const { placement = "bottom-end", className, ...rest } = props;
        const styles = useAvatarStyles();
        const placementStyles = placementMap[placement];
        const badgeStyles = {
          position: "absolute",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          ...placementStyles,
          ...styles.badge
        };
        return (0, import_jsx_runtime5.jsx)(
          import_system5.chakra.div,
          {
            ref,
            ...rest,
            className: (0, import_shared_utils2.cx)("chakra-avatar__badge", className),
            __css: badgeStyles
          }
        );
      }
    );
    AvatarBadge.displayName = "AvatarBadge";
    var import_system6 = require_dist12();
    var import_shared_utils3 = require_dist3();
    var import_react_children_utils = require_dist24();
    function compact(object) {
      const clone = Object.assign({}, object);
      for (let key in clone) {
        if (clone[key] === void 0)
          delete clone[key];
      }
      return clone;
    }
    var import_react3 = require_react();
    var import_jsx_runtime6 = require_jsx_runtime();
    var AvatarGroup = (0, import_system6.forwardRef)(
      function AvatarGroup2(props, ref) {
        const styles = (0, import_system6.useMultiStyleConfig)("Avatar", props);
        const {
          children,
          borderColor,
          max,
          spacing = "-0.75rem",
          borderRadius = "full",
          ...rest
        } = (0, import_system6.omitThemingProps)(props);
        const validChildren = (0, import_react_children_utils.getValidChildren)(children);
        const childrenWithinMax = max != null ? validChildren.slice(0, max) : validChildren;
        const excess = max != null ? validChildren.length - max : 0;
        const reversedChildren = childrenWithinMax.reverse();
        const clones = reversedChildren.map((child, index) => {
          var _a;
          const isFirstAvatar = index === 0;
          const childProps = {
            marginEnd: isFirstAvatar ? 0 : spacing,
            size: props.size,
            borderColor: (_a = child.props.borderColor) != null ? _a : borderColor,
            showBorder: true
          };
          return (0, import_react3.cloneElement)(child, compact(childProps));
        });
        const groupStyles = {
          display: "flex",
          alignItems: "center",
          justifyContent: "flex-end",
          flexDirection: "row-reverse",
          ...styles.group
        };
        const excessStyles = {
          borderRadius,
          marginStart: spacing,
          ...baseStyle,
          ...styles.excessLabel
        };
        return (0, import_jsx_runtime6.jsxs)(
          import_system6.chakra.div,
          {
            ref,
            role: "group",
            __css: groupStyles,
            ...rest,
            className: (0, import_shared_utils3.cx)("chakra-avatar__group", props.className),
            children: [
              excess > 0 && (0, import_jsx_runtime6.jsx)(import_system6.chakra.span, { className: "chakra-avatar__excess", __css: excessStyles, children: `+${excess}` }),
              clones
            ]
          }
        );
      }
    );
    AvatarGroup.displayName = "AvatarGroup";
  }
});

// ../../node_modules/@chakra-ui/breadcrumb/dist/index.js
var require_dist26 = __commonJS({
  "../../node_modules/@chakra-ui/breadcrumb/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Breadcrumb: () => Breadcrumb,
      BreadcrumbItem: () => BreadcrumbItem,
      BreadcrumbLink: () => BreadcrumbLink,
      BreadcrumbSeparator: () => BreadcrumbSeparator,
      useBreadcrumbStyles: () => useBreadcrumbStyles
    });
    module.exports = __toCommonJS2(src_exports);
    var import_shared_utils = require_dist3();
    var import_react_children_utils = require_dist24();
    var import_system = require_dist12();
    var import_react = require_react();
    var import_react_context = require_dist13();
    var [BreadcrumbStylesProvider, useBreadcrumbStyles] = (0, import_react_context.createContext)({
      name: `BreadcrumbStylesContext`,
      errorMessage: `useBreadcrumbStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Breadcrumb />" `
    });
    var import_jsx_runtime = require_jsx_runtime();
    var Breadcrumb = (0, import_system.forwardRef)(
      function Breadcrumb2(props, ref) {
        const styles = (0, import_system.useMultiStyleConfig)("Breadcrumb", props);
        const ownProps = (0, import_system.omitThemingProps)(props);
        const {
          children,
          spacing = "0.5rem",
          separator = "/",
          className,
          listProps,
          ...rest
        } = ownProps;
        const validChildren = (0, import_react_children_utils.getValidChildren)(children);
        const count = validChildren.length;
        const clones = validChildren.map(
          (child, index) => (0, import_react.cloneElement)(child, {
            separator,
            spacing,
            isLastChild: count === index + 1
          })
        );
        const _className = (0, import_shared_utils.cx)("chakra-breadcrumb", className);
        return (0, import_jsx_runtime.jsx)(
          import_system.chakra.nav,
          {
            ref,
            "aria-label": "breadcrumb",
            className: _className,
            __css: styles.container,
            ...rest,
            children: (0, import_jsx_runtime.jsx)(BreadcrumbStylesProvider, { value: styles, children: (0, import_jsx_runtime.jsx)(
              import_system.chakra.ol,
              {
                className: "chakra-breadcrumb__list",
                ...listProps,
                __css: {
                  display: "flex",
                  alignItems: "center",
                  ...styles.list
                },
                children: clones
              }
            ) })
          }
        );
      }
    );
    Breadcrumb.displayName = "Breadcrumb";
    var import_system4 = require_dist12();
    var import_react_children_utils2 = require_dist24();
    var import_shared_utils3 = require_dist3();
    var import_system2 = require_dist12();
    var import_jsx_runtime2 = require_jsx_runtime();
    var BreadcrumbSeparator = (0, import_system2.forwardRef)(
      function BreadcrumbSeparator2(props, ref) {
        const { spacing, ...rest } = props;
        const styles = useBreadcrumbStyles();
        const separatorStyles = {
          mx: spacing,
          ...styles.separator
        };
        return (0, import_jsx_runtime2.jsx)(
          import_system2.chakra.span,
          {
            ref,
            role: "presentation",
            ...rest,
            __css: separatorStyles
          }
        );
      }
    );
    BreadcrumbSeparator.displayName = "BreadcrumbSeparator";
    var import_system3 = require_dist12();
    var import_shared_utils2 = require_dist3();
    var import_jsx_runtime3 = require_jsx_runtime();
    var BreadcrumbLink = (0, import_system3.forwardRef)(
      function BreadcrumbLink2(props, ref) {
        const { isCurrentPage, as, className, href, ...rest } = props;
        const styles = useBreadcrumbStyles();
        const sharedProps = {
          ref,
          as,
          className: (0, import_shared_utils2.cx)("chakra-breadcrumb__link", className),
          ...rest
        };
        if (isCurrentPage) {
          return (0, import_jsx_runtime3.jsx)(import_system3.chakra.span, { "aria-current": "page", __css: styles.link, ...sharedProps });
        }
        return (0, import_jsx_runtime3.jsx)(import_system3.chakra.a, { __css: styles.link, href, ...sharedProps });
      }
    );
    BreadcrumbLink.displayName = "BreadcrumbLink";
    var import_react2 = require_react();
    var import_jsx_runtime4 = require_jsx_runtime();
    var BreadcrumbItem = (0, import_system4.forwardRef)(
      function BreadcrumbItem2(props, ref) {
        const {
          isCurrentPage,
          separator,
          isLastChild,
          spacing,
          children,
          className,
          ...rest
        } = props;
        const validChildren = (0, import_react_children_utils2.getValidChildren)(children);
        const clones = validChildren.map((child) => {
          if (child.type === BreadcrumbLink) {
            return (0, import_react2.cloneElement)(child, {
              isCurrentPage
            });
          }
          if (child.type === BreadcrumbSeparator) {
            return (0, import_react2.cloneElement)(child, {
              spacing,
              children: child.props.children || separator
            });
          }
          return child;
        });
        const styles = useBreadcrumbStyles();
        const itemStyles = {
          display: "inline-flex",
          alignItems: "center",
          ...styles.item
        };
        const _className = (0, import_shared_utils3.cx)("chakra-breadcrumb__list-item", className);
        return (0, import_jsx_runtime4.jsxs)(import_system4.chakra.li, { ref, className: _className, ...rest, __css: itemStyles, children: [
          clones,
          !isLastChild && (0, import_jsx_runtime4.jsx)(BreadcrumbSeparator, { spacing, children: separator })
        ] });
      }
    );
    BreadcrumbItem.displayName = "BreadcrumbItem";
  }
});

// ../../node_modules/@chakra-ui/button/dist/index.js
var require_dist27 = __commonJS({
  "../../node_modules/@chakra-ui/button/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Button: () => Button,
      ButtonGroup: () => ButtonGroup,
      ButtonSpinner: () => ButtonSpinner,
      IconButton: () => IconButton,
      useButtonGroup: () => useButtonGroup
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react_use_merge_refs = require_dist14();
    var import_system3 = require_dist12();
    var import_shared_utils3 = require_dist3();
    var import_react4 = require_react();
    var import_react_context = require_dist13();
    var [ButtonGroupProvider, useButtonGroup] = (0, import_react_context.createContext)({
      strict: false,
      name: "ButtonGroupContext"
    });
    var import_system = require_dist12();
    var import_shared_utils = require_dist3();
    var import_react = require_react();
    var import_jsx_runtime = require_jsx_runtime();
    function ButtonIcon(props) {
      const { children, className, ...rest } = props;
      const _children = (0, import_react.isValidElement)(children) ? (0, import_react.cloneElement)(children, {
        "aria-hidden": true,
        focusable: false
      }) : children;
      const _className = (0, import_shared_utils.cx)("chakra-button__icon", className);
      return (0, import_jsx_runtime.jsx)(
        import_system.chakra.span,
        {
          display: "inline-flex",
          alignSelf: "center",
          flexShrink: 0,
          ...rest,
          className: _className,
          children: _children
        }
      );
    }
    ButtonIcon.displayName = "ButtonIcon";
    var import_spinner = require_dist21();
    var import_system2 = require_dist12();
    var import_shared_utils2 = require_dist3();
    var import_react2 = require_react();
    var import_jsx_runtime2 = require_jsx_runtime();
    function ButtonSpinner(props) {
      const {
        label,
        placement,
        spacing = "0.5rem",
        children = (0, import_jsx_runtime2.jsx)(import_spinner.Spinner, { color: "currentColor", width: "1em", height: "1em" }),
        className,
        __css,
        ...rest
      } = props;
      const _className = (0, import_shared_utils2.cx)("chakra-button__spinner", className);
      const marginProp = placement === "start" ? "marginEnd" : "marginStart";
      const spinnerStyles = (0, import_react2.useMemo)(
        () => ({
          display: "flex",
          alignItems: "center",
          position: label ? "relative" : "absolute",
          [marginProp]: label ? spacing : 0,
          fontSize: "1em",
          lineHeight: "normal",
          ...__css
        }),
        [__css, label, marginProp, spacing]
      );
      return (0, import_jsx_runtime2.jsx)(import_system2.chakra.div, { className: _className, ...rest, __css: spinnerStyles, children });
    }
    ButtonSpinner.displayName = "ButtonSpinner";
    var import_react3 = require_react();
    function useButtonType(value) {
      const [isButton, setIsButton] = (0, import_react3.useState)(!value);
      const refCallback = (0, import_react3.useCallback)((node) => {
        if (!node)
          return;
        setIsButton(node.tagName === "BUTTON");
      }, []);
      const type = isButton ? "button" : void 0;
      return { ref: refCallback, type };
    }
    var import_jsx_runtime3 = require_jsx_runtime();
    var Button = (0, import_system3.forwardRef)((props, ref) => {
      const group = useButtonGroup();
      const styles = (0, import_system3.useStyleConfig)("Button", { ...group, ...props });
      const {
        isDisabled = group == null ? void 0 : group.isDisabled,
        isLoading,
        isActive,
        children,
        leftIcon,
        rightIcon,
        loadingText,
        iconSpacing = "0.5rem",
        type,
        spinner,
        spinnerPlacement = "start",
        className,
        as,
        ...rest
      } = (0, import_system3.omitThemingProps)(props);
      const buttonStyles = (0, import_react4.useMemo)(() => {
        const _focus = { ...styles == null ? void 0 : styles["_focus"], zIndex: 1 };
        return {
          display: "inline-flex",
          appearance: "none",
          alignItems: "center",
          justifyContent: "center",
          userSelect: "none",
          position: "relative",
          whiteSpace: "nowrap",
          verticalAlign: "middle",
          outline: "none",
          ...styles,
          ...!!group && { _focus }
        };
      }, [styles, group]);
      const { ref: _ref, type: defaultType } = useButtonType(as);
      const contentProps = { rightIcon, leftIcon, iconSpacing, children };
      return (0, import_jsx_runtime3.jsxs)(
        import_system3.chakra.button,
        {
          ref: (0, import_react_use_merge_refs.useMergeRefs)(ref, _ref),
          as,
          type: type != null ? type : defaultType,
          "data-active": (0, import_shared_utils3.dataAttr)(isActive),
          "data-loading": (0, import_shared_utils3.dataAttr)(isLoading),
          __css: buttonStyles,
          className: (0, import_shared_utils3.cx)("chakra-button", className),
          ...rest,
          disabled: isDisabled || isLoading,
          children: [
            isLoading && spinnerPlacement === "start" && (0, import_jsx_runtime3.jsx)(
              ButtonSpinner,
              {
                className: "chakra-button__spinner--start",
                label: loadingText,
                placement: "start",
                spacing: iconSpacing,
                children: spinner
              }
            ),
            isLoading ? loadingText || (0, import_jsx_runtime3.jsx)(import_system3.chakra.span, { opacity: 0, children: (0, import_jsx_runtime3.jsx)(ButtonContent, { ...contentProps }) }) : (0, import_jsx_runtime3.jsx)(ButtonContent, { ...contentProps }),
            isLoading && spinnerPlacement === "end" && (0, import_jsx_runtime3.jsx)(
              ButtonSpinner,
              {
                className: "chakra-button__spinner--end",
                label: loadingText,
                placement: "end",
                spacing: iconSpacing,
                children: spinner
              }
            )
          ]
        }
      );
    });
    Button.displayName = "Button";
    function ButtonContent(props) {
      const { leftIcon, rightIcon, children, iconSpacing } = props;
      return (0, import_jsx_runtime3.jsxs)(import_jsx_runtime3.Fragment, { children: [
        leftIcon && (0, import_jsx_runtime3.jsx)(ButtonIcon, { marginEnd: iconSpacing, children: leftIcon }),
        children,
        rightIcon && (0, import_jsx_runtime3.jsx)(ButtonIcon, { marginStart: iconSpacing, children: rightIcon })
      ] });
    }
    var import_system4 = require_dist12();
    var import_shared_utils4 = require_dist3();
    var import_react5 = require_react();
    var import_jsx_runtime4 = require_jsx_runtime();
    var attachedStyles = {
      horizontal: {
        "> *:first-of-type:not(:last-of-type)": { borderEndRadius: 0 },
        "> *:not(:first-of-type):not(:last-of-type)": { borderRadius: 0 },
        "> *:not(:first-of-type):last-of-type": { borderStartRadius: 0 }
      },
      vertical: {
        "> *:first-of-type:not(:last-of-type)": { borderBottomRadius: 0 },
        "> *:not(:first-of-type):not(:last-of-type)": { borderRadius: 0 },
        "> *:not(:first-of-type):last-of-type": { borderTopRadius: 0 }
      }
    };
    var gapStyles = {
      horizontal: (spacing) => ({
        "& > *:not(style) ~ *:not(style)": { marginStart: spacing }
      }),
      vertical: (spacing) => ({
        "& > *:not(style) ~ *:not(style)": { marginTop: spacing }
      })
    };
    var ButtonGroup = (0, import_system4.forwardRef)(
      function ButtonGroup2(props, ref) {
        const {
          size,
          colorScheme,
          variant,
          className,
          spacing = "0.5rem",
          isAttached,
          isDisabled,
          orientation = "horizontal",
          ...rest
        } = props;
        const _className = (0, import_shared_utils4.cx)("chakra-button__group", className);
        const context = (0, import_react5.useMemo)(
          () => ({ size, colorScheme, variant, isDisabled }),
          [size, colorScheme, variant, isDisabled]
        );
        let groupStyles = {
          display: "inline-flex",
          ...isAttached ? attachedStyles[orientation] : gapStyles[orientation](spacing)
        };
        const isVertical = orientation === "vertical";
        return (0, import_jsx_runtime4.jsx)(ButtonGroupProvider, { value: context, children: (0, import_jsx_runtime4.jsx)(
          import_system4.chakra.div,
          {
            ref,
            role: "group",
            __css: groupStyles,
            className: _className,
            "data-attached": isAttached ? "" : void 0,
            "data-orientation": orientation,
            flexDir: isVertical ? "column" : void 0,
            ...rest
          }
        ) });
      }
    );
    ButtonGroup.displayName = "ButtonGroup";
    var import_system5 = require_dist12();
    var import_react6 = require_react();
    var import_jsx_runtime5 = require_jsx_runtime();
    var IconButton = (0, import_system5.forwardRef)(
      (props, ref) => {
        const { icon, children, isRound, "aria-label": ariaLabel, ...rest } = props;
        const element = icon || children;
        const _children = (0, import_react6.isValidElement)(element) ? (0, import_react6.cloneElement)(element, {
          "aria-hidden": true,
          focusable: false
        }) : null;
        return (0, import_jsx_runtime5.jsx)(
          Button,
          {
            padding: "0",
            borderRadius: isRound ? "full" : void 0,
            ref,
            "aria-label": ariaLabel,
            ...rest,
            children: _children
          }
        );
      }
    );
    IconButton.displayName = "IconButton";
  }
});

// ../../node_modules/@chakra-ui/card/dist/index.js
var require_dist28 = __commonJS({
  "../../node_modules/@chakra-ui/card/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Card: () => Card,
      CardBody: () => CardBody,
      CardFooter: () => CardFooter,
      CardHeader: () => CardHeader,
      useCardStyles: () => useCardStyles
    });
    module.exports = __toCommonJS2(src_exports);
    var import_shared_utils = require_dist3();
    var import_system2 = require_dist12();
    var import_system = require_dist12();
    var [CardStylesProvider, useCardStyles] = (0, import_system.createStylesContext)("Card");
    var import_jsx_runtime = require_jsx_runtime();
    var Card = (0, import_system2.forwardRef)(function Card2(props, ref) {
      const {
        className,
        children,
        direction = "column",
        justify,
        align,
        ...rest
      } = (0, import_system2.omitThemingProps)(props);
      const styles = (0, import_system2.useMultiStyleConfig)("Card", props);
      return (0, import_jsx_runtime.jsx)(
        import_system2.chakra.div,
        {
          ref,
          className: (0, import_shared_utils.cx)("chakra-card", className),
          __css: {
            display: "flex",
            flexDirection: direction,
            justifyContent: justify,
            alignItems: align,
            position: "relative",
            minWidth: 0,
            wordWrap: "break-word",
            ...styles.container
          },
          ...rest,
          children: (0, import_jsx_runtime.jsx)(CardStylesProvider, { value: styles, children })
        }
      );
    });
    var import_shared_utils2 = require_dist3();
    var import_system3 = require_dist12();
    var import_jsx_runtime2 = require_jsx_runtime();
    var CardBody = (0, import_system3.forwardRef)(function CardBody2(props, ref) {
      const { className, ...rest } = props;
      const styles = useCardStyles();
      return (0, import_jsx_runtime2.jsx)(
        import_system3.chakra.div,
        {
          ref,
          className: (0, import_shared_utils2.cx)("chakra-card__body", className),
          __css: styles.body,
          ...rest
        }
      );
    });
    var import_shared_utils3 = require_dist3();
    var import_system4 = require_dist12();
    var import_jsx_runtime3 = require_jsx_runtime();
    var CardFooter = (0, import_system4.forwardRef)(
      function CardFooter2(props, ref) {
        const { className, justify, ...rest } = props;
        const styles = useCardStyles();
        return (0, import_jsx_runtime3.jsx)(
          import_system4.chakra.div,
          {
            ref,
            className: (0, import_shared_utils3.cx)("chakra-card__footer", className),
            __css: {
              display: "flex",
              justifyContent: justify,
              ...styles.footer
            },
            ...rest
          }
        );
      }
    );
    var import_shared_utils4 = require_dist3();
    var import_system5 = require_dist12();
    var import_jsx_runtime4 = require_jsx_runtime();
    var CardHeader = (0, import_system5.forwardRef)(
      function CardHeader2(props, ref) {
        const { className, ...rest } = props;
        const styles = useCardStyles();
        return (0, import_jsx_runtime4.jsx)(
          import_system5.chakra.div,
          {
            ref,
            className: (0, import_shared_utils4.cx)("chakra-card__header", className),
            __css: styles.header,
            ...rest
          }
        );
      }
    );
  }
});

// ../../node_modules/@chakra-ui/form-control/dist/index.js
var require_dist29 = __commonJS({
  "../../node_modules/@chakra-ui/form-control/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      FormControl: () => FormControl,
      FormErrorIcon: () => FormErrorIcon,
      FormErrorMessage: () => FormErrorMessage,
      FormHelperText: () => FormHelperText,
      FormLabel: () => FormLabel,
      RequiredIndicator: () => RequiredIndicator,
      useFormControl: () => useFormControl,
      useFormControlContext: () => useFormControlContext,
      useFormControlProps: () => useFormControlProps,
      useFormControlStyles: () => useFormControlStyles,
      useFormErrorStyles: () => useFormErrorStyles
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react_context = require_dist13();
    var import_react_use_merge_refs = require_dist14();
    var import_system = require_dist12();
    var import_shared_utils = require_dist3();
    var import_react = require_react();
    var import_jsx_runtime = require_jsx_runtime();
    var [FormControlStylesProvider, useFormControlStyles] = (0, import_react_context.createContext)({
      name: `FormControlStylesContext`,
      errorMessage: `useFormControlStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormControl />" `
    });
    var [FormControlProvider, useFormControlContext] = (0, import_react_context.createContext)({
      strict: false,
      name: "FormControlContext"
    });
    function useFormControlProvider(props) {
      const {
        id: idProp,
        isRequired,
        isInvalid,
        isDisabled,
        isReadOnly,
        ...htmlProps
      } = props;
      const uuid = (0, import_react.useId)();
      const id = idProp || `field-${uuid}`;
      const labelId = `${id}-label`;
      const feedbackId = `${id}-feedback`;
      const helpTextId = `${id}-helptext`;
      const [hasFeedbackText, setHasFeedbackText] = (0, import_react.useState)(false);
      const [hasHelpText, setHasHelpText] = (0, import_react.useState)(false);
      const [isFocused, setFocus] = (0, import_react.useState)(false);
      const getHelpTextProps = (0, import_react.useCallback)(
        (props2 = {}, forwardedRef = null) => ({
          id: helpTextId,
          ...props2,
          ref: (0, import_react_use_merge_refs.mergeRefs)(forwardedRef, (node) => {
            if (!node)
              return;
            setHasHelpText(true);
          })
        }),
        [helpTextId]
      );
      const getLabelProps = (0, import_react.useCallback)(
        (props2 = {}, forwardedRef = null) => ({
          ...props2,
          ref: forwardedRef,
          "data-focus": (0, import_shared_utils.dataAttr)(isFocused),
          "data-disabled": (0, import_shared_utils.dataAttr)(isDisabled),
          "data-invalid": (0, import_shared_utils.dataAttr)(isInvalid),
          "data-readonly": (0, import_shared_utils.dataAttr)(isReadOnly),
          id: props2.id !== void 0 ? props2.id : labelId,
          htmlFor: props2.htmlFor !== void 0 ? props2.htmlFor : id
        }),
        [id, isDisabled, isFocused, isInvalid, isReadOnly, labelId]
      );
      const getErrorMessageProps = (0, import_react.useCallback)(
        (props2 = {}, forwardedRef = null) => ({
          id: feedbackId,
          ...props2,
          ref: (0, import_react_use_merge_refs.mergeRefs)(forwardedRef, (node) => {
            if (!node)
              return;
            setHasFeedbackText(true);
          }),
          "aria-live": "polite"
        }),
        [feedbackId]
      );
      const getRootProps = (0, import_react.useCallback)(
        (props2 = {}, forwardedRef = null) => ({
          ...props2,
          ...htmlProps,
          ref: forwardedRef,
          role: "group"
        }),
        [htmlProps]
      );
      const getRequiredIndicatorProps = (0, import_react.useCallback)(
        (props2 = {}, forwardedRef = null) => ({
          ...props2,
          ref: forwardedRef,
          role: "presentation",
          "aria-hidden": true,
          children: props2.children || "*"
        }),
        []
      );
      return {
        isRequired: !!isRequired,
        isInvalid: !!isInvalid,
        isReadOnly: !!isReadOnly,
        isDisabled: !!isDisabled,
        isFocused: !!isFocused,
        onFocus: () => setFocus(true),
        onBlur: () => setFocus(false),
        hasFeedbackText,
        setHasFeedbackText,
        hasHelpText,
        setHasHelpText,
        id,
        labelId,
        feedbackId,
        helpTextId,
        htmlProps,
        getHelpTextProps,
        getErrorMessageProps,
        getRootProps,
        getLabelProps,
        getRequiredIndicatorProps
      };
    }
    var FormControl = (0, import_system.forwardRef)(
      function FormControl2(props, ref) {
        const styles = (0, import_system.useMultiStyleConfig)("Form", props);
        const ownProps = (0, import_system.omitThemingProps)(props);
        const {
          getRootProps,
          htmlProps: _,
          ...context
        } = useFormControlProvider(ownProps);
        const className = (0, import_shared_utils.cx)("chakra-form-control", props.className);
        return (0, import_jsx_runtime.jsx)(FormControlProvider, { value: context, children: (0, import_jsx_runtime.jsx)(FormControlStylesProvider, { value: styles, children: (0, import_jsx_runtime.jsx)(
          import_system.chakra.div,
          {
            ...getRootProps({}, ref),
            className,
            __css: styles["container"]
          }
        ) }) });
      }
    );
    FormControl.displayName = "FormControl";
    var FormHelperText = (0, import_system.forwardRef)(
      function FormHelperText2(props, ref) {
        const field = useFormControlContext();
        const styles = useFormControlStyles();
        const className = (0, import_shared_utils.cx)("chakra-form__helper-text", props.className);
        return (0, import_jsx_runtime.jsx)(
          import_system.chakra.div,
          {
            ...field == null ? void 0 : field.getHelpTextProps(props, ref),
            __css: styles.helperText,
            className
          }
        );
      }
    );
    FormHelperText.displayName = "FormHelperText";
    var import_shared_utils2 = require_dist3();
    function useFormControl(props) {
      const { isDisabled, isInvalid, isReadOnly, isRequired, ...rest } = useFormControlProps(props);
      return {
        ...rest,
        disabled: isDisabled,
        readOnly: isReadOnly,
        required: isRequired,
        "aria-invalid": (0, import_shared_utils2.ariaAttr)(isInvalid),
        "aria-required": (0, import_shared_utils2.ariaAttr)(isRequired),
        "aria-readonly": (0, import_shared_utils2.ariaAttr)(isReadOnly)
      };
    }
    function useFormControlProps(props) {
      var _a, _b, _c;
      const field = useFormControlContext();
      const {
        id,
        disabled,
        readOnly,
        required,
        isRequired,
        isInvalid,
        isReadOnly,
        isDisabled,
        onFocus,
        onBlur,
        ...rest
      } = props;
      const labelIds = props["aria-describedby"] ? [props["aria-describedby"]] : [];
      if ((field == null ? void 0 : field.hasFeedbackText) && (field == null ? void 0 : field.isInvalid)) {
        labelIds.push(field.feedbackId);
      }
      if (field == null ? void 0 : field.hasHelpText) {
        labelIds.push(field.helpTextId);
      }
      return {
        ...rest,
        "aria-describedby": labelIds.join(" ") || void 0,
        id: id != null ? id : field == null ? void 0 : field.id,
        isDisabled: (_a = disabled != null ? disabled : isDisabled) != null ? _a : field == null ? void 0 : field.isDisabled,
        isReadOnly: (_b = readOnly != null ? readOnly : isReadOnly) != null ? _b : field == null ? void 0 : field.isReadOnly,
        isRequired: (_c = required != null ? required : isRequired) != null ? _c : field == null ? void 0 : field.isRequired,
        isInvalid: isInvalid != null ? isInvalid : field == null ? void 0 : field.isInvalid,
        onFocus: (0, import_shared_utils2.callAllHandlers)(field == null ? void 0 : field.onFocus, onFocus),
        onBlur: (0, import_shared_utils2.callAllHandlers)(field == null ? void 0 : field.onBlur, onBlur)
      };
    }
    var import_icon = require_dist18();
    var import_react_context2 = require_dist13();
    var import_system2 = require_dist12();
    var import_shared_utils3 = require_dist3();
    var import_jsx_runtime2 = require_jsx_runtime();
    var [FormErrorStylesProvider, useFormErrorStyles] = (0, import_react_context2.createContext)({
      name: `FormErrorStylesContext`,
      errorMessage: `useFormErrorStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormError />" `
    });
    var FormErrorMessage = (0, import_system2.forwardRef)(
      (props, ref) => {
        const styles = (0, import_system2.useMultiStyleConfig)("FormError", props);
        const ownProps = (0, import_system2.omitThemingProps)(props);
        const field = useFormControlContext();
        if (!(field == null ? void 0 : field.isInvalid))
          return null;
        return (0, import_jsx_runtime2.jsx)(FormErrorStylesProvider, { value: styles, children: (0, import_jsx_runtime2.jsx)(
          import_system2.chakra.div,
          {
            ...field == null ? void 0 : field.getErrorMessageProps(ownProps, ref),
            className: (0, import_shared_utils3.cx)("chakra-form__error-message", props.className),
            __css: {
              display: "flex",
              alignItems: "center",
              ...styles.text
            }
          }
        ) });
      }
    );
    FormErrorMessage.displayName = "FormErrorMessage";
    var FormErrorIcon = (0, import_system2.forwardRef)((props, ref) => {
      const styles = useFormErrorStyles();
      const field = useFormControlContext();
      if (!(field == null ? void 0 : field.isInvalid))
        return null;
      const _className = (0, import_shared_utils3.cx)("chakra-form__error-icon", props.className);
      return (0, import_jsx_runtime2.jsx)(
        import_icon.Icon,
        {
          ref,
          "aria-hidden": true,
          ...props,
          __css: styles.icon,
          className: _className,
          children: (0, import_jsx_runtime2.jsx)(
            "path",
            {
              fill: "currentColor",
              d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
            }
          )
        }
      );
    });
    FormErrorIcon.displayName = "FormErrorIcon";
    var import_system3 = require_dist12();
    var import_shared_utils4 = require_dist3();
    var import_jsx_runtime3 = require_jsx_runtime();
    var FormLabel = (0, import_system3.forwardRef)(function FormLabel2(passedProps, ref) {
      var _a;
      const styles = (0, import_system3.useStyleConfig)("FormLabel", passedProps);
      const props = (0, import_system3.omitThemingProps)(passedProps);
      const {
        className,
        children,
        requiredIndicator = (0, import_jsx_runtime3.jsx)(RequiredIndicator, {}),
        optionalIndicator = null,
        ...rest
      } = props;
      const field = useFormControlContext();
      const ownProps = (_a = field == null ? void 0 : field.getLabelProps(rest, ref)) != null ? _a : { ref, ...rest };
      return (0, import_jsx_runtime3.jsxs)(
        import_system3.chakra.label,
        {
          ...ownProps,
          className: (0, import_shared_utils4.cx)("chakra-form__label", props.className),
          __css: {
            display: "block",
            textAlign: "start",
            ...styles
          },
          children: [
            children,
            (field == null ? void 0 : field.isRequired) ? requiredIndicator : optionalIndicator
          ]
        }
      );
    });
    FormLabel.displayName = "FormLabel";
    var RequiredIndicator = (0, import_system3.forwardRef)(
      function RequiredIndicator2(props, ref) {
        const field = useFormControlContext();
        const styles = useFormControlStyles();
        if (!(field == null ? void 0 : field.isRequired))
          return null;
        const className = (0, import_shared_utils4.cx)("chakra-form__required-indicator", props.className);
        return (0, import_jsx_runtime3.jsx)(
          import_system3.chakra.span,
          {
            ...field == null ? void 0 : field.getRequiredIndicatorProps(props, ref),
            __css: styles.requiredIndicator,
            className
          }
        );
      }
    );
    RequiredIndicator.displayName = "RequiredIndicator";
  }
});

// ../../node_modules/@chakra-ui/react-use-update-effect/dist/index.js
var require_dist30 = __commonJS({
  "../../node_modules/@chakra-ui/react-use-update-effect/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      useUpdateEffect: () => useUpdateEffect
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react = require_react();
    function useUpdateEffect(callback, deps) {
      const renderCycleRef = (0, import_react.useRef)(false);
      const effectCycleRef = (0, import_react.useRef)(false);
      (0, import_react.useEffect)(() => {
        const mounted = renderCycleRef.current;
        const run = mounted && effectCycleRef.current;
        if (run) {
          return callback();
        }
        effectCycleRef.current = true;
      }, deps);
      (0, import_react.useEffect)(() => {
        renderCycleRef.current = true;
        return () => {
          renderCycleRef.current = false;
        };
      }, []);
    }
  }
});

// ../../node_modules/@chakra-ui/visually-hidden/dist/index.js
var require_dist31 = __commonJS({
  "../../node_modules/@chakra-ui/visually-hidden/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      VisuallyHidden: () => VisuallyHidden,
      VisuallyHiddenInput: () => VisuallyHiddenInput,
      default: () => visually_hidden_default,
      visuallyHiddenStyle: () => visuallyHiddenStyle
    });
    module.exports = __toCommonJS2(src_exports);
    var import_system = require_dist12();
    var visuallyHiddenStyle = {
      border: "0",
      clip: "rect(0, 0, 0, 0)",
      height: "1px",
      width: "1px",
      margin: "-1px",
      padding: "0",
      overflow: "hidden",
      whiteSpace: "nowrap",
      position: "absolute"
    };
    var VisuallyHidden = (0, import_system.chakra)("span", {
      baseStyle: visuallyHiddenStyle
    });
    VisuallyHidden.displayName = "VisuallyHidden";
    var VisuallyHiddenInput = (0, import_system.chakra)("input", {
      baseStyle: visuallyHiddenStyle
    });
    VisuallyHiddenInput.displayName = "VisuallyHiddenInput";
    var visually_hidden_default = VisuallyHidden;
  }
});

// ../../node_modules/@zag-js/focus-visible/dist/index.js
var require_dist32 = __commonJS({
  "../../node_modules/@zag-js/focus-visible/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      getInteractionModality: () => getInteractionModality,
      setInteractionModality: () => setInteractionModality,
      trackFocusVisible: () => trackFocusVisible,
      trackInteractionModality: () => trackInteractionModality
    });
    module.exports = __toCommonJS2(src_exports);
    var hasSetup = false;
    var modality = null;
    var hasEventBeforeFocus = false;
    var hasBlurredWindowRecently = false;
    var handlers = /* @__PURE__ */ new Set();
    function trigger(modality2, event) {
      handlers.forEach((handler) => handler(modality2, event));
    }
    var isMac = typeof window !== "undefined" && window.navigator != null ? /^Mac/.test(window.navigator.platform) : false;
    function isValidKey(e) {
      return !(e.metaKey || !isMac && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
    }
    function onKeyboardEvent(event) {
      hasEventBeforeFocus = true;
      if (isValidKey(event)) {
        modality = "keyboard";
        trigger("keyboard", event);
      }
    }
    function onPointerEvent(event) {
      modality = "pointer";
      if (event.type === "mousedown" || event.type === "pointerdown") {
        hasEventBeforeFocus = true;
        const target = event.composedPath ? event.composedPath()[0] : event.target;
        let matches = false;
        try {
          matches = target.matches(":focus-visible");
        } catch {
        }
        if (matches)
          return;
        trigger("pointer", event);
      }
    }
    function isVirtualClick(event) {
      if (event.mozInputSource === 0 && event.isTrusted)
        return true;
      return event.detail === 0 && !event.pointerType;
    }
    function onClickEvent(e) {
      if (isVirtualClick(e)) {
        hasEventBeforeFocus = true;
        modality = "virtual";
      }
    }
    function onWindowFocus(event) {
      if (event.target === window || event.target === document) {
        return;
      }
      if (!hasEventBeforeFocus && !hasBlurredWindowRecently) {
        modality = "virtual";
        trigger("virtual", event);
      }
      hasEventBeforeFocus = false;
      hasBlurredWindowRecently = false;
    }
    function onWindowBlur() {
      hasEventBeforeFocus = false;
      hasBlurredWindowRecently = true;
    }
    function isFocusVisible() {
      return modality !== "pointer";
    }
    function setupGlobalFocusEvents() {
      if (typeof window === "undefined" || hasSetup) {
        return;
      }
      const { focus } = HTMLElement.prototype;
      HTMLElement.prototype.focus = function focusElement(...args) {
        hasEventBeforeFocus = true;
        focus.apply(this, args);
      };
      document.addEventListener("keydown", onKeyboardEvent, true);
      document.addEventListener("keyup", onKeyboardEvent, true);
      document.addEventListener("click", onClickEvent, true);
      window.addEventListener("focus", onWindowFocus, true);
      window.addEventListener("blur", onWindowBlur, false);
      if (typeof PointerEvent !== "undefined") {
        document.addEventListener("pointerdown", onPointerEvent, true);
        document.addEventListener("pointermove", onPointerEvent, true);
        document.addEventListener("pointerup", onPointerEvent, true);
      } else {
        document.addEventListener("mousedown", onPointerEvent, true);
        document.addEventListener("mousemove", onPointerEvent, true);
        document.addEventListener("mouseup", onPointerEvent, true);
      }
      hasSetup = true;
    }
    function trackFocusVisible(fn) {
      setupGlobalFocusEvents();
      fn(isFocusVisible());
      const handler = () => fn(isFocusVisible());
      handlers.add(handler);
      return () => {
        handlers.delete(handler);
      };
    }
    function trackInteractionModality(fn) {
      setupGlobalFocusEvents();
      fn(modality);
      const handler = () => fn(modality);
      handlers.add(handler);
      return () => {
        handlers.delete(handler);
      };
    }
    function setInteractionModality(value) {
      modality = value;
      trigger(value, null);
    }
    function getInteractionModality() {
      return modality;
    }
  }
});

// ../../node_modules/@chakra-ui/checkbox/dist/index.js
var require_dist33 = __commonJS({
  "../../node_modules/@chakra-ui/checkbox/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Checkbox: () => Checkbox,
      CheckboxGroup: () => CheckboxGroup,
      CheckboxIcon: () => CheckboxIcon,
      useCheckbox: () => useCheckbox,
      useCheckboxGroup: () => useCheckboxGroup
    });
    module.exports = __toCommonJS2(src_exports);
    var import_shared_utils2 = require_dist3();
    var import_system2 = require_dist12();
    var import_react3 = require_react();
    var import_react_context = require_dist13();
    var [CheckboxGroupProvider, useCheckboxGroupContext] = (0, import_react_context.createContext)({
      name: "CheckboxGroupContext",
      strict: false
    });
    var import_system = require_dist12();
    var import_jsx_runtime = require_jsx_runtime();
    function CheckIcon(props) {
      return (0, import_jsx_runtime.jsx)(
        import_system.chakra.svg,
        {
          width: "1.2em",
          viewBox: "0 0 12 10",
          style: {
            fill: "none",
            strokeWidth: 2,
            stroke: "currentColor",
            strokeDasharray: 16
          },
          ...props,
          children: (0, import_jsx_runtime.jsx)("polyline", { points: "1.5 6 4.5 9 10.5 1" })
        }
      );
    }
    function IndeterminateIcon(props) {
      return (0, import_jsx_runtime.jsx)(
        import_system.chakra.svg,
        {
          width: "1.2em",
          viewBox: "0 0 24 24",
          style: { stroke: "currentColor", strokeWidth: 4 },
          ...props,
          children: (0, import_jsx_runtime.jsx)("line", { x1: "21", x2: "3", y1: "12", y2: "12" })
        }
      );
    }
    function CheckboxIcon(props) {
      const { isIndeterminate, isChecked, ...rest } = props;
      const BaseIcon = isIndeterminate ? IndeterminateIcon : CheckIcon;
      return isChecked || isIndeterminate ? (0, import_jsx_runtime.jsx)(
        import_system.chakra.div,
        {
          style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            height: "100%"
          },
          children: (0, import_jsx_runtime.jsx)(BaseIcon, { ...rest })
        }
      ) : null;
    }
    var import_form_control = require_dist29();
    var import_react_use_safe_layout_effect = require_dist();
    var import_react_use_update_effect = require_dist30();
    var import_react_use_callback_ref = require_dist16();
    var import_react_use_merge_refs = require_dist14();
    var import_shared_utils = require_dist3();
    function omit(object, keysToOmit = []) {
      const clone = Object.assign({}, object);
      for (const key of keysToOmit) {
        if (key in clone) {
          delete clone[key];
        }
      }
      return clone;
    }
    var import_visually_hidden = require_dist31();
    var import_focus_visible = require_dist32();
    var import_react = require_react();
    function useCheckbox(props = {}) {
      const formControlProps = (0, import_form_control.useFormControlProps)(props);
      const {
        isDisabled,
        isReadOnly,
        isRequired,
        isInvalid,
        id,
        onBlur,
        onFocus,
        "aria-describedby": ariaDescribedBy
      } = formControlProps;
      const {
        defaultChecked,
        isChecked: checkedProp,
        isFocusable,
        onChange,
        isIndeterminate,
        name,
        value,
        tabIndex = void 0,
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-invalid": ariaInvalid,
        ...rest
      } = props;
      const htmlProps = omit(rest, [
        "isDisabled",
        "isReadOnly",
        "isRequired",
        "isInvalid",
        "id",
        "onBlur",
        "onFocus",
        "aria-describedby"
      ]);
      const onChangeProp = (0, import_react_use_callback_ref.useCallbackRef)(onChange);
      const onBlurProp = (0, import_react_use_callback_ref.useCallbackRef)(onBlur);
      const onFocusProp = (0, import_react_use_callback_ref.useCallbackRef)(onFocus);
      const [isFocusVisible, setIsFocusVisible] = (0, import_react.useState)(false);
      const [isFocused, setFocused] = (0, import_react.useState)(false);
      const [isHovered, setHovered] = (0, import_react.useState)(false);
      const [isActive, setActive] = (0, import_react.useState)(false);
      (0, import_react.useEffect)(() => {
        return (0, import_focus_visible.trackFocusVisible)(setIsFocusVisible);
      }, []);
      const inputRef = (0, import_react.useRef)(null);
      const [rootIsLabelElement, setRootIsLabelElement] = (0, import_react.useState)(true);
      const [checkedState, setCheckedState] = (0, import_react.useState)(!!defaultChecked);
      const isControlled = checkedProp !== void 0;
      const isChecked = isControlled ? checkedProp : checkedState;
      const handleChange = (0, import_react.useCallback)(
        (event) => {
          if (isReadOnly || isDisabled) {
            event.preventDefault();
            return;
          }
          if (!isControlled) {
            if (isChecked) {
              setCheckedState(event.target.checked);
            } else {
              setCheckedState(isIndeterminate ? true : event.target.checked);
            }
          }
          onChangeProp == null ? void 0 : onChangeProp(event);
        },
        [
          isReadOnly,
          isDisabled,
          isChecked,
          isControlled,
          isIndeterminate,
          onChangeProp
        ]
      );
      (0, import_react_use_safe_layout_effect.useSafeLayoutEffect)(() => {
        if (inputRef.current) {
          inputRef.current.indeterminate = Boolean(isIndeterminate);
        }
      }, [isIndeterminate]);
      (0, import_react_use_update_effect.useUpdateEffect)(() => {
        if (isDisabled) {
          setFocused(false);
        }
      }, [isDisabled, setFocused]);
      (0, import_react_use_safe_layout_effect.useSafeLayoutEffect)(() => {
        const el = inputRef.current;
        if (!(el == null ? void 0 : el.form))
          return;
        el.form.onreset = () => {
          setCheckedState(!!defaultChecked);
        };
      }, []);
      const trulyDisabled = isDisabled && !isFocusable;
      const onKeyDown = (0, import_react.useCallback)(
        (event) => {
          if (event.key === " ") {
            setActive(true);
          }
        },
        [setActive]
      );
      const onKeyUp = (0, import_react.useCallback)(
        (event) => {
          if (event.key === " ") {
            setActive(false);
          }
        },
        [setActive]
      );
      (0, import_react_use_safe_layout_effect.useSafeLayoutEffect)(() => {
        if (!inputRef.current)
          return;
        const notInSync = inputRef.current.checked !== isChecked;
        if (notInSync) {
          setCheckedState(inputRef.current.checked);
        }
      }, [inputRef.current]);
      const getCheckboxProps = (0, import_react.useCallback)(
        (props2 = {}, forwardedRef = null) => {
          const onPressDown = (event) => {
            if (isFocused) {
              event.preventDefault();
            }
            setActive(true);
          };
          return {
            ...props2,
            ref: forwardedRef,
            "data-active": (0, import_shared_utils.dataAttr)(isActive),
            "data-hover": (0, import_shared_utils.dataAttr)(isHovered),
            "data-checked": (0, import_shared_utils.dataAttr)(isChecked),
            "data-focus": (0, import_shared_utils.dataAttr)(isFocused),
            "data-focus-visible": (0, import_shared_utils.dataAttr)(isFocused && isFocusVisible),
            "data-indeterminate": (0, import_shared_utils.dataAttr)(isIndeterminate),
            "data-disabled": (0, import_shared_utils.dataAttr)(isDisabled),
            "data-invalid": (0, import_shared_utils.dataAttr)(isInvalid),
            "data-readonly": (0, import_shared_utils.dataAttr)(isReadOnly),
            "aria-hidden": true,
            onMouseDown: (0, import_shared_utils.callAllHandlers)(props2.onMouseDown, onPressDown),
            onMouseUp: (0, import_shared_utils.callAllHandlers)(props2.onMouseUp, () => setActive(false)),
            onMouseEnter: (0, import_shared_utils.callAllHandlers)(
              props2.onMouseEnter,
              () => setHovered(true)
            ),
            onMouseLeave: (0, import_shared_utils.callAllHandlers)(
              props2.onMouseLeave,
              () => setHovered(false)
            )
          };
        },
        [
          isActive,
          isChecked,
          isDisabled,
          isFocused,
          isFocusVisible,
          isHovered,
          isIndeterminate,
          isInvalid,
          isReadOnly
        ]
      );
      const getRootProps = (0, import_react.useCallback)(
        (props2 = {}, forwardedRef = null) => ({
          ...htmlProps,
          ...props2,
          ref: (0, import_react_use_merge_refs.mergeRefs)(forwardedRef, (node) => {
            if (!node)
              return;
            setRootIsLabelElement(node.tagName === "LABEL");
          }),
          onClick: (0, import_shared_utils.callAllHandlers)(props2.onClick, () => {
            var _a;
            if (!rootIsLabelElement) {
              (_a = inputRef.current) == null ? void 0 : _a.click();
              requestAnimationFrame(() => {
                var _a2;
                (_a2 = inputRef.current) == null ? void 0 : _a2.focus({ preventScroll: true });
              });
            }
          }),
          "data-disabled": (0, import_shared_utils.dataAttr)(isDisabled),
          "data-checked": (0, import_shared_utils.dataAttr)(isChecked),
          "data-invalid": (0, import_shared_utils.dataAttr)(isInvalid)
        }),
        [htmlProps, isDisabled, isChecked, isInvalid, rootIsLabelElement]
      );
      const getInputProps = (0, import_react.useCallback)(
        (props2 = {}, forwardedRef = null) => {
          return {
            ...props2,
            ref: (0, import_react_use_merge_refs.mergeRefs)(inputRef, forwardedRef),
            type: "checkbox",
            name,
            value,
            id,
            tabIndex,
            onChange: (0, import_shared_utils.callAllHandlers)(props2.onChange, handleChange),
            onBlur: (0, import_shared_utils.callAllHandlers)(
              props2.onBlur,
              onBlurProp,
              () => setFocused(false)
            ),
            onFocus: (0, import_shared_utils.callAllHandlers)(
              props2.onFocus,
              onFocusProp,
              () => setFocused(true)
            ),
            onKeyDown: (0, import_shared_utils.callAllHandlers)(props2.onKeyDown, onKeyDown),
            onKeyUp: (0, import_shared_utils.callAllHandlers)(props2.onKeyUp, onKeyUp),
            required: isRequired,
            checked: isChecked,
            disabled: trulyDisabled,
            readOnly: isReadOnly,
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-invalid": ariaInvalid ? Boolean(ariaInvalid) : isInvalid,
            "aria-describedby": ariaDescribedBy,
            "aria-disabled": isDisabled,
            style: import_visually_hidden.visuallyHiddenStyle
          };
        },
        [
          name,
          value,
          id,
          handleChange,
          onBlurProp,
          onFocusProp,
          onKeyDown,
          onKeyUp,
          isRequired,
          isChecked,
          trulyDisabled,
          isReadOnly,
          ariaLabel,
          ariaLabelledBy,
          ariaInvalid,
          isInvalid,
          ariaDescribedBy,
          isDisabled,
          tabIndex
        ]
      );
      const getLabelProps = (0, import_react.useCallback)(
        (props2 = {}, forwardedRef = null) => ({
          ...props2,
          ref: forwardedRef,
          onMouseDown: (0, import_shared_utils.callAllHandlers)(props2.onMouseDown, stopEvent),
          "data-disabled": (0, import_shared_utils.dataAttr)(isDisabled),
          "data-checked": (0, import_shared_utils.dataAttr)(isChecked),
          "data-invalid": (0, import_shared_utils.dataAttr)(isInvalid)
        }),
        [isChecked, isDisabled, isInvalid]
      );
      const state = {
        isInvalid,
        isFocused,
        isChecked,
        isActive,
        isHovered,
        isIndeterminate,
        isDisabled,
        isReadOnly,
        isRequired
      };
      return {
        state,
        getRootProps,
        getCheckboxProps,
        getInputProps,
        getLabelProps,
        htmlProps
      };
    }
    function stopEvent(event) {
      event.preventDefault();
      event.stopPropagation();
    }
    var import_react2 = require_react();
    function useInitialAnimationState(isChecked) {
      const [previousIsChecked, setPreviousIsChecked] = (0, import_react2.useState)(isChecked);
      const [shouldAnimate, setShouldAnimate] = (0, import_react2.useState)(false);
      if (isChecked !== previousIsChecked) {
        setShouldAnimate(true);
        setPreviousIsChecked(isChecked);
      }
      return shouldAnimate;
    }
    var import_jsx_runtime2 = require_jsx_runtime();
    var controlStyles = {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      verticalAlign: "top",
      userSelect: "none",
      flexShrink: 0
    };
    var rootStyles = {
      cursor: "pointer",
      display: "inline-flex",
      alignItems: "center",
      verticalAlign: "top",
      position: "relative"
    };
    var checkAnim = (0, import_system2.keyframes)({
      from: {
        opacity: 0,
        strokeDashoffset: 16,
        transform: "scale(0.95)"
      },
      to: {
        opacity: 1,
        strokeDashoffset: 0,
        transform: "scale(1)"
      }
    });
    var indeterminateOpacityAnim = (0, import_system2.keyframes)({
      from: {
        opacity: 0
      },
      to: {
        opacity: 1
      }
    });
    var indeterminateScaleAnim = (0, import_system2.keyframes)({
      from: {
        transform: "scaleX(0.65)"
      },
      to: {
        transform: "scaleX(1)"
      }
    });
    var Checkbox = (0, import_system2.forwardRef)(function Checkbox2(props, ref) {
      const group = useCheckboxGroupContext();
      const mergedProps = { ...group, ...props };
      const styles = (0, import_system2.useMultiStyleConfig)("Checkbox", mergedProps);
      const ownProps = (0, import_system2.omitThemingProps)(props);
      const {
        spacing = "0.5rem",
        className,
        children,
        iconColor,
        iconSize,
        icon = (0, import_jsx_runtime2.jsx)(CheckboxIcon, {}),
        isChecked: isCheckedProp,
        isDisabled = group == null ? void 0 : group.isDisabled,
        onChange: onChangeProp,
        inputProps,
        ...rest
      } = ownProps;
      let isChecked = isCheckedProp;
      if ((group == null ? void 0 : group.value) && ownProps.value) {
        isChecked = group.value.includes(ownProps.value);
      }
      let onChange = onChangeProp;
      if ((group == null ? void 0 : group.onChange) && ownProps.value) {
        onChange = (0, import_shared_utils2.callAll)(group.onChange, onChangeProp);
      }
      const {
        state,
        getInputProps,
        getCheckboxProps,
        getLabelProps,
        getRootProps
      } = useCheckbox({
        ...rest,
        isDisabled,
        isChecked,
        onChange
      });
      const shouldAnimate = useInitialAnimationState(state.isChecked);
      const iconStyles = (0, import_react3.useMemo)(
        () => ({
          animation: !shouldAnimate ? void 0 : state.isIndeterminate ? `${indeterminateOpacityAnim} 20ms linear, ${indeterminateScaleAnim} 200ms linear` : `${checkAnim} 200ms linear`,
          fontSize: iconSize,
          color: iconColor,
          ...styles.icon
        }),
        [iconColor, iconSize, shouldAnimate, state.isIndeterminate, styles.icon]
      );
      const clonedIcon = (0, import_react3.cloneElement)(icon, {
        __css: iconStyles,
        isIndeterminate: state.isIndeterminate,
        isChecked: state.isChecked
      });
      return (0, import_jsx_runtime2.jsxs)(
        import_system2.chakra.label,
        {
          __css: { ...rootStyles, ...styles.container },
          className: (0, import_shared_utils2.cx)("chakra-checkbox", className),
          ...getRootProps(),
          children: [
            (0, import_jsx_runtime2.jsx)(
              "input",
              {
                className: "chakra-checkbox__input",
                ...getInputProps(inputProps, ref)
              }
            ),
            (0, import_jsx_runtime2.jsx)(
              import_system2.chakra.span,
              {
                __css: { ...controlStyles, ...styles.control },
                className: "chakra-checkbox__control",
                ...getCheckboxProps(),
                children: clonedIcon
              }
            ),
            children && (0, import_jsx_runtime2.jsx)(
              import_system2.chakra.span,
              {
                className: "chakra-checkbox__label",
                ...getLabelProps(),
                __css: {
                  marginStart: spacing,
                  ...styles.label
                },
                children
              }
            )
          ]
        }
      );
    });
    Checkbox.displayName = "Checkbox";
    var import_react5 = require_react();
    var import_react_use_callback_ref2 = require_dist16();
    var import_react_use_controllable_state = require_dist17();
    var import_shared_utils3 = require_dist3();
    var import_react4 = require_react();
    function isInputEvent(value) {
      return value && (0, import_shared_utils3.isObject)(value) && (0, import_shared_utils3.isObject)(value.target);
    }
    function useCheckboxGroup(props = {}) {
      const {
        defaultValue,
        value: valueProp,
        onChange,
        isDisabled,
        isNative
      } = props;
      const onChangeProp = (0, import_react_use_callback_ref2.useCallbackRef)(onChange);
      const [value, setValue] = (0, import_react_use_controllable_state.useControllableState)({
        value: valueProp,
        defaultValue: defaultValue || [],
        onChange: onChangeProp
      });
      const handleChange = (0, import_react4.useCallback)(
        (eventOrValue) => {
          if (!value)
            return;
          const isChecked = isInputEvent(eventOrValue) ? eventOrValue.target.checked : !value.includes(eventOrValue);
          const selectedValue = isInputEvent(eventOrValue) ? eventOrValue.target.value : eventOrValue;
          const nextValue = isChecked ? [...value, selectedValue] : value.filter((v) => String(v) !== String(selectedValue));
          setValue(nextValue);
        },
        [setValue, value]
      );
      const getCheckboxProps = (0, import_react4.useCallback)(
        (props2 = {}) => {
          const checkedKey = isNative ? "checked" : "isChecked";
          return {
            ...props2,
            [checkedKey]: value.some((val) => String(props2.value) === String(val)),
            onChange: handleChange
          };
        },
        [handleChange, isNative, value]
      );
      return {
        value,
        isDisabled,
        onChange: handleChange,
        setValue,
        getCheckboxProps
      };
    }
    var import_jsx_runtime3 = require_jsx_runtime();
    function CheckboxGroup(props) {
      const { colorScheme, size, variant, children, isDisabled } = props;
      const { value, onChange } = useCheckboxGroup(props);
      const group = (0, import_react5.useMemo)(
        () => ({
          size,
          onChange,
          colorScheme,
          value,
          variant,
          isDisabled
        }),
        [size, onChange, colorScheme, value, variant, isDisabled]
      );
      return (0, import_jsx_runtime3.jsx)(CheckboxGroupProvider, { value: group, children });
    }
    CheckboxGroup.displayName = "CheckboxGroup";
  }
});

// ../../node_modules/@chakra-ui/close-button/dist/index.js
var require_dist34 = __commonJS({
  "../../node_modules/@chakra-ui/close-button/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      CloseButton: () => CloseButton
    });
    module.exports = __toCommonJS2(src_exports);
    var import_icon = require_dist18();
    var import_system = require_dist12();
    var import_jsx_runtime = require_jsx_runtime();
    function CloseIcon(props) {
      return (0, import_jsx_runtime.jsx)(import_icon.Icon, { focusable: "false", "aria-hidden": true, ...props, children: (0, import_jsx_runtime.jsx)(
        "path",
        {
          fill: "currentColor",
          d: "M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z"
        }
      ) });
    }
    var CloseButton = (0, import_system.forwardRef)(
      function CloseButton2(props, ref) {
        const styles = (0, import_system.useStyleConfig)("CloseButton", props);
        const { children, isDisabled, __css, ...rest } = (0, import_system.omitThemingProps)(props);
        const baseStyle = {
          outline: 0,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          flexShrink: 0
        };
        return (0, import_jsx_runtime.jsx)(
          import_system.chakra.button,
          {
            type: "button",
            "aria-label": "Close",
            ref,
            disabled: isDisabled,
            __css: {
              ...baseStyle,
              ...styles,
              ...__css
            },
            ...rest,
            children: children || (0, import_jsx_runtime.jsx)(CloseIcon, { width: "1em", height: "1em" })
          }
        );
      }
    );
    CloseButton.displayName = "CloseButton";
  }
});

// ../../node_modules/@chakra-ui/control-box/dist/index.js
var require_dist35 = __commonJS({
  "../../node_modules/@chakra-ui/control-box/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      ControlBox: () => ControlBox
    });
    module.exports = __toCommonJS2(src_exports);
    var import_system = require_dist12();
    var import_jsx_runtime = require_jsx_runtime();
    var ControlBox = (props) => {
      const {
        type = "checkbox",
        _hover,
        _invalid,
        _disabled,
        _focus,
        _checked,
        _child = { opacity: 0 },
        _checkedAndChild = { opacity: 1 },
        _checkedAndDisabled,
        _checkedAndFocus,
        _checkedAndHover,
        children,
        ...rest
      } = props;
      const checkedAndDisabled = `input[type=${type}]:checked:disabled + &`;
      const checkedAndHover = `input[type=${type}]:checked:hover:not(:disabled) + &`;
      const checkedAndFocus = `input[type=${type}]:checked:focus + &`;
      const disabled = `input[type=${type}]:disabled + &`;
      const focus = `input[type=${type}]:focus + &`;
      const hover = `input[type=${type}]:hover:not(:disabled):not(:checked) + &`;
      const checked = `input[type=${type}]:checked + &, input[type=${type}][aria-checked=mixed] + &`;
      const invalid = `input[type=${type}][aria-invalid=true] + &`;
      const child = `& > *`;
      return (0, import_jsx_runtime.jsx)(
        import_system.chakra.div,
        {
          ...rest,
          "aria-hidden": true,
          __css: {
            display: "inline-flex",
            alignItems: "center",
            justifyContent: "center",
            transitionProperty: "common",
            transitionDuration: "fast",
            flexShrink: 0,
            [focus]: _focus,
            [hover]: _hover,
            [disabled]: _disabled,
            [invalid]: _invalid,
            [checkedAndDisabled]: _checkedAndDisabled,
            [checkedAndFocus]: _checkedAndFocus,
            [checkedAndHover]: _checkedAndHover,
            [child]: _child,
            [checked]: {
              ..._checked,
              [child]: _checkedAndChild
            }
          },
          children
        }
      );
    };
    ControlBox.displayName = "ControlBox";
  }
});

// ../../node_modules/@chakra-ui/number-utils/dist/index.js
var require_dist36 = __commonJS({
  "../../node_modules/@chakra-ui/number-utils/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      clampValue: () => clampValue,
      countDecimalPlaces: () => countDecimalPlaces,
      percentToValue: () => percentToValue,
      roundValueToStep: () => roundValueToStep,
      toPrecision: () => toPrecision,
      valueToPercent: () => valueToPercent
    });
    module.exports = __toCommonJS2(src_exports);
    function toNumber(value) {
      const num = parseFloat(value);
      return typeof num !== "number" || Number.isNaN(num) ? 0 : num;
    }
    function toPrecision(value, precision) {
      let nextValue = toNumber(value);
      const scaleFactor = 10 ** (precision != null ? precision : 10);
      nextValue = Math.round(nextValue * scaleFactor) / scaleFactor;
      return precision ? nextValue.toFixed(precision) : nextValue.toString();
    }
    function countDecimalPlaces(value) {
      if (!Number.isFinite(value))
        return 0;
      let e = 1;
      let p = 0;
      while (Math.round(value * e) / e !== value) {
        e *= 10;
        p += 1;
      }
      return p;
    }
    function valueToPercent(value, min, max) {
      return (value - min) * 100 / (max - min);
    }
    function percentToValue(percent, min, max) {
      return (max - min) * percent + min;
    }
    function roundValueToStep(value, from, step) {
      const nextValue = Math.round((value - from) / step) * step + from;
      const precision = countDecimalPlaces(step);
      return toPrecision(nextValue, precision);
    }
    function clampValue(value, min, max) {
      if (value == null)
        return value;
      if (max < min) {
        console.warn("clamp: max cannot be less than min");
      }
      return Math.min(Math.max(value, min), max);
    }
  }
});

// ../../node_modules/@chakra-ui/counter/dist/index.js
var require_dist37 = __commonJS({
  "../../node_modules/@chakra-ui/counter/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      useCounter: () => useCounter
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react_use_callback_ref = require_dist16();
    var import_number_utils = require_dist36();
    var import_react = require_react();
    function useCounter(props = {}) {
      const {
        onChange,
        precision: precisionProp,
        defaultValue,
        value: valueProp,
        step: stepProp = 1,
        min = Number.MIN_SAFE_INTEGER,
        max = Number.MAX_SAFE_INTEGER,
        keepWithinRange = true
      } = props;
      const onChangeProp = (0, import_react_use_callback_ref.useCallbackRef)(onChange);
      const [valueState, setValue] = (0, import_react.useState)(() => {
        var _a;
        if (defaultValue == null)
          return "";
        return (_a = cast(defaultValue, stepProp, precisionProp)) != null ? _a : "";
      });
      const isControlled = typeof valueProp !== "undefined";
      const value = isControlled ? valueProp : valueState;
      const decimalPlaces = getDecimalPlaces(parse(value), stepProp);
      const precision = precisionProp != null ? precisionProp : decimalPlaces;
      const update = (0, import_react.useCallback)(
        (next) => {
          if (next === value)
            return;
          if (!isControlled) {
            setValue(next.toString());
          }
          onChangeProp == null ? void 0 : onChangeProp(next.toString(), parse(next));
        },
        [onChangeProp, isControlled, value]
      );
      const clamp = (0, import_react.useCallback)(
        (value2) => {
          let nextValue = value2;
          if (keepWithinRange) {
            nextValue = (0, import_number_utils.clampValue)(nextValue, min, max);
          }
          return (0, import_number_utils.toPrecision)(nextValue, precision);
        },
        [precision, keepWithinRange, max, min]
      );
      const increment = (0, import_react.useCallback)(
        (step = stepProp) => {
          let next;
          if (value === "") {
            next = parse(step);
          } else {
            next = parse(value) + step;
          }
          next = clamp(next);
          update(next);
        },
        [clamp, stepProp, update, value]
      );
      const decrement = (0, import_react.useCallback)(
        (step = stepProp) => {
          let next;
          if (value === "") {
            next = parse(-step);
          } else {
            next = parse(value) - step;
          }
          next = clamp(next);
          update(next);
        },
        [clamp, stepProp, update, value]
      );
      const reset = (0, import_react.useCallback)(() => {
        var _a;
        let next;
        if (defaultValue == null) {
          next = "";
        } else {
          next = (_a = cast(defaultValue, stepProp, precisionProp)) != null ? _a : min;
        }
        update(next);
      }, [defaultValue, precisionProp, stepProp, update, min]);
      const castValue = (0, import_react.useCallback)(
        (value2) => {
          var _a;
          const nextValue = (_a = cast(value2, stepProp, precision)) != null ? _a : min;
          update(nextValue);
        },
        [precision, stepProp, update, min]
      );
      const valueAsNumber = parse(value);
      const isOutOfRange = valueAsNumber > max || valueAsNumber < min;
      const isAtMax = valueAsNumber === max;
      const isAtMin = valueAsNumber === min;
      return {
        isOutOfRange,
        isAtMax,
        isAtMin,
        precision,
        value,
        valueAsNumber,
        update,
        reset,
        increment,
        decrement,
        clamp,
        cast: castValue,
        setValue
      };
    }
    function parse(value) {
      return parseFloat(value.toString().replace(/[^\w.-]+/g, ""));
    }
    function getDecimalPlaces(value, step) {
      return Math.max((0, import_number_utils.countDecimalPlaces)(step), (0, import_number_utils.countDecimalPlaces)(value));
    }
    function cast(value, step, precision) {
      const parsedValue = parse(value);
      if (Number.isNaN(parsedValue))
        return void 0;
      const decimalPlaces = getDecimalPlaces(parsedValue, step);
      return (0, import_number_utils.toPrecision)(parsedValue, precision != null ? precision : decimalPlaces);
    }
  }
});

// ../../node_modules/@chakra-ui/css-reset/dist/index.js
var require_dist38 = __commonJS({
  "../../node_modules/@chakra-ui/css-reset/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      CSSPolyfill: () => CSSPolyfill,
      CSSReset: () => CSSReset,
      default: () => css_reset_default
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react = require_emotion_react_cjs();
    var import_jsx_runtime = require_jsx_runtime();
    var css = String.raw;
    var vhPolyfill = css`
  :root,
  :host {
    --chakra-vh: 100vh;
  }

  @supports (height: -webkit-fill-available) {
    :root,
    :host {
      --chakra-vh: -webkit-fill-available;
    }
  }

  @supports (height: -moz-fill-available) {
    :root,
    :host {
      --chakra-vh: -moz-fill-available;
    }
  }

  @supports (height: 100dvh) {
    :root,
    :host {
      --chakra-vh: 100dvh;
    }
  }
`;
    var CSSPolyfill = () => (0, import_jsx_runtime.jsx)(import_react.Global, { styles: vhPolyfill });
    var CSSReset = ({ scope = "" }) => (0, import_jsx_runtime.jsx)(
      import_react.Global,
      {
        styles: css`
      html {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        font-family: system-ui, sans-serif;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
      }

      body {
        position: relative;
        min-height: 100%;
        margin: 0;
        font-feature-settings: "kern";
      }

      ${scope} :where(*, *::before, *::after) {
        border-width: 0;
        border-style: solid;
        box-sizing: border-box;
        word-wrap: break-word;
      }

      main {
        display: block;
      }

      ${scope} hr {
        border-top-width: 1px;
        box-sizing: content-box;
        height: 0;
        overflow: visible;
      }

      ${scope} :where(pre, code, kbd,samp) {
        font-family: SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: 1em;
      }

      ${scope} a {
        background-color: transparent;
        color: inherit;
        text-decoration: inherit;
      }

      ${scope} abbr[title] {
        border-bottom: none;
        text-decoration: underline;
        -webkit-text-decoration: underline dotted;
        text-decoration: underline dotted;
      }

      ${scope} :where(b, strong) {
        font-weight: bold;
      }

      ${scope} small {
        font-size: 80%;
      }

      ${scope} :where(sub,sup) {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
      }

      ${scope} sub {
        bottom: -0.25em;
      }

      ${scope} sup {
        top: -0.5em;
      }

      ${scope} img {
        border-style: none;
      }

      ${scope} :where(button, input, optgroup, select, textarea) {
        font-family: inherit;
        font-size: 100%;
        line-height: 1.15;
        margin: 0;
      }

      ${scope} :where(button, input) {
        overflow: visible;
      }

      ${scope} :where(button, select) {
        text-transform: none;
      }

      ${scope} :where(
          button::-moz-focus-inner,
          [type="button"]::-moz-focus-inner,
          [type="reset"]::-moz-focus-inner,
          [type="submit"]::-moz-focus-inner
        ) {
        border-style: none;
        padding: 0;
      }

      ${scope} fieldset {
        padding: 0.35em 0.75em 0.625em;
      }

      ${scope} legend {
        box-sizing: border-box;
        color: inherit;
        display: table;
        max-width: 100%;
        padding: 0;
        white-space: normal;
      }

      ${scope} progress {
        vertical-align: baseline;
      }

      ${scope} textarea {
        overflow: auto;
      }

      ${scope} :where([type="checkbox"], [type="radio"]) {
        box-sizing: border-box;
        padding: 0;
      }

      ${scope} input[type="number"]::-webkit-inner-spin-button,
      ${scope} input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none !important;
      }

      ${scope} input[type="number"] {
        -moz-appearance: textfield;
      }

      ${scope} input[type="search"] {
        -webkit-appearance: textfield;
        outline-offset: -2px;
      }

      ${scope} input[type="search"]::-webkit-search-decoration {
        -webkit-appearance: none !important;
      }

      ${scope} ::-webkit-file-upload-button {
        -webkit-appearance: button;
        font: inherit;
      }

      ${scope} details {
        display: block;
      }

      ${scope} summary {
        display: list-item;
      }

      template {
        display: none;
      }

      [hidden] {
        display: none !important;
      }

      ${scope} :where(
          blockquote,
          dl,
          dd,
          h1,
          h2,
          h3,
          h4,
          h5,
          h6,
          hr,
          figure,
          p,
          pre
        ) {
        margin: 0;
      }

      ${scope} button {
        background: transparent;
        padding: 0;
      }

      ${scope} fieldset {
        margin: 0;
        padding: 0;
      }

      ${scope} :where(ol, ul) {
        margin: 0;
        padding: 0;
      }

      ${scope} textarea {
        resize: vertical;
      }

      ${scope} :where(button, [role="button"]) {
        cursor: pointer;
      }

      ${scope} button::-moz-focus-inner {
        border: 0 !important;
      }

      ${scope} table {
        border-collapse: collapse;
      }

      ${scope} :where(h1, h2, h3, h4, h5, h6) {
        font-size: inherit;
        font-weight: inherit;
      }

      ${scope} :where(button, input, optgroup, select, textarea) {
        padding: 0;
        line-height: inherit;
        color: inherit;
      }

      ${scope} :where(img, svg, video, canvas, audio, iframe, embed, object) {
        display: block;
      }

      ${scope} :where(img, video) {
        max-width: 100%;
        height: auto;
      }

      [data-js-focus-visible]
        :focus:not([data-focus-visible-added]):not(
          [data-focus-visible-disabled]
        ) {
        outline: none;
        box-shadow: none;
      }

      ${scope} select::-ms-expand {
        display: none;
      }

      ${vhPolyfill}
    `
      }
    );
    var css_reset_default = CSSReset;
  }
});

// ../../node_modules/@chakra-ui/react-use-event-listener/dist/index.js
var require_dist39 = __commonJS({
  "../../node_modules/@chakra-ui/react-use-event-listener/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      useEventListener: () => useEventListener
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react = require_react();
    var import_react_use_callback_ref = require_dist16();
    function useEventListener(target, event, handler, options) {
      const listener = (0, import_react_use_callback_ref.useCallbackRef)(handler);
      (0, import_react.useEffect)(() => {
        const node = typeof target === "function" ? target() : target != null ? target : document;
        if (!handler || !node)
          return;
        node.addEventListener(event, listener, options);
        return () => {
          node.removeEventListener(event, listener, options);
        };
      }, [event, target, options, listener, handler]);
      return () => {
        const node = typeof target === "function" ? target() : target != null ? target : document;
        node == null ? void 0 : node.removeEventListener(event, listener, options);
      };
    }
  }
});

// ../../node_modules/@chakra-ui/react-use-focus-on-pointer-down/dist/index.js
var require_dist40 = __commonJS({
  "../../node_modules/@chakra-ui/react-use-focus-on-pointer-down/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      useFocusOnPointerDown: () => useFocusOnPointerDown
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react_use_event_listener = require_dist39();
    function isRefObject(val) {
      return "current" in val;
    }
    var isDom = () => typeof window !== "undefined";
    function getPlatform() {
      var _a;
      const agent = navigator.userAgentData;
      return (_a = agent == null ? void 0 : agent.platform) != null ? _a : navigator.platform;
    }
    var vn = (v) => isDom() && v.test(navigator.vendor);
    var pt = (v) => isDom() && v.test(getPlatform());
    var isApple = () => pt(/mac|iphone|ipad|ipod/i);
    var isSafari = () => isApple() && vn(/apple/i);
    function useFocusOnPointerDown(props) {
      const { ref, elements, enabled } = props;
      const doc = () => {
        var _a, _b;
        return (_b = (_a = ref.current) == null ? void 0 : _a.ownerDocument) != null ? _b : document;
      };
      (0, import_react_use_event_listener.useEventListener)(doc, "pointerdown", (event) => {
        if (!isSafari() || !enabled)
          return;
        const target = event.target;
        const els = elements != null ? elements : [ref];
        const isValidTarget = els.some((elementOrRef) => {
          const el = isRefObject(elementOrRef) ? elementOrRef.current : elementOrRef;
          return (el == null ? void 0 : el.contains(target)) || el === target;
        });
        if (doc().activeElement !== target && isValidTarget) {
          event.preventDefault();
          target.focus();
        }
      });
    }
  }
});

// ../../node_modules/@chakra-ui/editable/dist/index.js
var require_dist41 = __commonJS({
  "../../node_modules/@chakra-ui/editable/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Editable: () => Editable,
      EditableInput: () => EditableInput,
      EditablePreview: () => EditablePreview,
      EditableTextarea: () => EditableTextarea,
      useEditable: () => useEditable,
      useEditableContext: () => useEditableContext,
      useEditableControls: () => useEditableControls,
      useEditableState: () => useEditableState,
      useEditableStyles: () => useEditableStyles
    });
    module.exports = __toCommonJS2(src_exports);
    var import_shared_utils2 = require_dist3();
    var import_system = require_dist12();
    var import_react_context = require_dist13();
    var [EditableStylesProvider, useEditableStyles] = (0, import_react_context.createContext)({
      name: `EditableStylesContext`,
      errorMessage: `useEditableStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Editable />" `
    });
    var [EditableProvider, useEditableContext] = (0, import_react_context.createContext)({
      name: "EditableContext",
      errorMessage: "useEditableContext: context is undefined. Seems you forgot to wrap the editable components in `<Editable />`"
    });
    var import_react_use_focus_on_pointer_down = require_dist40();
    var import_react_use_safe_layout_effect = require_dist();
    var import_react_use_update_effect = require_dist30();
    var import_react_use_controllable_state = require_dist17();
    var import_react_use_merge_refs = require_dist14();
    var import_react_use_callback_ref = require_dist16();
    var import_shared_utils = require_dist3();
    var import_react = require_react();
    function contains(parent, child) {
      if (!parent)
        return false;
      return parent === child || parent.contains(child);
    }
    function useEditable(props = {}) {
      const {
        onChange: onChangeProp,
        onCancel: onCancelProp,
        onSubmit: onSubmitProp,
        onBlur: onBlurProp,
        value: valueProp,
        isDisabled,
        defaultValue,
        startWithEditView,
        isPreviewFocusable = true,
        submitOnBlur = true,
        selectAllOnFocus = true,
        placeholder,
        onEdit: onEditCallback,
        finalFocusRef,
        ...htmlProps
      } = props;
      const onEditProp = (0, import_react_use_callback_ref.useCallbackRef)(onEditCallback);
      const defaultIsEditing = Boolean(startWithEditView && !isDisabled);
      const [isEditing, setIsEditing] = (0, import_react.useState)(defaultIsEditing);
      const [value, setValue] = (0, import_react_use_controllable_state.useControllableState)({
        defaultValue: defaultValue || "",
        value: valueProp,
        onChange: onChangeProp
      });
      const [prevValue, setPrevValue] = (0, import_react.useState)(value);
      const inputRef = (0, import_react.useRef)(null);
      const previewRef = (0, import_react.useRef)(null);
      const editButtonRef = (0, import_react.useRef)(null);
      const cancelButtonRef = (0, import_react.useRef)(null);
      const submitButtonRef = (0, import_react.useRef)(null);
      (0, import_react_use_focus_on_pointer_down.useFocusOnPointerDown)({
        ref: inputRef,
        enabled: isEditing,
        elements: [cancelButtonRef, submitButtonRef]
      });
      const isInteractive = !isEditing && !isDisabled;
      (0, import_react_use_safe_layout_effect.useSafeLayoutEffect)(() => {
        var _a, _b;
        if (isEditing) {
          (_a = inputRef.current) == null ? void 0 : _a.focus();
          if (selectAllOnFocus)
            (_b = inputRef.current) == null ? void 0 : _b.select();
        }
      }, []);
      (0, import_react_use_update_effect.useUpdateEffect)(() => {
        var _a, _b, _c, _d;
        if (!isEditing) {
          if (finalFocusRef) {
            (_a = finalFocusRef.current) == null ? void 0 : _a.focus();
          } else {
            (_b = editButtonRef.current) == null ? void 0 : _b.focus();
          }
          return;
        }
        (_c = inputRef.current) == null ? void 0 : _c.focus();
        if (selectAllOnFocus) {
          (_d = inputRef.current) == null ? void 0 : _d.select();
        }
        onEditProp == null ? void 0 : onEditProp();
      }, [isEditing, onEditProp, selectAllOnFocus]);
      const onEdit = (0, import_react.useCallback)(() => {
        if (isInteractive) {
          setIsEditing(true);
        }
      }, [isInteractive]);
      const onUpdatePrevValue = (0, import_react.useCallback)(() => {
        setPrevValue(value);
      }, [value]);
      const onCancel = (0, import_react.useCallback)(() => {
        setIsEditing(false);
        setValue(prevValue);
        onCancelProp == null ? void 0 : onCancelProp(prevValue);
        onBlurProp == null ? void 0 : onBlurProp(prevValue);
      }, [onCancelProp, onBlurProp, setValue, prevValue]);
      const onSubmit = (0, import_react.useCallback)(() => {
        setIsEditing(false);
        setPrevValue(value);
        onSubmitProp == null ? void 0 : onSubmitProp(value);
        onBlurProp == null ? void 0 : onBlurProp(prevValue);
      }, [value, onSubmitProp, onBlurProp, prevValue]);
      (0, import_react.useEffect)(() => {
        if (isEditing)
          return;
        const inputEl = inputRef.current;
        if ((inputEl == null ? void 0 : inputEl.ownerDocument.activeElement) === inputEl) {
          inputEl == null ? void 0 : inputEl.blur();
        }
      }, [isEditing]);
      const onChange = (0, import_react.useCallback)(
        (event) => {
          setValue(event.currentTarget.value);
        },
        [setValue]
      );
      const onKeyDown = (0, import_react.useCallback)(
        (event) => {
          const eventKey = event.key;
          const keyMap = {
            Escape: onCancel,
            Enter: (event2) => {
              if (!event2.shiftKey && !event2.metaKey) {
                onSubmit();
              }
            }
          };
          const action = keyMap[eventKey];
          if (action) {
            event.preventDefault();
            action(event);
          }
        },
        [onCancel, onSubmit]
      );
      const onKeyDownWithoutSubmit = (0, import_react.useCallback)(
        (event) => {
          const eventKey = event.key;
          const keyMap = {
            Escape: onCancel
          };
          const action = keyMap[eventKey];
          if (action) {
            event.preventDefault();
            action(event);
          }
        },
        [onCancel]
      );
      const isValueEmpty = value.length === 0;
      const onBlur = (0, import_react.useCallback)(
        (event) => {
          var _a;
          if (!isEditing)
            return;
          const doc = event.currentTarget.ownerDocument;
          const relatedTarget = (_a = event.relatedTarget) != null ? _a : doc.activeElement;
          const targetIsCancel = contains(cancelButtonRef.current, relatedTarget);
          const targetIsSubmit = contains(submitButtonRef.current, relatedTarget);
          const isValidBlur = !targetIsCancel && !targetIsSubmit;
          if (isValidBlur) {
            if (submitOnBlur) {
              onSubmit();
            } else {
              onCancel();
            }
          }
        },
        [submitOnBlur, onSubmit, onCancel, isEditing]
      );
      const getPreviewProps = (0, import_react.useCallback)(
        (props2 = {}, ref = null) => {
          const tabIndex = isInteractive && isPreviewFocusable ? 0 : void 0;
          return {
            ...props2,
            ref: (0, import_react_use_merge_refs.mergeRefs)(ref, previewRef),
            children: isValueEmpty ? placeholder : value,
            hidden: isEditing,
            "aria-disabled": (0, import_shared_utils.ariaAttr)(isDisabled),
            tabIndex,
            onFocus: (0, import_shared_utils.callAllHandlers)(props2.onFocus, onEdit, onUpdatePrevValue)
          };
        },
        [
          isDisabled,
          isEditing,
          isInteractive,
          isPreviewFocusable,
          isValueEmpty,
          onEdit,
          onUpdatePrevValue,
          placeholder,
          value
        ]
      );
      const getInputProps = (0, import_react.useCallback)(
        (props2 = {}, ref = null) => ({
          ...props2,
          hidden: !isEditing,
          placeholder,
          ref: (0, import_react_use_merge_refs.mergeRefs)(ref, inputRef),
          disabled: isDisabled,
          "aria-disabled": (0, import_shared_utils.ariaAttr)(isDisabled),
          value,
          onBlur: (0, import_shared_utils.callAllHandlers)(props2.onBlur, onBlur),
          onChange: (0, import_shared_utils.callAllHandlers)(props2.onChange, onChange),
          onKeyDown: (0, import_shared_utils.callAllHandlers)(props2.onKeyDown, onKeyDown),
          onFocus: (0, import_shared_utils.callAllHandlers)(props2.onFocus, onUpdatePrevValue)
        }),
        [
          isDisabled,
          isEditing,
          onBlur,
          onChange,
          onKeyDown,
          onUpdatePrevValue,
          placeholder,
          value
        ]
      );
      const getTextareaProps = (0, import_react.useCallback)(
        (props2 = {}, ref = null) => ({
          ...props2,
          hidden: !isEditing,
          placeholder,
          ref: (0, import_react_use_merge_refs.mergeRefs)(ref, inputRef),
          disabled: isDisabled,
          "aria-disabled": (0, import_shared_utils.ariaAttr)(isDisabled),
          value,
          onBlur: (0, import_shared_utils.callAllHandlers)(props2.onBlur, onBlur),
          onChange: (0, import_shared_utils.callAllHandlers)(props2.onChange, onChange),
          onKeyDown: (0, import_shared_utils.callAllHandlers)(props2.onKeyDown, onKeyDownWithoutSubmit),
          onFocus: (0, import_shared_utils.callAllHandlers)(props2.onFocus, onUpdatePrevValue)
        }),
        [
          isDisabled,
          isEditing,
          onBlur,
          onChange,
          onKeyDownWithoutSubmit,
          onUpdatePrevValue,
          placeholder,
          value
        ]
      );
      const getEditButtonProps = (0, import_react.useCallback)(
        (props2 = {}, ref = null) => ({
          "aria-label": "Edit",
          ...props2,
          type: "button",
          onClick: (0, import_shared_utils.callAllHandlers)(props2.onClick, onEdit),
          ref: (0, import_react_use_merge_refs.mergeRefs)(ref, editButtonRef),
          disabled: isDisabled
        }),
        [onEdit, isDisabled]
      );
      const getSubmitButtonProps = (0, import_react.useCallback)(
        (props2 = {}, ref = null) => ({
          ...props2,
          "aria-label": "Submit",
          ref: (0, import_react_use_merge_refs.mergeRefs)(submitButtonRef, ref),
          type: "button",
          onClick: (0, import_shared_utils.callAllHandlers)(props2.onClick, onSubmit),
          disabled: isDisabled
        }),
        [onSubmit, isDisabled]
      );
      const getCancelButtonProps = (0, import_react.useCallback)(
        (props2 = {}, ref = null) => ({
          "aria-label": "Cancel",
          id: "cancel",
          ...props2,
          ref: (0, import_react_use_merge_refs.mergeRefs)(cancelButtonRef, ref),
          type: "button",
          onClick: (0, import_shared_utils.callAllHandlers)(props2.onClick, onCancel),
          disabled: isDisabled
        }),
        [onCancel, isDisabled]
      );
      return {
        isEditing,
        isDisabled,
        isValueEmpty,
        value,
        onEdit,
        onCancel,
        onSubmit,
        getPreviewProps,
        getInputProps,
        getTextareaProps,
        getEditButtonProps,
        getSubmitButtonProps,
        getCancelButtonProps,
        htmlProps
      };
    }
    var import_jsx_runtime = require_jsx_runtime();
    var Editable = (0, import_system.forwardRef)(function Editable2(props, ref) {
      const styles = (0, import_system.useMultiStyleConfig)("Editable", props);
      const ownProps = (0, import_system.omitThemingProps)(props);
      const { htmlProps, ...context } = useEditable(ownProps);
      const { isEditing, onSubmit, onCancel, onEdit } = context;
      const _className = (0, import_shared_utils2.cx)("chakra-editable", props.className);
      const children = (0, import_shared_utils2.runIfFn)(props.children, {
        isEditing,
        onSubmit,
        onCancel,
        onEdit
      });
      return (0, import_jsx_runtime.jsx)(EditableProvider, { value: context, children: (0, import_jsx_runtime.jsx)(EditableStylesProvider, { value: styles, children: (0, import_jsx_runtime.jsx)(
        import_system.chakra.div,
        {
          ref,
          ...htmlProps,
          className: _className,
          children
        }
      ) }) });
    });
    Editable.displayName = "Editable";
    var import_system2 = require_dist12();
    var import_shared_utils3 = require_dist3();
    var commonStyles = {
      fontSize: "inherit",
      fontWeight: "inherit",
      textAlign: "inherit",
      bg: "transparent"
    };
    var import_jsx_runtime2 = require_jsx_runtime();
    var EditableInput = (0, import_system2.forwardRef)(
      function EditableInput2(props, ref) {
        const { getInputProps } = useEditableContext();
        const styles = useEditableStyles();
        const inputProps = getInputProps(props, ref);
        const _className = (0, import_shared_utils3.cx)("chakra-editable__input", props.className);
        return (0, import_jsx_runtime2.jsx)(
          import_system2.chakra.input,
          {
            ...inputProps,
            __css: {
              outline: 0,
              ...commonStyles,
              ...styles.input
            },
            className: _className
          }
        );
      }
    );
    EditableInput.displayName = "EditableInput";
    var import_system3 = require_dist12();
    var import_shared_utils4 = require_dist3();
    var import_jsx_runtime3 = require_jsx_runtime();
    var EditablePreview = (0, import_system3.forwardRef)(
      function EditablePreview2(props, ref) {
        const { getPreviewProps } = useEditableContext();
        const styles = useEditableStyles();
        const previewProps = getPreviewProps(props, ref);
        const _className = (0, import_shared_utils4.cx)("chakra-editable__preview", props.className);
        return (0, import_jsx_runtime3.jsx)(
          import_system3.chakra.span,
          {
            ...previewProps,
            __css: {
              cursor: "text",
              display: "inline-block",
              ...commonStyles,
              ...styles.preview
            },
            className: _className
          }
        );
      }
    );
    EditablePreview.displayName = "EditablePreview";
    var import_system4 = require_dist12();
    var import_shared_utils5 = require_dist3();
    var import_jsx_runtime4 = require_jsx_runtime();
    var EditableTextarea = (0, import_system4.forwardRef)(
      function EditableTextarea2(props, ref) {
        const { getTextareaProps } = useEditableContext();
        const styles = useEditableStyles();
        const textareaProps = getTextareaProps(props, ref);
        const _className = (0, import_shared_utils5.cx)("chakra-editable__textarea", props.className);
        return (0, import_jsx_runtime4.jsx)(
          import_system4.chakra.textarea,
          {
            ...textareaProps,
            __css: {
              outline: 0,
              ...commonStyles,
              ...styles.textarea
            },
            className: _className
          }
        );
      }
    );
    EditableTextarea.displayName = "EditableTextarea";
    function useEditableControls() {
      const {
        isEditing,
        getEditButtonProps,
        getCancelButtonProps,
        getSubmitButtonProps
      } = useEditableContext();
      return {
        isEditing,
        getEditButtonProps,
        getCancelButtonProps,
        getSubmitButtonProps
      };
    }
    function useEditableState() {
      const { isEditing, onSubmit, onCancel, onEdit, isDisabled } = useEditableContext();
      return {
        isEditing,
        onSubmit,
        onCancel,
        onEdit,
        isDisabled
      };
    }
  }
});

// ../../node_modules/@chakra-ui/dom-utils/dist/index.js
var require_dist42 = __commonJS({
  "../../node_modules/@chakra-ui/dom-utils/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      contains: () => contains,
      getActiveElement: () => getActiveElement,
      getAllFocusable: () => getAllFocusable,
      getAllTabbable: () => getAllTabbable,
      getEventWindow: () => getEventWindow,
      getFirstFocusable: () => getFirstFocusable,
      getFirstTabbableIn: () => getFirstTabbableIn,
      getLastTabbableIn: () => getLastTabbableIn,
      getNextTabbable: () => getNextTabbable,
      getOwnerDocument: () => getOwnerDocument,
      getOwnerWindow: () => getOwnerWindow,
      getPreviousTabbable: () => getPreviousTabbable,
      hasDisplayNone: () => hasDisplayNone,
      hasFocusWithin: () => hasFocusWithin,
      hasNegativeTabIndex: () => hasNegativeTabIndex,
      hasTabIndex: () => hasTabIndex,
      isActiveElement: () => isActiveElement,
      isBrowser: () => isBrowser,
      isContentEditable: () => isContentEditable,
      isDisabled: () => isDisabled,
      isElement: () => isElement,
      isFocusable: () => isFocusable,
      isHTMLElement: () => isHTMLElement,
      isHidden: () => isHidden,
      isInputElement: () => isInputElement,
      isTabbable: () => isTabbable
    });
    module.exports = __toCommonJS2(src_exports);
    function isElement(el) {
      return el != null && typeof el == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
    }
    function isHTMLElement(el) {
      var _a;
      if (!isElement(el))
        return false;
      const win = (_a = el.ownerDocument.defaultView) != null ? _a : window;
      return el instanceof win.HTMLElement;
    }
    function getOwnerWindow(node) {
      var _a, _b;
      return (_b = (_a = getOwnerDocument(node)) == null ? void 0 : _a.defaultView) != null ? _b : window;
    }
    function getOwnerDocument(node) {
      return isElement(node) ? node.ownerDocument : document;
    }
    function getEventWindow(event) {
      var _a;
      return (_a = event.view) != null ? _a : window;
    }
    function isBrowser() {
      return Boolean(globalThis == null ? void 0 : globalThis.document);
    }
    function getActiveElement(node) {
      return getOwnerDocument(node).activeElement;
    }
    function contains(parent, child) {
      if (!parent)
        return false;
      return parent === child || parent.contains(child);
    }
    var hasDisplayNone = (element) => window.getComputedStyle(element).display === "none";
    var hasTabIndex = (element) => element.hasAttribute("tabindex");
    var hasNegativeTabIndex = (element) => hasTabIndex(element) && element.tabIndex === -1;
    function isDisabled(element) {
      return Boolean(element.getAttribute("disabled")) === true || Boolean(element.getAttribute("aria-disabled")) === true;
    }
    function isInputElement(element) {
      return isHTMLElement(element) && element.localName === "input" && "select" in element;
    }
    function isActiveElement(element) {
      const doc = isHTMLElement(element) ? getOwnerDocument(element) : document;
      return doc.activeElement === element;
    }
    function hasFocusWithin(element) {
      if (!document.activeElement)
        return false;
      return element.contains(document.activeElement);
    }
    function isHidden(element) {
      if (element.parentElement && isHidden(element.parentElement))
        return true;
      return element.hidden;
    }
    function isContentEditable(element) {
      const value = element.getAttribute("contenteditable");
      return value !== "false" && value != null;
    }
    function isFocusable(element) {
      if (!isHTMLElement(element) || isHidden(element) || isDisabled(element)) {
        return false;
      }
      const { localName } = element;
      const focusableTags = ["input", "select", "textarea", "button"];
      if (focusableTags.indexOf(localName) >= 0)
        return true;
      const others = {
        a: () => element.hasAttribute("href"),
        audio: () => element.hasAttribute("controls"),
        video: () => element.hasAttribute("controls")
      };
      if (localName in others) {
        return others[localName]();
      }
      if (isContentEditable(element))
        return true;
      return hasTabIndex(element);
    }
    function isTabbable(element) {
      if (!element)
        return false;
      return isHTMLElement(element) && isFocusable(element) && !hasNegativeTabIndex(element);
    }
    var focusableElList = [
      "input:not(:disabled):not([disabled])",
      "select:not(:disabled):not([disabled])",
      "textarea:not(:disabled):not([disabled])",
      "embed",
      "iframe",
      "object",
      "a[href]",
      "area[href]",
      "button:not(:disabled):not([disabled])",
      "[tabindex]",
      "audio[controls]",
      "video[controls]",
      "*[tabindex]:not([aria-disabled])",
      "*[contenteditable]"
    ];
    var focusableElSelector = focusableElList.join();
    var isVisible = (el) => el.offsetWidth > 0 && el.offsetHeight > 0;
    function getAllFocusable(container) {
      const focusableEls = Array.from(
        container.querySelectorAll(focusableElSelector)
      );
      focusableEls.unshift(container);
      return focusableEls.filter((el) => isFocusable(el) && isVisible(el));
    }
    function getFirstFocusable(container) {
      const allFocusable = getAllFocusable(container);
      return allFocusable.length ? allFocusable[0] : null;
    }
    function getAllTabbable(container, fallbackToFocusable) {
      const allFocusable = Array.from(
        container.querySelectorAll(focusableElSelector)
      );
      const allTabbable = allFocusable.filter(isTabbable);
      if (isTabbable(container)) {
        allTabbable.unshift(container);
      }
      if (!allTabbable.length && fallbackToFocusable) {
        return allFocusable;
      }
      return allTabbable;
    }
    function getFirstTabbableIn(container, fallbackToFocusable) {
      const [first] = getAllTabbable(container, fallbackToFocusable);
      return first || null;
    }
    function getLastTabbableIn(container, fallbackToFocusable) {
      const allTabbable = getAllTabbable(container, fallbackToFocusable);
      return allTabbable[allTabbable.length - 1] || null;
    }
    function getNextTabbable(container, fallbackToFocusable) {
      const allFocusable = getAllFocusable(container);
      const index = allFocusable.indexOf(document.activeElement);
      const slice = allFocusable.slice(index + 1);
      return slice.find(isTabbable) || allFocusable.find(isTabbable) || (fallbackToFocusable ? slice[0] : null);
    }
    function getPreviousTabbable(container, fallbackToFocusable) {
      const allFocusable = getAllFocusable(container).reverse();
      const index = allFocusable.indexOf(document.activeElement);
      const slice = allFocusable.slice(index + 1);
      return slice.find(isTabbable) || allFocusable.find(isTabbable) || (fallbackToFocusable ? slice[0] : null);
    }
  }
});

// ../../node_modules/@chakra-ui/focus-lock/dist/index.js
var require_dist43 = __commonJS({
  "../../node_modules/@chakra-ui/focus-lock/dist/index.js"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      FocusLock: () => FocusLock
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react_focus_lock = __toESM((init_es2015(), __toCommonJS(es2015_exports)));
    var import_dom_utils = require_dist42();
    var import_react = require_react();
    var import_jsx_runtime = require_jsx_runtime();
    var _a;
    var FocusTrap = (_a = import_react_focus_lock.default.default) != null ? _a : import_react_focus_lock.default;
    var FocusLock = (props) => {
      const {
        initialFocusRef,
        finalFocusRef,
        contentRef,
        restoreFocus,
        children,
        isDisabled,
        autoFocus,
        persistentFocus,
        lockFocusAcrossFrames
      } = props;
      const onActivation = (0, import_react.useCallback)(() => {
        if (initialFocusRef == null ? void 0 : initialFocusRef.current) {
          initialFocusRef.current.focus();
        } else if (contentRef == null ? void 0 : contentRef.current) {
          const focusables = (0, import_dom_utils.getAllFocusable)(contentRef.current);
          if (focusables.length === 0) {
            requestAnimationFrame(() => {
              var _a2;
              (_a2 = contentRef.current) == null ? void 0 : _a2.focus();
            });
          }
        }
      }, [initialFocusRef, contentRef]);
      const onDeactivation = (0, import_react.useCallback)(() => {
        var _a2;
        (_a2 = finalFocusRef == null ? void 0 : finalFocusRef.current) == null ? void 0 : _a2.focus();
      }, [finalFocusRef]);
      const returnFocus = restoreFocus && !finalFocusRef;
      return (0, import_jsx_runtime.jsx)(
        FocusTrap,
        {
          crossFrame: lockFocusAcrossFrames,
          persistentFocus,
          autoFocus,
          disabled: isDisabled,
          onActivation,
          onDeactivation,
          returnFocus,
          children
        }
      );
    };
    FocusLock.displayName = "FocusLock";
  }
});

// ../../node_modules/@chakra-ui/hooks/dist/index.js
var require_dist44 = __commonJS({
  "../../node_modules/@chakra-ui/hooks/dist/index.js"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      assignRef: () => assignRef,
      useAnimationState: () => useAnimationState,
      useBoolean: () => useBoolean,
      useCallbackRef: () => useCallbackRef,
      useClipboard: () => useClipboard,
      useConst: () => useConst,
      useControllableProp: () => useControllableProp,
      useControllableState: () => useControllableState,
      useDimensions: () => useDimensions,
      useDisclosure: () => useDisclosure,
      useEventListener: () => useEventListener,
      useEventListenerMap: () => useEventListenerMap,
      useFocusEffect: () => useFocusEffect,
      useFocusOnHide: () => useFocusOnHide,
      useFocusOnPointerDown: () => useFocusOnPointerDown,
      useFocusOnShow: () => useFocusOnShow,
      useForceUpdate: () => useForceUpdate,
      useId: () => useId,
      useIds: () => useIds,
      useInterval: () => useInterval,
      useLatestRef: () => useLatestRef,
      useMergeRefs: () => useMergeRefs,
      useMouseDownRef: () => useMouseDownRef,
      useOptionalPart: () => useOptionalPart,
      useOutsideClick: () => useOutsideClick,
      usePanGesture: () => usePanGesture,
      usePointerEvent: () => usePointerEvent,
      usePrevious: () => usePrevious,
      useSafeLayoutEffect: () => useSafeLayoutEffect,
      useShortcut: () => useShortcut,
      useTimeout: () => useTimeout,
      useUnmountEffect: () => useUnmountEffect,
      useUpdateEffect: () => useUpdateEffect,
      useWhyDidYouUpdate: () => useWhyDidYouUpdate
    });
    module.exports = __toCommonJS2(src_exports);
    var import_utils3 = require_dist5();
    var import_react4 = require_react();
    var import_utils2 = require_dist5();
    var import_react3 = require_react();
    var import_react2 = require_react();
    var import_utils = require_dist5();
    var import_react = require_react();
    var useSafeLayoutEffect = import_utils.isBrowser ? import_react.useLayoutEffect : import_react.useEffect;
    function useCallbackRef(fn, deps = []) {
      const ref = (0, import_react2.useRef)(fn);
      useSafeLayoutEffect(() => {
        ref.current = fn;
      });
      return (0, import_react2.useCallback)((...args) => {
        var _a;
        return (_a = ref.current) == null ? void 0 : _a.call(ref, ...args);
      }, deps);
    }
    function useEventListener(event, handler, env, options) {
      const listener = useCallbackRef(handler);
      (0, import_react3.useEffect)(() => {
        var _a;
        const node = (_a = (0, import_utils2.runIfFn)(env)) != null ? _a : document;
        if (!handler) {
          return;
        }
        node.addEventListener(event, listener, options);
        return () => {
          node.removeEventListener(event, listener, options);
        };
      }, [event, env, options, listener, handler]);
      return () => {
        var _a;
        const node = (_a = (0, import_utils2.runIfFn)(env)) != null ? _a : document;
        node.removeEventListener(event, listener, options);
      };
    }
    function useAnimationState(props) {
      const { isOpen, ref } = props;
      const [mounted, setMounted] = (0, import_react4.useState)(isOpen);
      const [once, setOnce] = (0, import_react4.useState)(false);
      (0, import_react4.useEffect)(() => {
        if (!once) {
          setMounted(isOpen);
          setOnce(true);
        }
      }, [isOpen, once, mounted]);
      useEventListener(
        "animationend",
        () => {
          setMounted(isOpen);
        },
        () => ref.current
      );
      const hidden = isOpen ? false : !mounted;
      return {
        present: !hidden,
        onComplete() {
          var _a;
          const win = (0, import_utils3.getOwnerWindow)(ref.current);
          const evt = new win.CustomEvent("animationend", { bubbles: true });
          (_a = ref.current) == null ? void 0 : _a.dispatchEvent(evt);
        }
      };
    }
    var import_react5 = require_react();
    function useBoolean(initialState = false) {
      const [value, setValue] = (0, import_react5.useState)(initialState);
      const callbacks = (0, import_react5.useMemo)(
        () => ({
          on: () => setValue(true),
          off: () => setValue(false),
          toggle: () => setValue((prev) => !prev)
        }),
        []
      );
      return [value, callbacks];
    }
    var import_react6 = require_react();
    var import_copy_to_clipboard = __toESM(require_copy_to_clipboard());
    function useClipboard(value, optionsOrTimeout = {}) {
      const [hasCopied, setHasCopied] = (0, import_react6.useState)(false);
      const [valueState, setValueState] = (0, import_react6.useState)(value);
      (0, import_react6.useEffect)(() => setValueState(value), [value]);
      const { timeout = 1500, ...copyOptions } = typeof optionsOrTimeout === "number" ? { timeout: optionsOrTimeout } : optionsOrTimeout;
      const onCopy = (0, import_react6.useCallback)(() => {
        const didCopy = (0, import_copy_to_clipboard.default)(valueState, copyOptions);
        setHasCopied(didCopy);
      }, [valueState, copyOptions]);
      (0, import_react6.useEffect)(() => {
        let timeoutId = null;
        if (hasCopied) {
          timeoutId = window.setTimeout(() => {
            setHasCopied(false);
          }, timeout);
        }
        return () => {
          if (timeoutId) {
            window.clearTimeout(timeoutId);
          }
        };
      }, [timeout, hasCopied]);
      return {
        value: valueState,
        setValue: setValueState,
        onCopy,
        hasCopied
      };
    }
    var import_react7 = require_react();
    function useConst(init) {
      const ref = (0, import_react7.useRef)(null);
      if (ref.current === null) {
        ref.current = typeof init === "function" ? init() : init;
      }
      return ref.current;
    }
    var import_utils4 = require_dist5();
    var import_react8 = require_react();
    function useControllableProp(prop, state) {
      const isControlled = prop !== void 0;
      const value = isControlled && typeof prop !== "undefined" ? prop : state;
      return [isControlled, value];
    }
    function useControllableState(props) {
      const {
        value: valueProp,
        defaultValue,
        onChange,
        shouldUpdate = (prev, next) => prev !== next
      } = props;
      const onChangeProp = useCallbackRef(onChange);
      const shouldUpdateProp = useCallbackRef(shouldUpdate);
      const [valueState, setValue] = (0, import_react8.useState)(defaultValue);
      const isControlled = valueProp !== void 0;
      const value = isControlled ? valueProp : valueState;
      const updateValue = (0, import_react8.useCallback)(
        (next) => {
          const nextValue = (0, import_utils4.runIfFn)(next, value);
          if (!shouldUpdateProp(value, nextValue)) {
            return;
          }
          if (!isControlled) {
            setValue(nextValue);
          }
          onChangeProp(nextValue);
        },
        [isControlled, onChangeProp, value, shouldUpdateProp]
      );
      return [value, updateValue];
    }
    var import_utils5 = require_dist5();
    var import_react9 = require_react();
    function useDimensions(ref, observe) {
      const [dimensions, setDimensions] = (0, import_react9.useState)(null);
      const rafId = (0, import_react9.useRef)();
      useSafeLayoutEffect(() => {
        function measure() {
          const node = ref.current;
          if (!node)
            return;
          rafId.current = requestAnimationFrame(() => {
            const boxModel = (0, import_utils5.getBox)(node);
            setDimensions(boxModel);
          });
        }
        measure();
        if (observe) {
          window.addEventListener("resize", measure);
          window.addEventListener("scroll", measure);
        }
        return () => {
          if (observe) {
            window.removeEventListener("resize", measure);
            window.removeEventListener("scroll", measure);
          }
          if (rafId.current) {
            cancelAnimationFrame(rafId.current);
          }
        };
      }, [observe]);
      return dimensions;
    }
    var import_utils6 = require_dist5();
    var import_react10 = require_react();
    function useId(idProp, prefix) {
      const id = (0, import_react10.useId)();
      return (0, import_react10.useMemo)(
        () => idProp || [prefix, id].filter(Boolean).join("-"),
        [idProp, prefix, id]
      );
    }
    function useIds(idProp, ...prefixes) {
      const id = useId(idProp);
      return (0, import_react10.useMemo)(() => {
        return prefixes.map((prefix) => `${prefix}-${id}`);
      }, [id, prefixes]);
    }
    function useOptionalPart(partId) {
      const [id, setId] = (0, import_react10.useState)(null);
      const ref = (0, import_react10.useCallback)(
        (node) => {
          setId(node ? partId : null);
        },
        [partId]
      );
      return { ref, id, isRendered: Boolean(id) };
    }
    var import_react11 = require_react();
    function useDisclosure(props = {}) {
      const {
        onClose: onCloseProp,
        onOpen: onOpenProp,
        isOpen: isOpenProp,
        id: idProp
      } = props;
      const onOpenPropCallbackRef = useCallbackRef(onOpenProp);
      const onClosePropCallbackRef = useCallbackRef(onCloseProp);
      const [isOpenState, setIsOpen] = (0, import_react11.useState)(props.defaultIsOpen || false);
      const [isControlled, isOpen] = useControllableProp(isOpenProp, isOpenState);
      const id = useId(idProp, "disclosure");
      const onClose = (0, import_react11.useCallback)(() => {
        if (!isControlled) {
          setIsOpen(false);
        }
        onClosePropCallbackRef == null ? void 0 : onClosePropCallbackRef();
      }, [isControlled, onClosePropCallbackRef]);
      const onOpen = (0, import_react11.useCallback)(() => {
        if (!isControlled) {
          setIsOpen(true);
        }
        onOpenPropCallbackRef == null ? void 0 : onOpenPropCallbackRef();
      }, [isControlled, onOpenPropCallbackRef]);
      const onToggle = (0, import_react11.useCallback)(() => {
        const action = isOpen ? onClose : onOpen;
        action();
      }, [isOpen, onOpen, onClose]);
      return {
        isOpen: !!isOpen,
        onOpen,
        onClose,
        onToggle,
        isControlled,
        getButtonProps: (props2 = {}) => ({
          ...props2,
          "aria-expanded": isOpen,
          "aria-controls": id,
          onClick: (0, import_utils6.callAllHandlers)(props2.onClick, onToggle)
        }),
        getDisclosureProps: (props2 = {}) => ({
          ...props2,
          hidden: !isOpen,
          id
        })
      };
    }
    var import_utils7 = require_dist5();
    var import_react12 = require_react();
    function useEventListenerMap() {
      const listeners = (0, import_react12.useRef)(/* @__PURE__ */ new Map());
      const currentListeners = listeners.current;
      const add = (0, import_react12.useCallback)((el, type, listener, options) => {
        const pointerEventListener = (0, import_utils7.wrapPointerEventHandler)(
          listener,
          type === "pointerdown"
        );
        listeners.current.set(listener, {
          __listener: pointerEventListener,
          type: (0, import_utils7.getPointerEventName)(type),
          el,
          options
        });
        el.addEventListener(type, pointerEventListener, options);
      }, []);
      const remove = (0, import_react12.useCallback)(
        (el, type, listener, options) => {
          const { __listener: pointerEventListener } = listeners.current.get(listener);
          el.removeEventListener(type, pointerEventListener, options);
          listeners.current.delete(pointerEventListener);
        },
        []
      );
      (0, import_react12.useEffect)(
        () => () => {
          currentListeners.forEach((value, key) => {
            remove(value.el, value.type, key, value.options);
          });
        },
        [remove, currentListeners]
      );
      return { add, remove };
    }
    var import_utils8 = require_dist5();
    var import_react13 = require_react();
    var useUpdateEffect = (effect, deps) => {
      const renderCycleRef = (0, import_react13.useRef)(false);
      const effectCycleRef = (0, import_react13.useRef)(false);
      (0, import_react13.useEffect)(() => {
        const isMounted = renderCycleRef.current;
        const shouldRun = isMounted && effectCycleRef.current;
        if (shouldRun) {
          return effect();
        }
        effectCycleRef.current = true;
      }, deps);
      (0, import_react13.useEffect)(() => {
        renderCycleRef.current = true;
        return () => {
          renderCycleRef.current = false;
        };
      }, []);
    };
    function useFocusEffect(ref, options) {
      const { shouldFocus, preventScroll } = options;
      useUpdateEffect(() => {
        const node = ref.current;
        if (!node || !shouldFocus)
          return;
        if (!(0, import_utils8.hasFocusWithin)(node)) {
          (0, import_utils8.focus)(node, { preventScroll, nextTick: true });
        }
      }, [shouldFocus, ref, preventScroll]);
    }
    var import_utils9 = require_dist5();
    function preventReturnFocus(containerRef) {
      const el = containerRef.current;
      if (!el)
        return false;
      const activeElement = (0, import_utils9.getActiveElement)(el);
      if (!activeElement)
        return false;
      if ((0, import_utils9.contains)(el, activeElement))
        return false;
      if ((0, import_utils9.isTabbable)(activeElement))
        return true;
      return false;
    }
    function useFocusOnHide(containerRef, options) {
      const { shouldFocus: shouldFocusProp, visible, focusRef } = options;
      const shouldFocus = shouldFocusProp && !visible;
      useUpdateEffect(() => {
        if (!shouldFocus)
          return;
        if (preventReturnFocus(containerRef)) {
          return;
        }
        const el = (focusRef == null ? void 0 : focusRef.current) || containerRef.current;
        if (el) {
          (0, import_utils9.focus)(el, { nextTick: true });
        }
      }, [shouldFocus, containerRef, focusRef]);
    }
    var import_utils11 = require_dist5();
    var import_utils10 = require_dist5();
    function usePointerEvent(env, eventName, handler, options) {
      return useEventListener(
        (0, import_utils10.getPointerEventName)(eventName),
        (0, import_utils10.wrapPointerEventHandler)(handler, eventName === "pointerdown"),
        env,
        options
      );
    }
    function useFocusOnPointerDown(props) {
      const { ref, elements, enabled } = props;
      const isSafari = (0, import_utils11.detectBrowser)("Safari");
      const doc = () => (0, import_utils11.getOwnerDocument)(ref.current);
      usePointerEvent(doc, "pointerdown", (event) => {
        if (!isSafari || !enabled)
          return;
        const target = event.target;
        const els = elements != null ? elements : [ref];
        const isValidTarget = els.some((elementOrRef) => {
          const el = (0, import_utils11.isRefObject)(elementOrRef) ? elementOrRef.current : elementOrRef;
          return (0, import_utils11.contains)(el, target);
        });
        if (!(0, import_utils11.isActiveElement)(target) && isValidTarget) {
          event.preventDefault();
          (0, import_utils11.focus)(target);
        }
      });
    }
    var import_utils12 = require_dist5();
    var import_react14 = require_react();
    var defaultOptions = {
      preventScroll: true,
      shouldFocus: false
    };
    function useFocusOnShow(target, options = defaultOptions) {
      const { focusRef, preventScroll, shouldFocus, visible } = options;
      const element = (0, import_utils12.isRefObject)(target) ? target.current : target;
      const autoFocusValue = shouldFocus && visible;
      const autoFocusRef = (0, import_react14.useRef)(autoFocusValue);
      const lastVisibleRef = (0, import_react14.useRef)(visible);
      useSafeLayoutEffect(() => {
        if (!lastVisibleRef.current && visible) {
          autoFocusRef.current = autoFocusValue;
        }
        lastVisibleRef.current = visible;
      }, [visible, autoFocusValue]);
      const onFocus = (0, import_react14.useCallback)(() => {
        if (!visible || !element || !autoFocusRef.current)
          return;
        autoFocusRef.current = false;
        if ((0, import_utils12.contains)(element, document.activeElement))
          return;
        if (focusRef == null ? void 0 : focusRef.current) {
          (0, import_utils12.focus)(focusRef.current, { preventScroll, nextTick: true });
        } else {
          const tabbableEls = (0, import_utils12.getAllFocusable)(element);
          if (tabbableEls.length > 0) {
            (0, import_utils12.focus)(tabbableEls[0], { preventScroll, nextTick: true });
          }
        }
      }, [visible, preventScroll, element, focusRef]);
      useUpdateEffect(() => {
        onFocus();
      }, [onFocus]);
      useEventListener("transitionend", onFocus, element);
    }
    var import_react16 = require_react();
    var import_react15 = require_react();
    function useUnmountEffect(fn, deps = []) {
      return (0, import_react15.useEffect)(
        () => () => fn(),
        deps
      );
    }
    function useForceUpdate() {
      const unloadingRef = (0, import_react16.useRef)(false);
      const [count, setCount] = (0, import_react16.useState)(0);
      useUnmountEffect(() => {
        unloadingRef.current = true;
      });
      return (0, import_react16.useCallback)(() => {
        if (!unloadingRef.current) {
          setCount(count + 1);
        }
      }, [count]);
    }
    var import_react17 = require_react();
    function useInterval(callback, delay) {
      const fn = useCallbackRef(callback);
      (0, import_react17.useEffect)(() => {
        let intervalId = null;
        const tick = () => fn();
        if (delay !== null) {
          intervalId = window.setInterval(tick, delay);
        }
        return () => {
          if (intervalId) {
            window.clearInterval(intervalId);
          }
        };
      }, [delay, fn]);
    }
    var import_react18 = require_react();
    function useLatestRef(value) {
      const ref = (0, import_react18.useRef)(null);
      ref.current = value;
      return ref;
    }
    var import_react19 = require_react();
    function assignRef(ref, value) {
      if (ref == null)
        return;
      if (typeof ref === "function") {
        ref(value);
        return;
      }
      try {
        ref.current = value;
      } catch (error) {
        throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);
      }
    }
    function useMergeRefs(...refs) {
      return (0, import_react19.useMemo)(() => {
        if (refs.every((ref) => ref == null)) {
          return null;
        }
        return (node) => {
          refs.forEach((ref) => {
            if (ref)
              assignRef(ref, node);
          });
        };
      }, refs);
    }
    var import_react20 = require_react();
    function useMouseDownRef(shouldListen = true) {
      const mouseDownRef = (0, import_react20.useRef)();
      useEventListener("mousedown", (event) => {
        if (shouldListen) {
          mouseDownRef.current = event.target;
        }
      });
      return mouseDownRef;
    }
    var import_utils13 = require_dist5();
    var import_react21 = require_react();
    function useOutsideClick(props) {
      const { ref, handler, enabled = true } = props;
      const savedHandler = useCallbackRef(handler);
      const stateRef = (0, import_react21.useRef)({
        isPointerDown: false,
        ignoreEmulatedMouseEvents: false
      });
      const state = stateRef.current;
      (0, import_react21.useEffect)(() => {
        if (!enabled)
          return;
        const onPointerDown = (e) => {
          if (isValidEvent(e, ref)) {
            state.isPointerDown = true;
          }
        };
        const onMouseUp = (event) => {
          if (state.ignoreEmulatedMouseEvents) {
            state.ignoreEmulatedMouseEvents = false;
            return;
          }
          if (state.isPointerDown && handler && isValidEvent(event, ref)) {
            state.isPointerDown = false;
            savedHandler(event);
          }
        };
        const onTouchEnd = (event) => {
          state.ignoreEmulatedMouseEvents = true;
          if (handler && state.isPointerDown && isValidEvent(event, ref)) {
            state.isPointerDown = false;
            savedHandler(event);
          }
        };
        const doc = (0, import_utils13.getOwnerDocument)(ref.current);
        doc.addEventListener("mousedown", onPointerDown, true);
        doc.addEventListener("mouseup", onMouseUp, true);
        doc.addEventListener("touchstart", onPointerDown, true);
        doc.addEventListener("touchend", onTouchEnd, true);
        return () => {
          doc.removeEventListener("mousedown", onPointerDown, true);
          doc.removeEventListener("mouseup", onMouseUp, true);
          doc.removeEventListener("touchstart", onPointerDown, true);
          doc.removeEventListener("touchend", onTouchEnd, true);
        };
      }, [handler, ref, savedHandler, state, enabled]);
    }
    function isValidEvent(event, ref) {
      var _a;
      const target = event.target;
      if (target) {
        const doc = (0, import_utils13.getOwnerDocument)(target);
        if (!doc.contains(target))
          return false;
      }
      return !((_a = ref.current) == null ? void 0 : _a.contains(target));
    }
    var import_utils14 = require_dist5();
    var import_react22 = require_react();
    function usePanGesture(ref, props) {
      const {
        onPan,
        onPanStart,
        onPanEnd,
        onPanSessionStart,
        onPanSessionEnd,
        threshold
      } = props;
      const hasPanEvents = Boolean(
        onPan || onPanStart || onPanEnd || onPanSessionStart || onPanSessionEnd
      );
      const panSession = (0, import_react22.useRef)(null);
      const handlers = {
        onSessionStart: onPanSessionStart,
        onSessionEnd: onPanSessionEnd,
        onStart: onPanStart,
        onMove: onPan,
        onEnd(event, info) {
          panSession.current = null;
          onPanEnd == null ? void 0 : onPanEnd(event, info);
        }
      };
      (0, import_react22.useEffect)(() => {
        var _a;
        (_a = panSession.current) == null ? void 0 : _a.updateHandlers(handlers);
      });
      function onPointerDown(event) {
        panSession.current = new import_utils14.PanSession(event, handlers, threshold);
      }
      usePointerEvent(
        () => ref.current,
        "pointerdown",
        hasPanEvents ? onPointerDown : import_utils14.noop
      );
      useUnmountEffect(() => {
        var _a;
        (_a = panSession.current) == null ? void 0 : _a.end();
        panSession.current = null;
      });
    }
    var import_react23 = require_react();
    function usePrevious(value) {
      const ref = (0, import_react23.useRef)();
      (0, import_react23.useEffect)(() => {
        ref.current = value;
      }, [value]);
      return ref.current;
    }
    var import_react24 = require_react();
    function isPrintableCharacter(event) {
      const { key } = event;
      return key.length === 1 || key.length > 1 && /[^a-zA-Z0-9]/.test(key);
    }
    function useShortcut(props = {}) {
      const { timeout = 300, preventDefault = () => true } = props;
      const [keys, setKeys] = (0, import_react24.useState)([]);
      const timeoutRef = (0, import_react24.useRef)();
      const flush = () => {
        if (timeoutRef.current) {
          clearTimeout(timeoutRef.current);
          timeoutRef.current = null;
        }
      };
      const clearKeysAfterDelay = () => {
        flush();
        timeoutRef.current = setTimeout(() => {
          setKeys([]);
          timeoutRef.current = null;
        }, timeout);
      };
      (0, import_react24.useEffect)(() => flush, []);
      function onKeyDown(fn) {
        return (event) => {
          if (event.key === "Backspace") {
            const keysCopy = [...keys];
            keysCopy.pop();
            setKeys(keysCopy);
            return;
          }
          if (isPrintableCharacter(event)) {
            const keysCopy = keys.concat(event.key);
            if (preventDefault(event)) {
              event.preventDefault();
              event.stopPropagation();
            }
            setKeys(keysCopy);
            fn(keysCopy.join(""));
            clearKeysAfterDelay();
          }
        };
      }
      return onKeyDown;
    }
    var import_react25 = require_react();
    function useTimeout(callback, delay) {
      const fn = useCallbackRef(callback);
      (0, import_react25.useEffect)(() => {
        if (delay == null)
          return void 0;
        let timeoutId = null;
        timeoutId = window.setTimeout(() => {
          fn();
        }, delay);
        return () => {
          if (timeoutId) {
            window.clearTimeout(timeoutId);
          }
        };
      }, [delay, fn]);
    }
    var import_react26 = require_react();
    function useWhyDidYouUpdate(name, props) {
      const previousProps = (0, import_react26.useRef)();
      (0, import_react26.useEffect)(() => {
        if (previousProps.current) {
          const allKeys = Object.keys({ ...previousProps.current, ...props });
          const changesObj = {};
          allKeys.forEach((key) => {
            if (previousProps.current[key] !== props[key]) {
              changesObj[key] = {
                from: previousProps.current[key],
                to: props[key]
              };
            }
          });
          if (Object.keys(changesObj).length) {
            console.log("[why-did-you-update]", name, changesObj);
          }
        }
        previousProps.current = props;
      });
    }
  }
});

// ../../node_modules/@chakra-ui/input/dist/index.js
var require_dist45 = __commonJS({
  "../../node_modules/@chakra-ui/input/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Input: () => Input,
      InputAddon: () => InputAddon,
      InputGroup: () => InputGroup,
      InputLeftAddon: () => InputLeftAddon,
      InputLeftElement: () => InputLeftElement,
      InputRightAddon: () => InputRightAddon,
      InputRightElement: () => InputRightElement,
      useInputGroupStyles: () => useInputGroupStyles
    });
    module.exports = __toCommonJS2(src_exports);
    var import_form_control = require_dist29();
    var import_system = require_dist12();
    var import_shared_utils = require_dist3();
    var import_jsx_runtime = require_jsx_runtime();
    var Input = (0, import_system.forwardRef)(function Input2(props, ref) {
      const { htmlSize, ...rest } = props;
      const styles = (0, import_system.useMultiStyleConfig)("Input", rest);
      const ownProps = (0, import_system.omitThemingProps)(rest);
      const input = (0, import_form_control.useFormControl)(ownProps);
      const _className = (0, import_shared_utils.cx)("chakra-input", props.className);
      return (0, import_jsx_runtime.jsx)(
        import_system.chakra.input,
        {
          size: htmlSize,
          ...input,
          __css: styles.field,
          ref,
          className: _className
        }
      );
    });
    Input.displayName = "Input";
    Input.id = "Input";
    var import_system3 = require_dist12();
    var import_shared_utils3 = require_dist3();
    var import_react_context = require_dist13();
    var import_react_children_utils = require_dist24();
    var import_system2 = require_dist12();
    var import_shared_utils2 = require_dist3();
    var import_object_utils = require_dist7();
    var import_react = require_react();
    var import_jsx_runtime2 = require_jsx_runtime();
    var [InputGroupStylesProvider, useInputGroupStyles] = (0, import_react_context.createContext)({
      name: `InputGroupStylesContext`,
      errorMessage: `useInputGroupStyles returned is 'undefined'. Seems you forgot to wrap the components in "<InputGroup />" `
    });
    var InputGroup = (0, import_system2.forwardRef)(
      function InputGroup2(props, ref) {
        const styles = (0, import_system2.useMultiStyleConfig)("Input", props);
        const { children, className, ...rest } = (0, import_system2.omitThemingProps)(props);
        const _className = (0, import_shared_utils2.cx)("chakra-input__group", className);
        const groupStyles = {};
        const validChildren = (0, import_react_children_utils.getValidChildren)(children);
        const input = styles.field;
        validChildren.forEach((child) => {
          var _a, _b;
          if (!styles)
            return;
          if (input && child.type.id === "InputLeftElement") {
            groupStyles.paddingStart = (_a = input.height) != null ? _a : input.h;
          }
          if (input && child.type.id === "InputRightElement") {
            groupStyles.paddingEnd = (_b = input.height) != null ? _b : input.h;
          }
          if (child.type.id === "InputRightAddon") {
            groupStyles.borderEndRadius = 0;
          }
          if (child.type.id === "InputLeftAddon") {
            groupStyles.borderStartRadius = 0;
          }
        });
        const clones = validChildren.map((child) => {
          var _a, _b;
          const theming = (0, import_object_utils.compact)({
            size: ((_a = child.props) == null ? void 0 : _a.size) || props.size,
            variant: ((_b = child.props) == null ? void 0 : _b.variant) || props.variant
          });
          return child.type.id !== "Input" ? (0, import_react.cloneElement)(child, theming) : (0, import_react.cloneElement)(child, Object.assign(theming, groupStyles, child.props));
        });
        return (0, import_jsx_runtime2.jsx)(
          import_system2.chakra.div,
          {
            className: _className,
            ref,
            __css: {
              width: "100%",
              display: "flex",
              position: "relative",
              isolation: "isolate"
            },
            "data-group": true,
            ...rest,
            children: (0, import_jsx_runtime2.jsx)(InputGroupStylesProvider, { value: styles, children: clones })
          }
        );
      }
    );
    InputGroup.displayName = "InputGroup";
    var import_jsx_runtime3 = require_jsx_runtime();
    var placements = {
      left: {
        marginEnd: "-1px",
        borderEndRadius: 0,
        borderEndColor: "transparent"
      },
      right: {
        marginStart: "-1px",
        borderStartRadius: 0,
        borderStartColor: "transparent"
      }
    };
    var StyledAddon = (0, import_system3.chakra)("div", {
      baseStyle: {
        flex: "0 0 auto",
        width: "auto",
        display: "flex",
        alignItems: "center",
        whiteSpace: "nowrap"
      }
    });
    var InputAddon = (0, import_system3.forwardRef)(
      function InputAddon2(props, ref) {
        var _a;
        const { placement = "left", ...rest } = props;
        const placementStyles = (_a = placements[placement]) != null ? _a : {};
        const styles = useInputGroupStyles();
        return (0, import_jsx_runtime3.jsx)(
          StyledAddon,
          {
            ref,
            ...rest,
            __css: {
              ...styles.addon,
              ...placementStyles
            }
          }
        );
      }
    );
    InputAddon.displayName = "InputAddon";
    var InputLeftAddon = (0, import_system3.forwardRef)(
      function InputLeftAddon2(props, ref) {
        return (0, import_jsx_runtime3.jsx)(
          InputAddon,
          {
            ref,
            placement: "left",
            ...props,
            className: (0, import_shared_utils3.cx)("chakra-input__left-addon", props.className)
          }
        );
      }
    );
    InputLeftAddon.displayName = "InputLeftAddon";
    InputLeftAddon.id = "InputLeftAddon";
    var InputRightAddon = (0, import_system3.forwardRef)(
      function InputRightAddon2(props, ref) {
        return (0, import_jsx_runtime3.jsx)(
          InputAddon,
          {
            ref,
            placement: "right",
            ...props,
            className: (0, import_shared_utils3.cx)("chakra-input__right-addon", props.className)
          }
        );
      }
    );
    InputRightAddon.displayName = "InputRightAddon";
    InputRightAddon.id = "InputRightAddon";
    var import_system4 = require_dist12();
    var import_shared_utils4 = require_dist3();
    var import_jsx_runtime4 = require_jsx_runtime();
    var StyledInputElement = (0, import_system4.chakra)("div", {
      baseStyle: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        position: "absolute",
        top: "0",
        zIndex: 2
      }
    });
    var InputElement = (0, import_system4.forwardRef)(function InputElement2(props, ref) {
      var _a, _b;
      const { placement = "left", ...rest } = props;
      const styles = useInputGroupStyles();
      const input = styles.field;
      const attr = placement === "left" ? "insetStart" : "insetEnd";
      const elementStyles = {
        [attr]: "0",
        width: (_a = input == null ? void 0 : input.height) != null ? _a : input == null ? void 0 : input.h,
        height: (_b = input == null ? void 0 : input.height) != null ? _b : input == null ? void 0 : input.h,
        fontSize: input == null ? void 0 : input.fontSize,
        ...styles.element
      };
      return (0, import_jsx_runtime4.jsx)(StyledInputElement, { ref, __css: elementStyles, ...rest });
    });
    InputElement.id = "InputElement";
    InputElement.displayName = "InputElement";
    var InputLeftElement = (0, import_system4.forwardRef)(
      function InputLeftElement2(props, ref) {
        const { className, ...rest } = props;
        const _className = (0, import_shared_utils4.cx)("chakra-input__left-element", className);
        return (0, import_jsx_runtime4.jsx)(
          InputElement,
          {
            ref,
            placement: "left",
            className: _className,
            ...rest
          }
        );
      }
    );
    InputLeftElement.id = "InputLeftElement";
    InputLeftElement.displayName = "InputLeftElement";
    var InputRightElement = (0, import_system4.forwardRef)(
      function InputRightElement2(props, ref) {
        const { className, ...rest } = props;
        const _className = (0, import_shared_utils4.cx)("chakra-input__right-element", className);
        return (0, import_jsx_runtime4.jsx)(
          InputElement,
          {
            ref,
            placement: "right",
            className: _className,
            ...rest
          }
        );
      }
    );
    InputRightElement.id = "InputRightElement";
    InputRightElement.displayName = "InputRightElement";
  }
});

// ../../node_modules/@chakra-ui/breakpoint-utils/dist/index.js
var require_dist46 = __commonJS({
  "../../node_modules/@chakra-ui/breakpoint-utils/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      analyzeBreakpoints: () => analyzeBreakpoints,
      arrayToObjectNotation: () => arrayToObjectNotation,
      breakpoints: () => breakpoints,
      isCustomBreakpoint: () => isCustomBreakpoint,
      isResponsiveObjectLike: () => isResponsiveObjectLike,
      mapResponsive: () => mapResponsive,
      objectToArrayNotation: () => objectToArrayNotation,
      px: () => px,
      toMediaQueryString: () => toMediaQueryString
    });
    module.exports = __toCommonJS2(src_exports);
    var import_shared_utils = require_dist3();
    var breakpoints = Object.freeze([
      "base",
      "sm",
      "md",
      "lg",
      "xl",
      "2xl"
    ]);
    function mapResponsive(prop, mapper) {
      if (Array.isArray(prop)) {
        return prop.map((item) => item === null ? null : mapper(item));
      }
      if ((0, import_shared_utils.isObject)(prop)) {
        return Object.keys(prop).reduce((result, key) => {
          result[key] = mapper(prop[key]);
          return result;
        }, {});
      }
      if (prop != null) {
        return mapper(prop);
      }
      return null;
    }
    function objectToArrayNotation(obj, bps = breakpoints) {
      const result = bps.map((br) => {
        var _a;
        return (_a = obj[br]) != null ? _a : null;
      });
      const lastItem = result[result.length - 1];
      while (lastItem === null)
        result.pop();
      return result;
    }
    function arrayToObjectNotation(values, bps = breakpoints) {
      const result = {};
      values.forEach((value, index) => {
        const key = bps[index];
        if (value == null)
          return;
        result[key] = value;
      });
      return result;
    }
    function isResponsiveObjectLike(obj, bps = breakpoints) {
      const keys2 = Object.keys(obj);
      return keys2.length > 0 && keys2.every((key) => bps.includes(key));
    }
    var isCustomBreakpoint = (v) => Number.isNaN(Number(v));
    var import_shared_utils2 = require_dist3();
    function getLastItem(array) {
      const length = array == null ? 0 : array.length;
      return length ? array[length - 1] : void 0;
    }
    function analyzeCSSValue(value) {
      const num = parseFloat(value.toString());
      const unit = value.toString().replace(String(num), "");
      return { unitless: !unit, value: num, unit };
    }
    function px(value) {
      if (value == null)
        return value;
      const { unitless } = analyzeCSSValue(value);
      return unitless || typeof value === "number" ? `${value}px` : value;
    }
    var sortByBreakpointValue = (a, b) => parseInt(a[1], 10) > parseInt(b[1], 10) ? 1 : -1;
    var sortBps = (breakpoints2) => Object.fromEntries(Object.entries(breakpoints2).sort(sortByBreakpointValue));
    function normalize(breakpoints2) {
      const sorted = sortBps(breakpoints2);
      return Object.assign(Object.values(sorted), sorted);
    }
    function keys(breakpoints2) {
      const value = Object.keys(sortBps(breakpoints2));
      return new Set(value);
    }
    function subtract(value) {
      var _a;
      if (!value)
        return value;
      value = (_a = px(value)) != null ? _a : value;
      const OFFSET = -0.02;
      return typeof value === "number" ? `${value + OFFSET}` : value.replace(/(\d+\.?\d*)/u, (m) => `${parseFloat(m) + OFFSET}`);
    }
    function toMediaQueryString(min, max) {
      const query = ["@media screen"];
      if (min)
        query.push("and", `(min-width: ${px(min)})`);
      if (max)
        query.push("and", `(max-width: ${px(max)})`);
      return query.join(" ");
    }
    function analyzeBreakpoints(breakpoints2) {
      var _a;
      if (!breakpoints2)
        return null;
      breakpoints2.base = (_a = breakpoints2.base) != null ? _a : "0px";
      const normalized = normalize(breakpoints2);
      const queries = Object.entries(breakpoints2).sort(sortByBreakpointValue).map(([breakpoint, minW], index, entry) => {
        var _a2;
        let [, maxW] = (_a2 = entry[index + 1]) != null ? _a2 : [];
        maxW = parseFloat(maxW) > 0 ? subtract(maxW) : void 0;
        return {
          _minW: subtract(minW),
          breakpoint,
          minW,
          maxW,
          maxWQuery: toMediaQueryString(null, maxW),
          minWQuery: toMediaQueryString(minW),
          minMaxQuery: toMediaQueryString(minW, maxW)
        };
      });
      const _keys = keys(breakpoints2);
      const _keysArr = Array.from(_keys.values());
      return {
        keys: _keys,
        normalized,
        isResponsive(test) {
          const keys2 = Object.keys(test);
          return keys2.length > 0 && keys2.every((key) => _keys.has(key));
        },
        asObject: sortBps(breakpoints2),
        asArray: normalize(breakpoints2),
        details: queries,
        get(key) {
          return queries.find((q) => q.breakpoint === key);
        },
        media: [
          null,
          ...normalized.map((minW) => toMediaQueryString(minW)).slice(1)
        ],
        toArrayValue(test) {
          if (!(0, import_shared_utils2.isObject)(test)) {
            throw new Error("toArrayValue: value must be an object");
          }
          const result = _keysArr.map((bp) => {
            var _a2;
            return (_a2 = test[bp]) != null ? _a2 : null;
          });
          while (getLastItem(result) === null) {
            result.pop();
          }
          return result;
        },
        toObjectValue(test) {
          if (!Array.isArray(test)) {
            throw new Error("toObjectValue: value must be an array");
          }
          return test.reduce((acc, value, index) => {
            const key = _keysArr[index];
            if (key != null && value != null)
              acc[key] = value;
            return acc;
          }, {});
        }
      };
    }
  }
});

// ../../node_modules/@chakra-ui/layout/dist/index.js
var require_dist47 = __commonJS({
  "../../node_modules/@chakra-ui/layout/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      AbsoluteCenter: () => AbsoluteCenter,
      AspectRatio: () => AspectRatio,
      Badge: () => Badge,
      Box: () => Box,
      Center: () => Center,
      Circle: () => Circle,
      Code: () => Code,
      Container: () => Container,
      Divider: () => Divider,
      Flex: () => Flex,
      Grid: () => Grid,
      GridItem: () => GridItem,
      HStack: () => HStack,
      Heading: () => Heading,
      Highlight: () => Highlight,
      Kbd: () => Kbd,
      Link: () => Link,
      LinkBox: () => LinkBox,
      LinkOverlay: () => LinkOverlay,
      List: () => List,
      ListIcon: () => ListIcon,
      ListItem: () => ListItem,
      Mark: () => Mark,
      OrderedList: () => OrderedList,
      SimpleGrid: () => SimpleGrid,
      Spacer: () => Spacer,
      Square: () => Square,
      Stack: () => Stack,
      StackDivider: () => StackDivider,
      StackItem: () => StackItem,
      Text: () => Text,
      UnorderedList: () => UnorderedList,
      VStack: () => VStack,
      Wrap: () => Wrap,
      WrapItem: () => WrapItem,
      useHighlight: () => useHighlight,
      useListStyles: () => useListStyles
    });
    module.exports = __toCommonJS2(src_exports);
    var import_system = require_dist12();
    var import_breakpoint_utils = require_dist46();
    var import_shared_utils = require_dist3();
    var import_react = require_react();
    var import_jsx_runtime = require_jsx_runtime();
    var AspectRatio = (0, import_system.forwardRef)(function(props, ref) {
      const { ratio = 4 / 3, children, className, ...rest } = props;
      const child = import_react.Children.only(children);
      const _className = (0, import_shared_utils.cx)("chakra-aspect-ratio", className);
      return (0, import_jsx_runtime.jsx)(
        import_system.chakra.div,
        {
          ref,
          position: "relative",
          className: _className,
          _before: {
            height: 0,
            content: `""`,
            display: "block",
            paddingBottom: (0, import_breakpoint_utils.mapResponsive)(ratio, (r) => `${1 / r * 100}%`)
          },
          __css: {
            "& > *:not(style)": {
              overflow: "hidden",
              position: "absolute",
              top: "0",
              right: "0",
              bottom: "0",
              left: "0",
              display: "flex",
              justifyContent: "center",
              alignItems: "center",
              width: "100%",
              height: "100%"
            },
            "& > img, & > video": {
              objectFit: "cover"
            }
          },
          ...rest,
          children: child
        }
      );
    });
    AspectRatio.displayName = "AspectRatio";
    var import_system2 = require_dist12();
    var import_shared_utils2 = require_dist3();
    var import_jsx_runtime2 = require_jsx_runtime();
    var Badge = (0, import_system2.forwardRef)(function Badge2(props, ref) {
      const styles = (0, import_system2.useStyleConfig)("Badge", props);
      const { className, ...rest } = (0, import_system2.omitThemingProps)(props);
      return (0, import_jsx_runtime2.jsx)(
        import_system2.chakra.span,
        {
          ref,
          className: (0, import_shared_utils2.cx)("chakra-badge", props.className),
          ...rest,
          __css: {
            display: "inline-block",
            whiteSpace: "nowrap",
            verticalAlign: "middle",
            ...styles
          }
        }
      );
    });
    Badge.displayName = "Badge";
    var import_system3 = require_dist12();
    var import_jsx_runtime3 = require_jsx_runtime();
    var Box = (0, import_system3.chakra)("div");
    Box.displayName = "Box";
    var Square = (0, import_system3.forwardRef)(function Square2(props, ref) {
      const { size, centerContent = true, ...rest } = props;
      const styles = centerContent ? { display: "flex", alignItems: "center", justifyContent: "center" } : {};
      return (0, import_jsx_runtime3.jsx)(
        Box,
        {
          ref,
          boxSize: size,
          __css: {
            ...styles,
            flexShrink: 0,
            flexGrow: 0
          },
          ...rest
        }
      );
    });
    Square.displayName = "Square";
    var Circle = (0, import_system3.forwardRef)(function Circle2(props, ref) {
      const { size, ...rest } = props;
      return (0, import_jsx_runtime3.jsx)(Square, { size, ref, borderRadius: "9999px", ...rest });
    });
    Circle.displayName = "Circle";
    var import_system4 = require_dist12();
    var import_jsx_runtime4 = require_jsx_runtime();
    var Center = (0, import_system4.chakra)("div", {
      baseStyle: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      }
    });
    Center.displayName = "Center";
    var centerStyles = {
      horizontal: {
        insetStart: "50%",
        transform: "translateX(-50%)"
      },
      vertical: {
        top: "50%",
        transform: "translateY(-50%)"
      },
      both: {
        insetStart: "50%",
        top: "50%",
        transform: "translate(-50%, -50%)"
      }
    };
    var AbsoluteCenter = (0, import_system4.forwardRef)(
      function AbsoluteCenter2(props, ref) {
        const { axis = "both", ...rest } = props;
        return (0, import_jsx_runtime4.jsx)(
          import_system4.chakra.div,
          {
            ref,
            __css: centerStyles[axis],
            ...rest,
            position: "absolute"
          }
        );
      }
    );
    var import_system5 = require_dist12();
    var import_shared_utils3 = require_dist3();
    var import_jsx_runtime5 = require_jsx_runtime();
    var Code = (0, import_system5.forwardRef)(function Code2(props, ref) {
      const styles = (0, import_system5.useStyleConfig)("Code", props);
      const { className, ...rest } = (0, import_system5.omitThemingProps)(props);
      return (0, import_jsx_runtime5.jsx)(
        import_system5.chakra.code,
        {
          ref,
          className: (0, import_shared_utils3.cx)("chakra-code", props.className),
          ...rest,
          __css: {
            display: "inline-block",
            ...styles
          }
        }
      );
    });
    Code.displayName = "Code";
    var import_system6 = require_dist12();
    var import_shared_utils4 = require_dist3();
    var import_jsx_runtime6 = require_jsx_runtime();
    var Container = (0, import_system6.forwardRef)(function Container2(props, ref) {
      const { className, centerContent, ...rest } = (0, import_system6.omitThemingProps)(props);
      const styles = (0, import_system6.useStyleConfig)("Container", props);
      return (0, import_jsx_runtime6.jsx)(
        import_system6.chakra.div,
        {
          ref,
          className: (0, import_shared_utils4.cx)("chakra-container", className),
          ...rest,
          __css: {
            ...styles,
            ...centerContent && {
              display: "flex",
              flexDirection: "column",
              alignItems: "center"
            }
          }
        }
      );
    });
    Container.displayName = "Container";
    var import_system7 = require_dist12();
    var import_shared_utils5 = require_dist3();
    var import_jsx_runtime7 = require_jsx_runtime();
    var Divider = (0, import_system7.forwardRef)(function Divider2(props, ref) {
      const {
        borderLeftWidth,
        borderBottomWidth,
        borderTopWidth,
        borderRightWidth,
        borderWidth,
        borderStyle,
        borderColor,
        ...styles
      } = (0, import_system7.useStyleConfig)("Divider", props);
      const {
        className,
        orientation = "horizontal",
        __css,
        ...rest
      } = (0, import_system7.omitThemingProps)(props);
      const dividerStyles = {
        vertical: {
          borderLeftWidth: borderLeftWidth || borderRightWidth || borderWidth || "1px",
          height: "100%"
        },
        horizontal: {
          borderBottomWidth: borderBottomWidth || borderTopWidth || borderWidth || "1px",
          width: "100%"
        }
      };
      return (0, import_jsx_runtime7.jsx)(
        import_system7.chakra.hr,
        {
          ref,
          "aria-orientation": orientation,
          ...rest,
          __css: {
            ...styles,
            border: "0",
            borderColor,
            borderStyle,
            ...dividerStyles[orientation],
            ...__css
          },
          className: (0, import_shared_utils5.cx)("chakra-divider", className)
        }
      );
    });
    Divider.displayName = "Divider";
    var import_system8 = require_dist12();
    var import_jsx_runtime8 = require_jsx_runtime();
    var Flex = (0, import_system8.forwardRef)(function Flex2(props, ref) {
      const { direction, align, justify, wrap, basis, grow, shrink, ...rest } = props;
      const styles = {
        display: "flex",
        flexDirection: direction,
        alignItems: align,
        justifyContent: justify,
        flexWrap: wrap,
        flexBasis: basis,
        flexGrow: grow,
        flexShrink: shrink
      };
      return (0, import_jsx_runtime8.jsx)(import_system8.chakra.div, { ref, __css: styles, ...rest });
    });
    Flex.displayName = "Flex";
    var import_system9 = require_dist12();
    var import_jsx_runtime9 = require_jsx_runtime();
    var Grid = (0, import_system9.forwardRef)(function Grid2(props, ref) {
      const {
        templateAreas,
        gap,
        rowGap,
        columnGap,
        column,
        row,
        autoFlow,
        autoRows,
        templateRows,
        autoColumns,
        templateColumns,
        ...rest
      } = props;
      const styles = {
        display: "grid",
        gridTemplateAreas: templateAreas,
        gridGap: gap,
        gridRowGap: rowGap,
        gridColumnGap: columnGap,
        gridAutoColumns: autoColumns,
        gridColumn: column,
        gridRow: row,
        gridAutoFlow: autoFlow,
        gridAutoRows: autoRows,
        gridTemplateRows: templateRows,
        gridTemplateColumns: templateColumns
      };
      return (0, import_jsx_runtime9.jsx)(import_system9.chakra.div, { ref, __css: styles, ...rest });
    });
    Grid.displayName = "Grid";
    var import_system10 = require_dist12();
    var import_object_utils = require_dist7();
    var import_breakpoint_utils2 = require_dist46();
    var import_jsx_runtime10 = require_jsx_runtime();
    function spanFn(span) {
      return (0, import_breakpoint_utils2.mapResponsive)(
        span,
        (value) => value === "auto" ? "auto" : `span ${value}/span ${value}`
      );
    }
    var GridItem = (0, import_system10.forwardRef)(function GridItem2(props, ref) {
      const {
        area,
        colSpan,
        colStart,
        colEnd,
        rowEnd,
        rowSpan,
        rowStart,
        ...rest
      } = props;
      const styles = (0, import_object_utils.compact)({
        gridArea: area,
        gridColumn: spanFn(colSpan),
        gridRow: spanFn(rowSpan),
        gridColumnStart: colStart,
        gridColumnEnd: colEnd,
        gridRowStart: rowStart,
        gridRowEnd: rowEnd
      });
      return (0, import_jsx_runtime10.jsx)(import_system10.chakra.div, { ref, __css: styles, ...rest });
    });
    GridItem.displayName = "GridItem";
    var import_system11 = require_dist12();
    var import_shared_utils6 = require_dist3();
    var import_jsx_runtime11 = require_jsx_runtime();
    var Heading = (0, import_system11.forwardRef)(function Heading2(props, ref) {
      const styles = (0, import_system11.useStyleConfig)("Heading", props);
      const { className, ...rest } = (0, import_system11.omitThemingProps)(props);
      return (0, import_jsx_runtime11.jsx)(
        import_system11.chakra.h2,
        {
          ref,
          className: (0, import_shared_utils6.cx)("chakra-heading", props.className),
          ...rest,
          __css: styles
        }
      );
    });
    Heading.displayName = "Heading";
    var import_system12 = require_dist12();
    var import_react2 = require_react();
    var import_jsx_runtime12 = require_jsx_runtime();
    var escapeRegexp = (term) => term.replace(/[|\\{}()[\]^$+*?.-]/g, (char) => `\\${char}`);
    function buildRegex(query) {
      const _query = query.filter((text) => text.length !== 0).map((text) => escapeRegexp(text.trim()));
      if (!_query.length) {
        return null;
      }
      return new RegExp(`(${_query.join("|")})`, "ig");
    }
    function highlightWords({ text, query }) {
      const regex = buildRegex(Array.isArray(query) ? query : [query]);
      if (!regex) {
        return [{ text, match: false }];
      }
      const result = text.split(regex).filter(Boolean);
      return result.map((str) => ({ text: str, match: regex.test(str) }));
    }
    function useHighlight(props) {
      const { text, query } = props;
      return (0, import_react2.useMemo)(() => highlightWords({ text, query }), [text, query]);
    }
    var Mark = (0, import_system12.forwardRef)(function Mark2(props, ref) {
      const styles = (0, import_system12.useStyleConfig)("Mark", props);
      const ownProps = (0, import_system12.omitThemingProps)(props);
      return (0, import_jsx_runtime12.jsx)(
        Box,
        {
          ref,
          ...ownProps,
          as: "mark",
          __css: { bg: "transparent", whiteSpace: "nowrap", ...styles }
        }
      );
    });
    function Highlight(props) {
      const { children, query, styles } = props;
      if (typeof children !== "string") {
        throw new Error("The children prop of Highlight must be a string");
      }
      const chunks = useHighlight({ query, text: children });
      return (0, import_jsx_runtime12.jsx)(import_jsx_runtime12.Fragment, { children: chunks.map((chunk, index) => {
        return chunk.match ? (0, import_jsx_runtime12.jsx)(Mark, { sx: styles, children: chunk.text }, index) : (0, import_jsx_runtime12.jsx)(import_react2.Fragment, { children: chunk.text }, index);
      }) });
    }
    var import_system13 = require_dist12();
    var import_shared_utils7 = require_dist3();
    var import_jsx_runtime13 = require_jsx_runtime();
    var Kbd = (0, import_system13.forwardRef)(function Kbd2(props, ref) {
      const styles = (0, import_system13.useStyleConfig)("Kbd", props);
      const { className, ...rest } = (0, import_system13.omitThemingProps)(props);
      return (0, import_jsx_runtime13.jsx)(
        import_system13.chakra.kbd,
        {
          ref,
          className: (0, import_shared_utils7.cx)("chakra-kbd", className),
          ...rest,
          __css: {
            fontFamily: "mono",
            ...styles
          }
        }
      );
    });
    Kbd.displayName = "Kbd";
    var import_system14 = require_dist12();
    var import_shared_utils8 = require_dist3();
    var import_jsx_runtime14 = require_jsx_runtime();
    var Link = (0, import_system14.forwardRef)(function Link2(props, ref) {
      const styles = (0, import_system14.useStyleConfig)("Link", props);
      const { className, isExternal, ...rest } = (0, import_system14.omitThemingProps)(props);
      return (0, import_jsx_runtime14.jsx)(
        import_system14.chakra.a,
        {
          target: isExternal ? "_blank" : void 0,
          rel: isExternal ? "noopener" : void 0,
          ref,
          className: (0, import_shared_utils8.cx)("chakra-link", className),
          ...rest,
          __css: styles
        }
      );
    });
    Link.displayName = "Link";
    var import_system15 = require_dist12();
    var import_shared_utils9 = require_dist3();
    var import_jsx_runtime15 = require_jsx_runtime();
    var LinkOverlay = (0, import_system15.forwardRef)(
      function LinkOverlay2(props, ref) {
        const { isExternal, target, rel, className, ...rest } = props;
        return (0, import_jsx_runtime15.jsx)(
          import_system15.chakra.a,
          {
            ...rest,
            ref,
            className: (0, import_shared_utils9.cx)("chakra-linkbox__overlay", className),
            rel: isExternal ? "noopener noreferrer" : rel,
            target: isExternal ? "_blank" : target,
            __css: {
              position: "static",
              "&::before": {
                content: "''",
                cursor: "inherit",
                display: "block",
                position: "absolute",
                top: 0,
                left: 0,
                zIndex: 0,
                width: "100%",
                height: "100%"
              }
            }
          }
        );
      }
    );
    var LinkBox = (0, import_system15.forwardRef)(function LinkBox2(props, ref) {
      const { className, ...rest } = props;
      return (0, import_jsx_runtime15.jsx)(
        import_system15.chakra.div,
        {
          ref,
          position: "relative",
          ...rest,
          className: (0, import_shared_utils9.cx)("chakra-linkbox", className),
          __css: {
            "a[href]:not(.chakra-linkbox__overlay), abbr[title]": {
              position: "relative",
              zIndex: 1
            }
          }
        }
      );
    });
    var import_icon = require_dist18();
    var import_react_context = require_dist13();
    var import_react_children_utils = require_dist24();
    var import_system16 = require_dist12();
    var import_jsx_runtime16 = require_jsx_runtime();
    var [ListStylesProvider, useListStyles] = (0, import_react_context.createContext)({
      name: `ListStylesContext`,
      errorMessage: `useListStyles returned is 'undefined'. Seems you forgot to wrap the components in "<List />" `
    });
    var List = (0, import_system16.forwardRef)(function List2(props, ref) {
      const styles = (0, import_system16.useMultiStyleConfig)("List", props);
      const {
        children,
        styleType = "none",
        stylePosition,
        spacing,
        ...rest
      } = (0, import_system16.omitThemingProps)(props);
      const validChildren = (0, import_react_children_utils.getValidChildren)(children);
      const selector2 = "& > *:not(style) ~ *:not(style)";
      const spacingStyle = spacing ? { [selector2]: { mt: spacing } } : {};
      return (0, import_jsx_runtime16.jsx)(ListStylesProvider, { value: styles, children: (0, import_jsx_runtime16.jsx)(
        import_system16.chakra.ul,
        {
          ref,
          listStyleType: styleType,
          listStylePosition: stylePosition,
          role: "list",
          __css: { ...styles.container, ...spacingStyle },
          ...rest,
          children: validChildren
        }
      ) });
    });
    List.displayName = "List";
    var OrderedList = (0, import_system16.forwardRef)((props, ref) => {
      const { as, ...rest } = props;
      return (0, import_jsx_runtime16.jsx)(List, { ref, as: "ol", styleType: "decimal", marginStart: "1em", ...rest });
    });
    OrderedList.displayName = "OrderedList";
    var UnorderedList = (0, import_system16.forwardRef)(function UnorderedList2(props, ref) {
      const { as, ...rest } = props;
      return (0, import_jsx_runtime16.jsx)(List, { ref, as: "ul", styleType: "initial", marginStart: "1em", ...rest });
    });
    UnorderedList.displayName = "UnorderedList";
    var ListItem = (0, import_system16.forwardRef)(function ListItem2(props, ref) {
      const styles = useListStyles();
      return (0, import_jsx_runtime16.jsx)(import_system16.chakra.li, { ref, ...props, __css: styles.item });
    });
    ListItem.displayName = "ListItem";
    var ListIcon = (0, import_system16.forwardRef)(function ListIcon2(props, ref) {
      const styles = useListStyles();
      return (0, import_jsx_runtime16.jsx)(import_icon.Icon, { ref, role: "presentation", ...props, __css: styles.icon });
    });
    ListIcon.displayName = "ListIcon";
    var import_system17 = require_dist12();
    var import_breakpoint_utils3 = require_dist46();
    var import_jsx_runtime17 = require_jsx_runtime();
    var SimpleGrid = (0, import_system17.forwardRef)(
      function SimpleGrid2(props, ref) {
        const { columns, spacingX, spacingY, spacing, minChildWidth, ...rest } = props;
        const theme = (0, import_system17.useTheme)();
        const templateColumns = minChildWidth ? widthToColumns(minChildWidth, theme) : countToColumns(columns);
        return (0, import_jsx_runtime17.jsx)(
          Grid,
          {
            ref,
            gap: spacing,
            columnGap: spacingX,
            rowGap: spacingY,
            templateColumns,
            ...rest
          }
        );
      }
    );
    SimpleGrid.displayName = "SimpleGrid";
    function toPx(n) {
      return typeof n === "number" ? `${n}px` : n;
    }
    function widthToColumns(width, theme) {
      return (0, import_breakpoint_utils3.mapResponsive)(width, (value) => {
        const _value = (0, import_system17.getToken)("sizes", value, toPx(value))(theme);
        return value === null ? null : `repeat(auto-fit, minmax(${_value}, 1fr))`;
      });
    }
    function countToColumns(count) {
      return (0, import_breakpoint_utils3.mapResponsive)(
        count,
        (value) => value === null ? null : `repeat(${value}, minmax(0, 1fr))`
      );
    }
    var import_system18 = require_dist12();
    var Spacer = (0, import_system18.chakra)("div", {
      baseStyle: {
        flex: 1,
        justifySelf: "stretch",
        alignSelf: "stretch"
      }
    });
    Spacer.displayName = "Spacer";
    var import_system21 = require_dist12();
    var import_system20 = require_dist12();
    var import_shared_utils10 = require_dist3();
    var import_react_children_utils2 = require_dist24();
    var import_react3 = require_react();
    var import_breakpoint_utils4 = require_dist46();
    var selector = "& > *:not(style) ~ *:not(style)";
    function getStackStyles(options) {
      const { spacing, direction } = options;
      const directionStyles = {
        column: {
          marginTop: spacing,
          marginEnd: 0,
          marginBottom: 0,
          marginStart: 0
        },
        row: { marginTop: 0, marginEnd: 0, marginBottom: 0, marginStart: spacing },
        "column-reverse": {
          marginTop: 0,
          marginEnd: 0,
          marginBottom: spacing,
          marginStart: 0
        },
        "row-reverse": {
          marginTop: 0,
          marginEnd: spacing,
          marginBottom: 0,
          marginStart: 0
        }
      };
      return {
        flexDirection: direction,
        [selector]: (0, import_breakpoint_utils4.mapResponsive)(
          direction,
          (value) => directionStyles[value]
        )
      };
    }
    function getDividerStyles(options) {
      const { spacing, direction } = options;
      const dividerStyles = {
        column: {
          my: spacing,
          mx: 0,
          borderLeftWidth: 0,
          borderBottomWidth: "1px"
        },
        "column-reverse": {
          my: spacing,
          mx: 0,
          borderLeftWidth: 0,
          borderBottomWidth: "1px"
        },
        row: {
          mx: spacing,
          my: 0,
          borderLeftWidth: "1px",
          borderBottomWidth: 0
        },
        "row-reverse": {
          mx: spacing,
          my: 0,
          borderLeftWidth: "1px",
          borderBottomWidth: 0
        }
      };
      return {
        "&": (0, import_breakpoint_utils4.mapResponsive)(
          direction,
          (value) => dividerStyles[value]
        )
      };
    }
    var import_system19 = require_dist12();
    var import_jsx_runtime18 = require_jsx_runtime();
    var StackItem = (props) => (0, import_jsx_runtime18.jsx)(
      import_system19.chakra.div,
      {
        className: "chakra-stack__item",
        ...props,
        __css: {
          display: "inline-block",
          flex: "0 0 auto",
          minWidth: 0,
          ...props["__css"]
        }
      }
    );
    StackItem.displayName = "StackItem";
    var import_jsx_runtime19 = require_jsx_runtime();
    var Stack = (0, import_system20.forwardRef)((props, ref) => {
      const {
        isInline,
        direction: directionProp,
        align,
        justify,
        spacing = "0.5rem",
        wrap,
        children,
        divider,
        className,
        shouldWrapChildren,
        ...rest
      } = props;
      const direction = isInline ? "row" : directionProp != null ? directionProp : "column";
      const styles = (0, import_react3.useMemo)(
        () => getStackStyles({ direction, spacing }),
        [direction, spacing]
      );
      const dividerStyle = (0, import_react3.useMemo)(
        () => getDividerStyles({ spacing, direction }),
        [spacing, direction]
      );
      const hasDivider = !!divider;
      const shouldUseChildren = !shouldWrapChildren && !hasDivider;
      const clones = (0, import_react3.useMemo)(() => {
        const validChildren = (0, import_react_children_utils2.getValidChildren)(children);
        return shouldUseChildren ? validChildren : validChildren.map((child, index) => {
          const key = typeof child.key !== "undefined" ? child.key : index;
          const isLast = index + 1 === validChildren.length;
          const wrappedChild = (0, import_jsx_runtime19.jsx)(StackItem, { children: child }, key);
          const _child = shouldWrapChildren ? wrappedChild : child;
          if (!hasDivider)
            return _child;
          const clonedDivider = (0, import_react3.cloneElement)(
            divider,
            {
              __css: dividerStyle
            }
          );
          const _divider = isLast ? null : clonedDivider;
          return (0, import_jsx_runtime19.jsxs)(import_react3.Fragment, { children: [
            _child,
            _divider
          ] }, key);
        });
      }, [
        divider,
        dividerStyle,
        hasDivider,
        shouldUseChildren,
        shouldWrapChildren,
        children
      ]);
      const _className = (0, import_shared_utils10.cx)("chakra-stack", className);
      return (0, import_jsx_runtime19.jsx)(
        import_system20.chakra.div,
        {
          ref,
          display: "flex",
          alignItems: align,
          justifyContent: justify,
          flexDirection: styles.flexDirection,
          flexWrap: wrap,
          className: _className,
          __css: hasDivider ? {} : { [selector]: styles[selector] },
          ...rest,
          children: clones
        }
      );
    });
    Stack.displayName = "Stack";
    var import_jsx_runtime20 = require_jsx_runtime();
    var HStack = (0, import_system21.forwardRef)((props, ref) => (0, import_jsx_runtime20.jsx)(Stack, { align: "center", ...props, direction: "row", ref }));
    HStack.displayName = "HStack";
    var import_system22 = require_dist12();
    var import_jsx_runtime21 = require_jsx_runtime();
    var StackDivider = (props) => (0, import_jsx_runtime21.jsx)(
      import_system22.chakra.div,
      {
        className: "chakra-stack__divider",
        ...props,
        __css: {
          ...props["__css"],
          borderWidth: 0,
          alignSelf: "stretch",
          borderColor: "inherit",
          width: "auto",
          height: "auto"
        }
      }
    );
    StackDivider.displayName = "StackDivider";
    var import_system23 = require_dist12();
    var import_jsx_runtime22 = require_jsx_runtime();
    var VStack = (0, import_system23.forwardRef)((props, ref) => (0, import_jsx_runtime22.jsx)(Stack, { align: "center", ...props, direction: "column", ref }));
    VStack.displayName = "VStack";
    var import_system24 = require_dist12();
    var import_shared_utils11 = require_dist3();
    var import_object_utils2 = require_dist7();
    var import_jsx_runtime23 = require_jsx_runtime();
    var Text = (0, import_system24.forwardRef)(function Text2(props, ref) {
      const styles = (0, import_system24.useStyleConfig)("Text", props);
      const { className, align, decoration, casing, ...rest } = (0, import_system24.omitThemingProps)(props);
      const aliasedProps = (0, import_object_utils2.compact)({
        textAlign: props.align,
        textDecoration: props.decoration,
        textTransform: props.casing
      });
      return (0, import_jsx_runtime23.jsx)(
        import_system24.chakra.p,
        {
          ref,
          className: (0, import_shared_utils11.cx)("chakra-text", props.className),
          ...aliasedProps,
          ...rest,
          __css: styles
        }
      );
    });
    Text.displayName = "Text";
    var import_system25 = require_dist12();
    var import_shared_utils12 = require_dist3();
    var import_breakpoint_utils5 = require_dist46();
    var import_react4 = require_react();
    var import_jsx_runtime24 = require_jsx_runtime();
    function px(value) {
      return typeof value === "number" ? `${value}px` : value;
    }
    var Wrap = (0, import_system25.forwardRef)(function Wrap2(props, ref) {
      const {
        spacing = "0.5rem",
        spacingX,
        spacingY,
        children,
        justify,
        direction,
        align,
        className,
        shouldWrapChildren,
        ...rest
      } = props;
      const styles = (0, import_react4.useMemo)(() => {
        const { spacingX: x = spacing, spacingY: y = spacing } = {
          spacingX,
          spacingY
        };
        return {
          "--chakra-wrap-x-spacing": (theme) => (0, import_breakpoint_utils5.mapResponsive)(x, (value) => px((0, import_system25.tokenToCSSVar)("space", value)(theme))),
          "--chakra-wrap-y-spacing": (theme) => (0, import_breakpoint_utils5.mapResponsive)(y, (value) => px((0, import_system25.tokenToCSSVar)("space", value)(theme))),
          "--wrap-x-spacing": "calc(var(--chakra-wrap-x-spacing) / 2)",
          "--wrap-y-spacing": "calc(var(--chakra-wrap-y-spacing) / 2)",
          display: "flex",
          flexWrap: "wrap",
          justifyContent: justify,
          alignItems: align,
          flexDirection: direction,
          listStyleType: "none",
          padding: "0",
          margin: "calc(var(--wrap-y-spacing) * -1) calc(var(--wrap-x-spacing) * -1)",
          "& > *:not(style)": {
            margin: "var(--wrap-y-spacing) var(--wrap-x-spacing)"
          }
        };
      }, [spacing, spacingX, spacingY, justify, align, direction]);
      const childrenToRender = (0, import_react4.useMemo)(
        () => shouldWrapChildren ? import_react4.Children.map(children, (child, index) => (0, import_jsx_runtime24.jsx)(WrapItem, { children: child }, index)) : children,
        [children, shouldWrapChildren]
      );
      return (0, import_jsx_runtime24.jsx)(
        import_system25.chakra.div,
        {
          ref,
          className: (0, import_shared_utils12.cx)("chakra-wrap", className),
          overflow: "hidden",
          ...rest,
          children: (0, import_jsx_runtime24.jsx)(import_system25.chakra.ul, { className: "chakra-wrap__list", __css: styles, children: childrenToRender })
        }
      );
    });
    Wrap.displayName = "Wrap";
    var WrapItem = (0, import_system25.forwardRef)(function WrapItem2(props, ref) {
      const { className, ...rest } = props;
      return (0, import_jsx_runtime24.jsx)(
        import_system25.chakra.li,
        {
          ref,
          __css: { display: "flex", alignItems: "flex-start" },
          className: (0, import_shared_utils12.cx)("chakra-wrap__listitem", className),
          ...rest
        }
      );
    });
    WrapItem.displayName = "WrapItem";
  }
});

// ../../node_modules/@chakra-ui/react-env/dist/index.js
var require_dist48 = __commonJS({
  "../../node_modules/@chakra-ui/react-env/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      EnvironmentProvider: () => EnvironmentProvider,
      useEnvironment: () => useEnvironment
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react_use_safe_layout_effect = require_dist();
    var import_react = require_react();
    var import_jsx_runtime = require_jsx_runtime();
    var EnvironmentContext = (0, import_react.createContext)({
      getDocument() {
        return document;
      },
      getWindow() {
        return window;
      }
    });
    EnvironmentContext.displayName = "EnvironmentContext";
    function useEnvironment({ defer } = {}) {
      const [, forceUpdate] = (0, import_react.useReducer)((c) => c + 1, 0);
      (0, import_react_use_safe_layout_effect.useSafeLayoutEffect)(() => {
        if (!defer)
          return;
        forceUpdate();
      }, [defer]);
      return (0, import_react.useContext)(EnvironmentContext);
    }
    function EnvironmentProvider(props) {
      const { children, environment: environmentProp, disabled } = props;
      const ref = (0, import_react.useRef)(null);
      const context = (0, import_react.useMemo)(() => {
        if (environmentProp)
          return environmentProp;
        return {
          getDocument: () => {
            var _a, _b;
            return (_b = (_a = ref.current) == null ? void 0 : _a.ownerDocument) != null ? _b : document;
          },
          getWindow: () => {
            var _a, _b;
            return (_b = (_a = ref.current) == null ? void 0 : _a.ownerDocument.defaultView) != null ? _b : window;
          }
        };
      }, [environmentProp]);
      const showSpan = !disabled || !environmentProp;
      return (0, import_jsx_runtime.jsxs)(EnvironmentContext.Provider, { value: context, children: [
        children,
        showSpan && (0, import_jsx_runtime.jsx)("span", { id: "__chakra_env", hidden: true, ref })
      ] });
    }
    EnvironmentProvider.displayName = "EnvironmentProvider";
  }
});

// ../../node_modules/@chakra-ui/media-query/dist/index.js
var require_dist49 = __commonJS({
  "../../node_modules/@chakra-ui/media-query/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Hide: () => Hide,
      Show: () => Show,
      useBreakpoint: () => useBreakpoint,
      useBreakpointValue: () => useBreakpointValue,
      useColorModePreference: () => useColorModePreference,
      useMediaQuery: () => useMediaQuery,
      usePrefersReducedMotion: () => usePrefersReducedMotion,
      useQuery: () => useQuery
    });
    module.exports = __toCommonJS2(src_exports);
    var import_system = require_dist12();
    var getBreakpoint = (theme, value) => {
      var _a, _b;
      return (_b = (_a = theme == null ? void 0 : theme.breakpoints) == null ? void 0 : _a[value]) != null ? _b : value;
    };
    function useQuery(props) {
      const { breakpoint = "", below, above } = props;
      const theme = (0, import_system.useTheme)();
      const bpBelow = getBreakpoint(theme, below);
      const bpAbove = getBreakpoint(theme, above);
      let query = breakpoint;
      if (bpBelow) {
        query = `(max-width: ${bpBelow})`;
      } else if (bpAbove) {
        query = `(min-width: ${bpAbove})`;
      }
      return query;
    }
    var import_react_env = require_dist48();
    var import_react = require_react();
    function useMediaQuery(query, options = {}) {
      const { ssr = true, fallback } = options;
      const { getWindow } = (0, import_react_env.useEnvironment)();
      const queries = Array.isArray(query) ? query : [query];
      let fallbackValues = Array.isArray(fallback) ? fallback : [fallback];
      fallbackValues = fallbackValues.filter((v) => v != null);
      const [value, setValue] = (0, import_react.useState)(() => {
        return queries.map((query2, index) => ({
          media: query2,
          matches: ssr ? !!fallbackValues[index] : getWindow().matchMedia(query2).matches
        }));
      });
      (0, import_react.useEffect)(() => {
        const win = getWindow();
        setValue(
          queries.map((query2) => ({
            media: query2,
            matches: win.matchMedia(query2).matches
          }))
        );
        const mql = queries.map((query2) => win.matchMedia(query2));
        const handler = (evt) => {
          setValue((prev) => {
            return prev.slice().map((item) => {
              if (item.media === evt.media)
                return { ...item, matches: evt.matches };
              return item;
            });
          });
        };
        mql.forEach((mql2) => {
          if (typeof mql2.addListener === "function") {
            mql2.addListener(handler);
          } else {
            mql2.addEventListener("change", handler);
          }
        });
        return () => {
          mql.forEach((mql2) => {
            if (typeof mql2.removeListener === "function") {
              mql2.removeListener(handler);
            } else {
              mql2.removeEventListener("change", handler);
            }
          });
        };
      }, [getWindow]);
      return value.map((item) => item.matches);
    }
    function Visibility(props) {
      const { breakpoint, hide, children, ssr } = props;
      const [show] = useMediaQuery(breakpoint, { ssr });
      const isVisible = hide ? !show : show;
      const rendered = isVisible ? children : null;
      return rendered;
    }
    var import_jsx_runtime = require_jsx_runtime();
    function Hide(props) {
      const { children, ssr } = props;
      const query = useQuery(props);
      return (0, import_jsx_runtime.jsx)(Visibility, { breakpoint: query, hide: true, ssr, children });
    }
    Hide.displayName = "Hide";
    function usePrefersReducedMotion(options) {
      const [prefersReducedMotion] = useMediaQuery(
        "(prefers-reduced-motion: reduce)",
        options
      );
      return prefersReducedMotion;
    }
    function useColorModePreference(options) {
      const [isLight, isDark] = useMediaQuery(
        ["(prefers-color-scheme: light)", "(prefers-color-scheme: dark)"],
        options
      );
      if (isLight)
        return "light";
      if (isDark)
        return "dark";
      return void 0;
    }
    var import_jsx_runtime2 = require_jsx_runtime();
    function Show(props) {
      const { children, ssr } = props;
      const query = useQuery(props);
      return (0, import_jsx_runtime2.jsx)(Visibility, { breakpoint: query, ssr, children });
    }
    Show.displayName = "Show";
    var import_system2 = require_dist12();
    var import_shared_utils = require_dist3();
    function useBreakpoint(arg) {
      var _a, _b;
      const opts = (0, import_shared_utils.isObject)(arg) ? arg : { fallback: arg != null ? arg : "base" };
      const theme = (0, import_system2.useTheme)();
      const breakpoints = theme.__breakpoints.details.map(
        ({ minMaxQuery, breakpoint }) => ({
          breakpoint,
          query: minMaxQuery.replace("@media screen and ", "")
        })
      );
      const fallback = breakpoints.map((bp) => bp.breakpoint === opts.fallback);
      const values = useMediaQuery(
        breakpoints.map((bp) => bp.query),
        { fallback, ssr: opts.ssr }
      );
      const index = values.findIndex((value) => value == true);
      return (_b = (_a = breakpoints[index]) == null ? void 0 : _a.breakpoint) != null ? _b : opts.fallback;
    }
    var import_system3 = require_dist12();
    var import_shared_utils2 = require_dist3();
    var import_breakpoint_utils2 = require_dist46();
    var import_breakpoint_utils = require_dist46();
    function getClosestValue(values, breakpoint, breakpoints = import_breakpoint_utils.breakpoints) {
      let index = Object.keys(values).indexOf(breakpoint);
      if (index !== -1) {
        return values[breakpoint];
      }
      let stopIndex = breakpoints.indexOf(breakpoint);
      while (stopIndex >= 0) {
        const key = breakpoints[stopIndex];
        if (values.hasOwnProperty(key)) {
          index = stopIndex;
          break;
        }
        stopIndex -= 1;
      }
      if (index !== -1) {
        const key = breakpoints[index];
        return values[key];
      }
      return void 0;
    }
    function useBreakpointValue(values, arg) {
      var _a;
      const opts = (0, import_shared_utils2.isObject)(arg) ? arg : { fallback: arg != null ? arg : "base" };
      const breakpoint = useBreakpoint(opts);
      const theme = (0, import_system3.useTheme)();
      if (!breakpoint)
        return;
      const breakpoints = Array.from(((_a = theme.__breakpoints) == null ? void 0 : _a.keys) || []);
      const obj = Array.isArray(values) ? Object.fromEntries(
        Object.entries((0, import_breakpoint_utils2.arrayToObjectNotation)(values, breakpoints)).map(
          ([key, value]) => [key, value]
        )
      ) : values;
      return getClosestValue(obj, breakpoint, breakpoints);
    }
  }
});

// ../../node_modules/@chakra-ui/clickable/dist/index.js
var require_dist50 = __commonJS({
  "../../node_modules/@chakra-ui/clickable/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      useClickable: () => useClickable
    });
    module.exports = __toCommonJS2(src_exports);
    var import_shared_utils = require_dist3();
    var import_react_use_merge_refs = require_dist14();
    var import_react = require_react();
    function useEventListeners() {
      const listeners = (0, import_react.useRef)(/* @__PURE__ */ new Map());
      const currentListeners = listeners.current;
      const add = (0, import_react.useCallback)((el, type, listener, options) => {
        listeners.current.set(listener, { type, el, options });
        el.addEventListener(type, listener, options);
      }, []);
      const remove = (0, import_react.useCallback)(
        (el, type, listener, options) => {
          el.removeEventListener(type, listener, options);
          listeners.current.delete(listener);
        },
        []
      );
      (0, import_react.useEffect)(
        () => () => {
          currentListeners.forEach((value, key) => {
            remove(value.el, value.type, key, value.options);
          });
        },
        [remove, currentListeners]
      );
      return { add, remove };
    }
    var import_react2 = require_react();
    function isValidElement(event) {
      const element = event.target;
      const { tagName, isContentEditable } = element;
      return tagName !== "INPUT" && tagName !== "TEXTAREA" && isContentEditable !== true;
    }
    function useClickable(props = {}) {
      const {
        ref: htmlRef,
        isDisabled,
        isFocusable,
        clickOnEnter = true,
        clickOnSpace = true,
        onMouseDown,
        onMouseUp,
        onClick,
        onKeyDown,
        onKeyUp,
        tabIndex: tabIndexProp,
        onMouseOver,
        onMouseLeave,
        ...htmlProps
      } = props;
      const [isButton, setIsButton] = (0, import_react2.useState)(true);
      const [isPressed, setIsPressed] = (0, import_react2.useState)(false);
      const listeners = useEventListeners();
      const refCallback = (node) => {
        if (!node)
          return;
        if (node.tagName !== "BUTTON") {
          setIsButton(false);
        }
      };
      const tabIndex = isButton ? tabIndexProp : tabIndexProp || 0;
      const trulyDisabled = isDisabled && !isFocusable;
      const handleClick = (0, import_react2.useCallback)(
        (event) => {
          if (isDisabled) {
            event.stopPropagation();
            event.preventDefault();
            return;
          }
          const self2 = event.currentTarget;
          self2.focus();
          onClick == null ? void 0 : onClick(event);
        },
        [isDisabled, onClick]
      );
      const onDocumentKeyUp = (0, import_react2.useCallback)(
        (e) => {
          if (isPressed && isValidElement(e)) {
            e.preventDefault();
            e.stopPropagation();
            setIsPressed(false);
            listeners.remove(document, "keyup", onDocumentKeyUp, false);
          }
        },
        [isPressed, listeners]
      );
      const handleKeyDown = (0, import_react2.useCallback)(
        (event) => {
          onKeyDown == null ? void 0 : onKeyDown(event);
          if (isDisabled || event.defaultPrevented || event.metaKey) {
            return;
          }
          if (!isValidElement(event.nativeEvent) || isButton)
            return;
          const shouldClickOnEnter = clickOnEnter && event.key === "Enter";
          const shouldClickOnSpace = clickOnSpace && event.key === " ";
          if (shouldClickOnSpace) {
            event.preventDefault();
            setIsPressed(true);
          }
          if (shouldClickOnEnter) {
            event.preventDefault();
            const self2 = event.currentTarget;
            self2.click();
          }
          listeners.add(document, "keyup", onDocumentKeyUp, false);
        },
        [
          isDisabled,
          isButton,
          onKeyDown,
          clickOnEnter,
          clickOnSpace,
          listeners,
          onDocumentKeyUp
        ]
      );
      const handleKeyUp = (0, import_react2.useCallback)(
        (event) => {
          onKeyUp == null ? void 0 : onKeyUp(event);
          if (isDisabled || event.defaultPrevented || event.metaKey)
            return;
          if (!isValidElement(event.nativeEvent) || isButton)
            return;
          const shouldClickOnSpace = clickOnSpace && event.key === " ";
          if (shouldClickOnSpace) {
            event.preventDefault();
            setIsPressed(false);
            const self2 = event.currentTarget;
            self2.click();
          }
        },
        [clickOnSpace, isButton, isDisabled, onKeyUp]
      );
      const onDocumentMouseUp = (0, import_react2.useCallback)(
        (event) => {
          if (event.button !== 0)
            return;
          setIsPressed(false);
          listeners.remove(document, "mouseup", onDocumentMouseUp, false);
        },
        [listeners]
      );
      const handleMouseDown = (0, import_react2.useCallback)(
        (event) => {
          if (event.button !== 0)
            return;
          if (isDisabled) {
            event.stopPropagation();
            event.preventDefault();
            return;
          }
          if (!isButton) {
            setIsPressed(true);
          }
          const target = event.currentTarget;
          target.focus({ preventScroll: true });
          listeners.add(document, "mouseup", onDocumentMouseUp, false);
          onMouseDown == null ? void 0 : onMouseDown(event);
        },
        [isDisabled, isButton, onMouseDown, listeners, onDocumentMouseUp]
      );
      const handleMouseUp = (0, import_react2.useCallback)(
        (event) => {
          if (event.button !== 0)
            return;
          if (!isButton) {
            setIsPressed(false);
          }
          onMouseUp == null ? void 0 : onMouseUp(event);
        },
        [onMouseUp, isButton]
      );
      const handleMouseOver = (0, import_react2.useCallback)(
        (event) => {
          if (isDisabled) {
            event.preventDefault();
            return;
          }
          onMouseOver == null ? void 0 : onMouseOver(event);
        },
        [isDisabled, onMouseOver]
      );
      const handleMouseLeave = (0, import_react2.useCallback)(
        (event) => {
          if (isPressed) {
            event.preventDefault();
            setIsPressed(false);
          }
          onMouseLeave == null ? void 0 : onMouseLeave(event);
        },
        [isPressed, onMouseLeave]
      );
      const ref = (0, import_react_use_merge_refs.mergeRefs)(htmlRef, refCallback);
      if (isButton) {
        return {
          ...htmlProps,
          ref,
          type: "button",
          "aria-disabled": trulyDisabled ? void 0 : isDisabled,
          disabled: trulyDisabled,
          onClick: handleClick,
          onMouseDown,
          onMouseUp,
          onKeyUp,
          onKeyDown,
          onMouseOver,
          onMouseLeave
        };
      }
      return {
        ...htmlProps,
        ref,
        role: "button",
        "data-active": (0, import_shared_utils.dataAttr)(isPressed),
        "aria-disabled": isDisabled ? "true" : void 0,
        tabIndex: trulyDisabled ? void 0 : tabIndex,
        onClick: handleClick,
        onMouseDown: handleMouseDown,
        onMouseUp: handleMouseUp,
        onKeyUp: handleKeyUp,
        onKeyDown: handleKeyDown,
        onMouseOver: handleMouseOver,
        onMouseLeave: handleMouseLeave
      };
    }
  }
});

// ../../node_modules/@chakra-ui/react-use-focus-effect/dist/index.js
var require_dist51 = __commonJS({
  "../../node_modules/@chakra-ui/react-use-focus-effect/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      useFocusOnHide: () => useFocusOnHide,
      useFocusOnShow: () => useFocusOnShow
    });
    module.exports = __toCommonJS2(src_exports);
    var import_dom_utils = require_dist42();
    var import_react_use_event_listener = require_dist39();
    var import_react_use_safe_layout_effect = require_dist();
    var import_react_use_update_effect = require_dist30();
    var import_react = require_react();
    function preventReturnFocus(containerRef) {
      const el = containerRef.current;
      if (!el)
        return false;
      const activeElement = (0, import_dom_utils.getActiveElement)(el);
      if (!activeElement)
        return false;
      if (el.contains(activeElement))
        return false;
      if ((0, import_dom_utils.isTabbable)(activeElement))
        return true;
      return false;
    }
    function useFocusOnHide(containerRef, options) {
      const { shouldFocus: shouldFocusProp, visible, focusRef } = options;
      const shouldFocus = shouldFocusProp && !visible;
      (0, import_react_use_update_effect.useUpdateEffect)(() => {
        if (!shouldFocus)
          return;
        if (preventReturnFocus(containerRef)) {
          return;
        }
        const el = (focusRef == null ? void 0 : focusRef.current) || containerRef.current;
        let rafId;
        if (el) {
          rafId = requestAnimationFrame(() => {
            el.focus({ preventScroll: true });
          });
          return () => {
            cancelAnimationFrame(rafId);
          };
        }
      }, [shouldFocus, containerRef, focusRef]);
    }
    var defaultOptions = {
      preventScroll: true,
      shouldFocus: false
    };
    function useFocusOnShow(target, options = defaultOptions) {
      const { focusRef, preventScroll, shouldFocus, visible } = options;
      const element = isRefObject(target) ? target.current : target;
      const autoFocusValue = shouldFocus && visible;
      const autoFocusRef = (0, import_react.useRef)(autoFocusValue);
      const lastVisibleRef = (0, import_react.useRef)(visible);
      (0, import_react_use_safe_layout_effect.useSafeLayoutEffect)(() => {
        if (!lastVisibleRef.current && visible) {
          autoFocusRef.current = autoFocusValue;
        }
        lastVisibleRef.current = visible;
      }, [visible, autoFocusValue]);
      const onFocus = (0, import_react.useCallback)(() => {
        if (!visible || !element || !autoFocusRef.current)
          return;
        autoFocusRef.current = false;
        if (element.contains(document.activeElement))
          return;
        if (focusRef == null ? void 0 : focusRef.current) {
          requestAnimationFrame(() => {
            var _a;
            (_a = focusRef.current) == null ? void 0 : _a.focus({ preventScroll });
          });
        } else {
          const tabbableEls = (0, import_dom_utils.getAllFocusable)(element);
          if (tabbableEls.length > 0) {
            requestAnimationFrame(() => {
              tabbableEls[0].focus({ preventScroll });
            });
          }
        }
      }, [visible, preventScroll, element, focusRef]);
      (0, import_react_use_update_effect.useUpdateEffect)(() => {
        onFocus();
      }, [onFocus]);
      (0, import_react_use_event_listener.useEventListener)(element, "transitionend", onFocus);
    }
    function isRefObject(val) {
      return "current" in val;
    }
  }
});

// ../../node_modules/@chakra-ui/popper/dist/index.js
var require_dist52 = __commonJS({
  "../../node_modules/@chakra-ui/popper/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      popperCSSVars: () => cssVars,
      usePopper: () => usePopper
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react_use_merge_refs = require_dist14();
    var import_core = (init_lib(), __toCommonJS(lib_exports));
    var import_react = require_react();
    var toVar = (value, fallback) => ({
      var: value,
      varRef: fallback ? `var(${value}, ${fallback})` : `var(${value})`
    });
    var cssVars = {
      arrowShadowColor: toVar("--popper-arrow-shadow-color"),
      arrowSize: toVar("--popper-arrow-size", "8px"),
      arrowSizeHalf: toVar("--popper-arrow-size-half"),
      arrowBg: toVar("--popper-arrow-bg"),
      transformOrigin: toVar("--popper-transform-origin"),
      arrowOffset: toVar("--popper-arrow-offset")
    };
    function getBoxShadow(placement) {
      if (placement.includes("top"))
        return `1px 1px 0px 0 var(--popper-arrow-shadow-color)`;
      if (placement.includes("bottom"))
        return `-1px -1px 0px 0 var(--popper-arrow-shadow-color)`;
      if (placement.includes("right"))
        return `-1px 1px 0px 0 var(--popper-arrow-shadow-color)`;
      if (placement.includes("left"))
        return `1px -1px 0px 0 var(--popper-arrow-shadow-color)`;
    }
    var transforms = {
      top: "bottom center",
      "top-start": "bottom left",
      "top-end": "bottom right",
      bottom: "top center",
      "bottom-start": "top left",
      "bottom-end": "top right",
      left: "right center",
      "left-start": "right top",
      "left-end": "right bottom",
      right: "left center",
      "right-start": "left top",
      "right-end": "left bottom"
    };
    var toTransformOrigin = (placement) => transforms[placement];
    var defaultEventListeners = {
      scroll: true,
      resize: true
    };
    function getEventListenerOptions(value) {
      let eventListeners;
      if (typeof value === "object") {
        eventListeners = {
          enabled: true,
          options: { ...defaultEventListeners, ...value }
        };
      } else {
        eventListeners = {
          enabled: value,
          options: defaultEventListeners
        };
      }
      return eventListeners;
    }
    var matchWidth = {
      name: "matchWidth",
      enabled: true,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: ({ state }) => {
        state.styles.popper.width = `${state.rects.reference.width}px`;
      },
      effect: ({ state }) => () => {
        const reference = state.elements.reference;
        state.elements.popper.style.width = `${reference.offsetWidth}px`;
      }
    };
    var transformOrigin = {
      name: "transformOrigin",
      enabled: true,
      phase: "write",
      fn: ({ state }) => {
        setTransformOrigin(state);
      },
      effect: ({ state }) => () => {
        setTransformOrigin(state);
      }
    };
    var setTransformOrigin = (state) => {
      state.elements.popper.style.setProperty(
        cssVars.transformOrigin.var,
        toTransformOrigin(state.placement)
      );
    };
    var positionArrow = {
      name: "positionArrow",
      enabled: true,
      phase: "afterWrite",
      fn: ({ state }) => {
        setArrowStyles(state);
      }
    };
    var setArrowStyles = (state) => {
      var _a;
      if (!state.placement)
        return;
      const overrides = getArrowStyle(state.placement);
      if (((_a = state.elements) == null ? void 0 : _a.arrow) && overrides) {
        Object.assign(state.elements.arrow.style, {
          [overrides.property]: overrides.value,
          width: cssVars.arrowSize.varRef,
          height: cssVars.arrowSize.varRef,
          zIndex: -1
        });
        const vars = {
          [cssVars.arrowSizeHalf.var]: `calc(${cssVars.arrowSize.varRef} / 2 - 1px)`,
          [cssVars.arrowOffset.var]: `calc(${cssVars.arrowSizeHalf.varRef} * -1)`
        };
        for (const property in vars) {
          state.elements.arrow.style.setProperty(property, vars[property]);
        }
      }
    };
    var getArrowStyle = (placement) => {
      if (placement.startsWith("top")) {
        return { property: "bottom", value: cssVars.arrowOffset.varRef };
      }
      if (placement.startsWith("bottom")) {
        return { property: "top", value: cssVars.arrowOffset.varRef };
      }
      if (placement.startsWith("left")) {
        return { property: "right", value: cssVars.arrowOffset.varRef };
      }
      if (placement.startsWith("right")) {
        return { property: "left", value: cssVars.arrowOffset.varRef };
      }
    };
    var innerArrow = {
      name: "innerArrow",
      enabled: true,
      phase: "main",
      requires: ["arrow"],
      fn: ({ state }) => {
        setInnerArrowStyles(state);
      },
      effect: ({ state }) => () => {
        setInnerArrowStyles(state);
      }
    };
    var setInnerArrowStyles = (state) => {
      if (!state.elements.arrow)
        return;
      const inner = state.elements.arrow.querySelector(
        "[data-popper-arrow-inner]"
      );
      if (!inner)
        return;
      const boxShadow = getBoxShadow(state.placement);
      if (boxShadow) {
        inner.style.setProperty("--popper-arrow-default-shadow", boxShadow);
      }
      Object.assign(inner.style, {
        transform: "rotate(45deg)",
        background: cssVars.arrowBg.varRef,
        top: 0,
        left: 0,
        width: "100%",
        height: "100%",
        position: "absolute",
        zIndex: "inherit",
        boxShadow: `var(--popper-arrow-shadow, var(--popper-arrow-default-shadow))`
      });
    };
    var logicals = {
      "start-start": { ltr: "left-start", rtl: "right-start" },
      "start-end": { ltr: "left-end", rtl: "right-end" },
      "end-start": { ltr: "right-start", rtl: "left-start" },
      "end-end": { ltr: "right-end", rtl: "left-end" },
      start: { ltr: "left", rtl: "right" },
      end: { ltr: "right", rtl: "left" }
    };
    var opposites = {
      "auto-start": "auto-end",
      "auto-end": "auto-start",
      "top-start": "top-end",
      "top-end": "top-start",
      "bottom-start": "bottom-end",
      "bottom-end": "bottom-start"
    };
    function getPopperPlacement(placement, dir = "ltr") {
      var _a, _b;
      const value = ((_a = logicals[placement]) == null ? void 0 : _a[dir]) || placement;
      if (dir === "ltr")
        return value;
      return (_b = opposites[placement]) != null ? _b : value;
    }
    function usePopper(props = {}) {
      const {
        enabled = true,
        modifiers,
        placement: placementProp = "bottom",
        strategy = "absolute",
        arrowPadding = 8,
        eventListeners = true,
        offset,
        gutter = 8,
        flip = true,
        boundary = "clippingParents",
        preventOverflow = true,
        matchWidth: matchWidth2,
        direction = "ltr"
      } = props;
      const reference = (0, import_react.useRef)(null);
      const popper = (0, import_react.useRef)(null);
      const instance = (0, import_react.useRef)(null);
      const placement = getPopperPlacement(placementProp, direction);
      const cleanup = (0, import_react.useRef)(() => {
      });
      const setupPopper = (0, import_react.useCallback)(() => {
        var _a;
        if (!enabled || !reference.current || !popper.current)
          return;
        (_a = cleanup.current) == null ? void 0 : _a.call(cleanup);
        instance.current = (0, import_core.createPopper)(reference.current, popper.current, {
          placement,
          modifiers: [
            innerArrow,
            positionArrow,
            transformOrigin,
            {
              ...matchWidth,
              enabled: !!matchWidth2
            },
            {
              name: "eventListeners",
              ...getEventListenerOptions(eventListeners)
            },
            {
              name: "arrow",
              options: { padding: arrowPadding }
            },
            {
              name: "offset",
              options: {
                offset: offset != null ? offset : [0, gutter]
              }
            },
            {
              name: "flip",
              enabled: !!flip,
              options: { padding: 8 }
            },
            {
              name: "preventOverflow",
              enabled: !!preventOverflow,
              options: { boundary }
            },
            ...modifiers != null ? modifiers : []
          ],
          strategy
        });
        instance.current.forceUpdate();
        cleanup.current = instance.current.destroy;
      }, [
        placement,
        enabled,
        modifiers,
        matchWidth2,
        eventListeners,
        arrowPadding,
        offset,
        gutter,
        flip,
        preventOverflow,
        boundary,
        strategy
      ]);
      (0, import_react.useEffect)(() => {
        return () => {
          var _a;
          if (!reference.current && !popper.current) {
            (_a = instance.current) == null ? void 0 : _a.destroy();
            instance.current = null;
          }
        };
      }, []);
      const referenceRef = (0, import_react.useCallback)(
        (node) => {
          reference.current = node;
          setupPopper();
        },
        [setupPopper]
      );
      const getReferenceProps = (0, import_react.useCallback)(
        (props2 = {}, ref = null) => ({
          ...props2,
          ref: (0, import_react_use_merge_refs.mergeRefs)(referenceRef, ref)
        }),
        [referenceRef]
      );
      const popperRef = (0, import_react.useCallback)(
        (node) => {
          popper.current = node;
          setupPopper();
        },
        [setupPopper]
      );
      const getPopperProps = (0, import_react.useCallback)(
        (props2 = {}, ref = null) => ({
          ...props2,
          ref: (0, import_react_use_merge_refs.mergeRefs)(popperRef, ref),
          style: {
            ...props2.style,
            position: strategy,
            minWidth: matchWidth2 ? void 0 : "max-content",
            inset: "0 auto auto 0"
          }
        }),
        [strategy, popperRef, matchWidth2]
      );
      const getArrowProps = (0, import_react.useCallback)((props2 = {}, ref = null) => {
        const { size, shadowColor, bg, style, ...rest } = props2;
        return {
          ...rest,
          ref,
          "data-popper-arrow": "",
          style: getArrowStyle2(props2)
        };
      }, []);
      const getArrowInnerProps = (0, import_react.useCallback)(
        (props2 = {}, ref = null) => ({
          ...props2,
          ref,
          "data-popper-arrow-inner": ""
        }),
        []
      );
      return {
        update() {
          var _a;
          (_a = instance.current) == null ? void 0 : _a.update();
        },
        forceUpdate() {
          var _a;
          (_a = instance.current) == null ? void 0 : _a.forceUpdate();
        },
        transformOrigin: cssVars.transformOrigin.varRef,
        referenceRef,
        popperRef,
        getPopperProps,
        getArrowProps,
        getArrowInnerProps,
        getReferenceProps
      };
    }
    function getArrowStyle2(props) {
      const { size, shadowColor, bg, style } = props;
      const computedStyle = { ...style, position: "absolute" };
      if (size) {
        computedStyle["--popper-arrow-size"] = size;
      }
      if (shadowColor) {
        computedStyle["--popper-arrow-shadow-color"] = shadowColor;
      }
      if (bg) {
        computedStyle["--popper-arrow-bg"] = bg;
      }
      return computedStyle;
    }
  }
});

// ../../node_modules/@chakra-ui/react-use-disclosure/dist/index.js
var require_dist53 = __commonJS({
  "../../node_modules/@chakra-ui/react-use-disclosure/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      useDisclosure: () => useDisclosure
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react_use_callback_ref = require_dist16();
    var import_react = require_react();
    function useDisclosure(props = {}) {
      const {
        onClose: onCloseProp,
        onOpen: onOpenProp,
        isOpen: isOpenProp,
        id: idProp
      } = props;
      const handleOpen = (0, import_react_use_callback_ref.useCallbackRef)(onOpenProp);
      const handleClose = (0, import_react_use_callback_ref.useCallbackRef)(onCloseProp);
      const [isOpenState, setIsOpen] = (0, import_react.useState)(props.defaultIsOpen || false);
      const isOpen = isOpenProp !== void 0 ? isOpenProp : isOpenState;
      const isControlled = isOpenProp !== void 0;
      const uid = (0, import_react.useId)();
      const id = idProp != null ? idProp : `disclosure-${uid}`;
      const onClose = (0, import_react.useCallback)(() => {
        if (!isControlled) {
          setIsOpen(false);
        }
        handleClose == null ? void 0 : handleClose();
      }, [isControlled, handleClose]);
      const onOpen = (0, import_react.useCallback)(() => {
        if (!isControlled) {
          setIsOpen(true);
        }
        handleOpen == null ? void 0 : handleOpen();
      }, [isControlled, handleOpen]);
      const onToggle = (0, import_react.useCallback)(() => {
        if (isOpen) {
          onClose();
        } else {
          onOpen();
        }
      }, [isOpen, onOpen, onClose]);
      function getButtonProps(props2 = {}) {
        return {
          ...props2,
          "aria-expanded": isOpen,
          "aria-controls": id,
          onClick(event) {
            var _a;
            (_a = props2.onClick) == null ? void 0 : _a.call(props2, event);
            onToggle();
          }
        };
      }
      function getDisclosureProps(props2 = {}) {
        return {
          ...props2,
          hidden: !isOpen,
          id
        };
      }
      return {
        isOpen,
        onOpen,
        onClose,
        onToggle,
        isControlled,
        getButtonProps,
        getDisclosureProps
      };
    }
  }
});

// ../../node_modules/@chakra-ui/react-use-outside-click/dist/index.js
var require_dist54 = __commonJS({
  "../../node_modules/@chakra-ui/react-use-outside-click/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      useOutsideClick: () => useOutsideClick
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react = require_react();
    var import_react_use_callback_ref = require_dist16();
    function useOutsideClick(props) {
      const { ref, handler, enabled = true } = props;
      const savedHandler = (0, import_react_use_callback_ref.useCallbackRef)(handler);
      const stateRef = (0, import_react.useRef)({
        isPointerDown: false,
        ignoreEmulatedMouseEvents: false
      });
      const state = stateRef.current;
      (0, import_react.useEffect)(() => {
        if (!enabled)
          return;
        const onPointerDown = (e) => {
          if (isValidEvent(e, ref)) {
            state.isPointerDown = true;
          }
        };
        const onMouseUp = (event) => {
          if (state.ignoreEmulatedMouseEvents) {
            state.ignoreEmulatedMouseEvents = false;
            return;
          }
          if (state.isPointerDown && handler && isValidEvent(event, ref)) {
            state.isPointerDown = false;
            savedHandler(event);
          }
        };
        const onTouchEnd = (event) => {
          state.ignoreEmulatedMouseEvents = true;
          if (handler && state.isPointerDown && isValidEvent(event, ref)) {
            state.isPointerDown = false;
            savedHandler(event);
          }
        };
        const doc = getOwnerDocument(ref.current);
        doc.addEventListener("mousedown", onPointerDown, true);
        doc.addEventListener("mouseup", onMouseUp, true);
        doc.addEventListener("touchstart", onPointerDown, true);
        doc.addEventListener("touchend", onTouchEnd, true);
        return () => {
          doc.removeEventListener("mousedown", onPointerDown, true);
          doc.removeEventListener("mouseup", onMouseUp, true);
          doc.removeEventListener("touchstart", onPointerDown, true);
          doc.removeEventListener("touchend", onTouchEnd, true);
        };
      }, [handler, ref, savedHandler, state, enabled]);
    }
    function isValidEvent(event, ref) {
      var _a;
      const target = event.target;
      if (target) {
        const doc = getOwnerDocument(target);
        if (!doc.contains(target))
          return false;
      }
      return !((_a = ref.current) == null ? void 0 : _a.contains(target));
    }
    function getOwnerDocument(node) {
      var _a;
      return (_a = node == null ? void 0 : node.ownerDocument) != null ? _a : document;
    }
  }
});

// ../../node_modules/@chakra-ui/react-use-animation-state/dist/index.js
var require_dist55 = __commonJS({
  "../../node_modules/@chakra-ui/react-use-animation-state/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      useAnimationState: () => useAnimationState
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react = require_react();
    var import_react_use_event_listener = require_dist39();
    var import_dom_utils = require_dist42();
    function useAnimationState(props) {
      const { isOpen, ref } = props;
      const [mounted, setMounted] = (0, import_react.useState)(isOpen);
      const [once, setOnce] = (0, import_react.useState)(false);
      (0, import_react.useEffect)(() => {
        if (!once) {
          setMounted(isOpen);
          setOnce(true);
        }
      }, [isOpen, once, mounted]);
      (0, import_react_use_event_listener.useEventListener)(
        () => ref.current,
        "animationend",
        () => {
          setMounted(isOpen);
        }
      );
      const hidden = isOpen ? false : !mounted;
      return {
        present: !hidden,
        onComplete() {
          var _a;
          const win = (0, import_dom_utils.getOwnerWindow)(ref.current);
          const evt = new win.CustomEvent("animationend", { bubbles: true });
          (_a = ref.current) == null ? void 0 : _a.dispatchEvent(evt);
        }
      };
    }
  }
});

// ../../node_modules/@chakra-ui/lazy-utils/dist/index.js
var require_dist56 = __commonJS({
  "../../node_modules/@chakra-ui/lazy-utils/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      lazyDisclosure: () => lazyDisclosure
    });
    module.exports = __toCommonJS2(src_exports);
    function lazyDisclosure(options) {
      const { wasSelected, enabled, isSelected, mode = "unmount" } = options;
      if (!enabled)
        return true;
      if (isSelected)
        return true;
      if (mode === "keepMounted" && wasSelected)
        return true;
      return false;
    }
  }
});

// ../../node_modules/@chakra-ui/menu/dist/index.js
var require_dist57 = __commonJS({
  "../../node_modules/@chakra-ui/menu/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Menu: () => Menu,
      MenuButton: () => MenuButton,
      MenuCommand: () => MenuCommand,
      MenuDescendantsProvider: () => MenuDescendantsProvider,
      MenuDivider: () => MenuDivider,
      MenuGroup: () => MenuGroup,
      MenuIcon: () => MenuIcon,
      MenuItem: () => MenuItem,
      MenuItemOption: () => MenuItemOption,
      MenuList: () => MenuList,
      MenuOptionGroup: () => MenuOptionGroup,
      MenuProvider: () => MenuProvider,
      useMenu: () => useMenu,
      useMenuButton: () => useMenuButton,
      useMenuContext: () => useMenuContext,
      useMenuDescendant: () => useMenuDescendant,
      useMenuDescendants: () => useMenuDescendants,
      useMenuDescendantsContext: () => useMenuDescendantsContext,
      useMenuItem: () => useMenuItem,
      useMenuList: () => useMenuList,
      useMenuOption: () => useMenuOption,
      useMenuOptionGroup: () => useMenuOptionGroup,
      useMenuPositioner: () => useMenuPositioner,
      useMenuState: () => useMenuState,
      useMenuStyles: () => useMenuStyles
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react_context2 = require_dist13();
    var import_system = require_dist12();
    var import_shared_utils2 = require_dist3();
    var import_react3 = require_react();
    var import_clickable = require_dist50();
    var import_descendant = require_dist15();
    var import_react_use_focus_effect = require_dist51();
    var import_popper = require_dist52();
    var import_react_use_disclosure = require_dist53();
    var import_react_use_outside_click = require_dist54();
    var import_react_use_animation_state = require_dist55();
    var import_react_context = require_dist13();
    var import_react_children_utils = require_dist24();
    var import_react_use_controllable_state = require_dist17();
    var import_react_use_update_effect = require_dist30();
    var import_react_use_merge_refs = require_dist14();
    var import_shared_utils = require_dist3();
    var import_lazy_utils = require_dist56();
    var import_react2 = require_react();
    var import_react = require_react();
    function isPrintableCharacter(event) {
      const { key } = event;
      return key.length === 1 || key.length > 1 && /[^a-zA-Z0-9]/.test(key);
    }
    function useShortcut(props = {}) {
      const { timeout = 300, preventDefault = () => true } = props;
      const [keys, setKeys] = (0, import_react.useState)([]);
      const timeoutRef = (0, import_react.useRef)();
      const flush = () => {
        if (timeoutRef.current) {
          clearTimeout(timeoutRef.current);
          timeoutRef.current = null;
        }
      };
      const clearKeysAfterDelay = () => {
        flush();
        timeoutRef.current = setTimeout(() => {
          setKeys([]);
          timeoutRef.current = null;
        }, timeout);
      };
      (0, import_react.useEffect)(() => flush, []);
      function onKeyDown(fn) {
        return (event) => {
          if (event.key === "Backspace") {
            const keysCopy = [...keys];
            keysCopy.pop();
            setKeys(keysCopy);
            return;
          }
          if (isPrintableCharacter(event)) {
            const keysCopy = keys.concat(event.key);
            if (preventDefault(event)) {
              event.preventDefault();
              event.stopPropagation();
            }
            setKeys(keysCopy);
            fn(keysCopy.join(""));
            clearKeysAfterDelay();
          }
        };
      }
      return onKeyDown;
    }
    function getNextItemFromSearch(items, searchString, itemToString, currentItem) {
      if (searchString == null) {
        return currentItem;
      }
      if (!currentItem) {
        const foundItem = items.find(
          (item) => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase())
        );
        return foundItem;
      }
      const matchingItems = items.filter(
        (item) => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase())
      );
      if (matchingItems.length > 0) {
        let nextIndex;
        if (matchingItems.includes(currentItem)) {
          const currentIndex = matchingItems.indexOf(currentItem);
          nextIndex = currentIndex + 1;
          if (nextIndex === matchingItems.length) {
            nextIndex = 0;
          }
          return matchingItems[nextIndex];
        }
        nextIndex = items.indexOf(matchingItems[0]);
        return items[nextIndex];
      }
      return currentItem;
    }
    var [
      MenuDescendantsProvider,
      useMenuDescendantsContext,
      useMenuDescendants,
      useMenuDescendant
    ] = (0, import_descendant.createDescendantContext)();
    var [MenuProvider, useMenuContext] = (0, import_react_context.createContext)({
      strict: false,
      name: "MenuContext"
    });
    function useIds(idProp, ...prefixes) {
      const reactId = (0, import_react2.useId)();
      const id = idProp || reactId;
      return (0, import_react2.useMemo)(() => {
        return prefixes.map((prefix) => `${prefix}-${id}`);
      }, [id, prefixes]);
    }
    function getOwnerDocument(node) {
      var _a;
      return (_a = node == null ? void 0 : node.ownerDocument) != null ? _a : document;
    }
    function isActiveElement(element) {
      const doc = getOwnerDocument(element);
      return doc.activeElement === element;
    }
    function useMenu(props = {}) {
      const {
        id,
        closeOnSelect = true,
        closeOnBlur = true,
        initialFocusRef,
        autoSelect = true,
        isLazy,
        isOpen: isOpenProp,
        defaultIsOpen,
        onClose: onCloseProp,
        onOpen: onOpenProp,
        placement = "bottom-start",
        lazyBehavior = "unmount",
        direction,
        computePositionOnMount = false,
        ...popperProps
      } = props;
      const menuRef = (0, import_react2.useRef)(null);
      const buttonRef = (0, import_react2.useRef)(null);
      const descendants = useMenuDescendants();
      const focusMenu = (0, import_react2.useCallback)(() => {
        requestAnimationFrame(() => {
          var _a;
          (_a = menuRef.current) == null ? void 0 : _a.focus({ preventScroll: false });
        });
      }, []);
      const focusFirstItem = (0, import_react2.useCallback)(() => {
        const id2 = setTimeout(() => {
          var _a;
          if (initialFocusRef) {
            (_a = initialFocusRef.current) == null ? void 0 : _a.focus();
          } else {
            const first = descendants.firstEnabled();
            if (first)
              setFocusedIndex(first.index);
          }
        });
        timeoutIds.current.add(id2);
      }, [descendants, initialFocusRef]);
      const focusLastItem = (0, import_react2.useCallback)(() => {
        const id2 = setTimeout(() => {
          const last = descendants.lastEnabled();
          if (last)
            setFocusedIndex(last.index);
        });
        timeoutIds.current.add(id2);
      }, [descendants]);
      const onOpenInternal = (0, import_react2.useCallback)(() => {
        onOpenProp == null ? void 0 : onOpenProp();
        if (autoSelect) {
          focusFirstItem();
        } else {
          focusMenu();
        }
      }, [autoSelect, focusFirstItem, focusMenu, onOpenProp]);
      const { isOpen, onOpen, onClose, onToggle } = (0, import_react_use_disclosure.useDisclosure)({
        isOpen: isOpenProp,
        defaultIsOpen,
        onClose: onCloseProp,
        onOpen: onOpenInternal
      });
      (0, import_react_use_outside_click.useOutsideClick)({
        enabled: isOpen && closeOnBlur,
        ref: menuRef,
        handler: (event) => {
          var _a;
          if (!((_a = buttonRef.current) == null ? void 0 : _a.contains(event.target))) {
            onClose();
          }
        }
      });
      const popper = (0, import_popper.usePopper)({
        ...popperProps,
        enabled: isOpen || computePositionOnMount,
        placement,
        direction
      });
      const [focusedIndex, setFocusedIndex] = (0, import_react2.useState)(-1);
      (0, import_react_use_update_effect.useUpdateEffect)(() => {
        if (!isOpen) {
          setFocusedIndex(-1);
        }
      }, [isOpen]);
      (0, import_react_use_focus_effect.useFocusOnHide)(menuRef, {
        focusRef: buttonRef,
        visible: isOpen,
        shouldFocus: true
      });
      const animationState = (0, import_react_use_animation_state.useAnimationState)({ isOpen, ref: menuRef });
      const [buttonId, menuId] = useIds(id, `menu-button`, `menu-list`);
      const openAndFocusMenu = (0, import_react2.useCallback)(() => {
        onOpen();
        focusMenu();
      }, [onOpen, focusMenu]);
      const timeoutIds = (0, import_react2.useRef)(/* @__PURE__ */ new Set([]));
      useUnmountEffect(() => {
        timeoutIds.current.forEach((id2) => clearTimeout(id2));
        timeoutIds.current.clear();
      });
      const openAndFocusFirstItem = (0, import_react2.useCallback)(() => {
        onOpen();
        focusFirstItem();
      }, [focusFirstItem, onOpen]);
      const openAndFocusLastItem = (0, import_react2.useCallback)(() => {
        onOpen();
        focusLastItem();
      }, [onOpen, focusLastItem]);
      const refocus = (0, import_react2.useCallback)(() => {
        var _a, _b;
        const doc = getOwnerDocument(menuRef.current);
        const hasFocusWithin = (_a = menuRef.current) == null ? void 0 : _a.contains(doc.activeElement);
        const shouldRefocus = isOpen && !hasFocusWithin;
        if (!shouldRefocus)
          return;
        const node = (_b = descendants.item(focusedIndex)) == null ? void 0 : _b.node;
        node == null ? void 0 : node.focus();
      }, [isOpen, focusedIndex, descendants]);
      const rafId = (0, import_react2.useRef)(null);
      return {
        openAndFocusMenu,
        openAndFocusFirstItem,
        openAndFocusLastItem,
        onTransitionEnd: refocus,
        unstable__animationState: animationState,
        descendants,
        popper,
        buttonId,
        menuId,
        forceUpdate: popper.forceUpdate,
        orientation: "vertical",
        isOpen,
        onToggle,
        onOpen,
        onClose,
        menuRef,
        buttonRef,
        focusedIndex,
        closeOnSelect,
        closeOnBlur,
        autoSelect,
        setFocusedIndex,
        isLazy,
        lazyBehavior,
        initialFocusRef,
        rafId
      };
    }
    function useMenuButton(props = {}, externalRef = null) {
      const menu = useMenuContext();
      const { onToggle, popper, openAndFocusFirstItem, openAndFocusLastItem } = menu;
      const onKeyDown = (0, import_react2.useCallback)(
        (event) => {
          const eventKey = event.key;
          const keyMap = {
            Enter: openAndFocusFirstItem,
            ArrowDown: openAndFocusFirstItem,
            ArrowUp: openAndFocusLastItem
          };
          const action = keyMap[eventKey];
          if (action) {
            event.preventDefault();
            event.stopPropagation();
            action(event);
          }
        },
        [openAndFocusFirstItem, openAndFocusLastItem]
      );
      return {
        ...props,
        ref: (0, import_react_use_merge_refs.mergeRefs)(menu.buttonRef, externalRef, popper.referenceRef),
        id: menu.buttonId,
        "data-active": (0, import_shared_utils.dataAttr)(menu.isOpen),
        "aria-expanded": menu.isOpen,
        "aria-haspopup": "menu",
        "aria-controls": menu.menuId,
        onClick: (0, import_shared_utils.callAllHandlers)(props.onClick, onToggle),
        onKeyDown: (0, import_shared_utils.callAllHandlers)(props.onKeyDown, onKeyDown)
      };
    }
    function isTargetMenuItem(target) {
      var _a;
      return isHTMLElement(target) && !!((_a = target == null ? void 0 : target.getAttribute("role")) == null ? void 0 : _a.startsWith("menuitem"));
    }
    function useMenuList(props = {}, ref = null) {
      const menu = useMenuContext();
      if (!menu) {
        throw new Error(
          `useMenuContext: context is undefined. Seems you forgot to wrap component within <Menu>`
        );
      }
      const {
        focusedIndex,
        setFocusedIndex,
        menuRef,
        isOpen,
        onClose,
        menuId,
        isLazy,
        lazyBehavior,
        unstable__animationState: animated
      } = menu;
      const descendants = useMenuDescendantsContext();
      const createTypeaheadHandler = useShortcut({
        preventDefault: (event) => event.key !== " " && isTargetMenuItem(event.target)
      });
      const onKeyDown = (0, import_react2.useCallback)(
        (event) => {
          const eventKey = event.key;
          const keyMap = {
            Tab: (event2) => event2.preventDefault(),
            Escape: onClose,
            ArrowDown: () => {
              const next = descendants.nextEnabled(focusedIndex);
              if (next)
                setFocusedIndex(next.index);
            },
            ArrowUp: () => {
              const prev = descendants.prevEnabled(focusedIndex);
              if (prev)
                setFocusedIndex(prev.index);
            }
          };
          const fn = keyMap[eventKey];
          if (fn) {
            event.preventDefault();
            fn(event);
            return;
          }
          const onTypeahead = createTypeaheadHandler((character) => {
            const nextItem = getNextItemFromSearch(
              descendants.values(),
              character,
              (item) => {
                var _a, _b;
                return (_b = (_a = item == null ? void 0 : item.node) == null ? void 0 : _a.textContent) != null ? _b : "";
              },
              descendants.item(focusedIndex)
            );
            if (nextItem) {
              const index = descendants.indexOf(nextItem.node);
              setFocusedIndex(index);
            }
          });
          if (isTargetMenuItem(event.target)) {
            onTypeahead(event);
          }
        },
        [
          descendants,
          focusedIndex,
          createTypeaheadHandler,
          onClose,
          setFocusedIndex
        ]
      );
      const hasBeenOpened = (0, import_react2.useRef)(false);
      if (isOpen) {
        hasBeenOpened.current = true;
      }
      const shouldRenderChildren = (0, import_lazy_utils.lazyDisclosure)({
        wasSelected: hasBeenOpened.current,
        enabled: isLazy,
        mode: lazyBehavior,
        isSelected: animated.present
      });
      return {
        ...props,
        ref: (0, import_react_use_merge_refs.mergeRefs)(menuRef, ref),
        children: shouldRenderChildren ? props.children : null,
        tabIndex: -1,
        role: "menu",
        id: menuId,
        style: {
          ...props.style,
          transformOrigin: "var(--popper-transform-origin)"
        },
        "aria-orientation": "vertical",
        onKeyDown: (0, import_shared_utils.callAllHandlers)(props.onKeyDown, onKeyDown)
      };
    }
    function useMenuPositioner(props = {}) {
      const { popper, isOpen } = useMenuContext();
      return popper.getPopperProps({
        ...props,
        style: {
          visibility: isOpen ? "visible" : "hidden",
          ...props.style
        }
      });
    }
    function useMenuItem(props = {}, externalRef = null) {
      const {
        onMouseEnter: onMouseEnterProp,
        onMouseMove: onMouseMoveProp,
        onMouseLeave: onMouseLeaveProp,
        onClick: onClickProp,
        onFocus: onFocusProp,
        isDisabled,
        isFocusable,
        closeOnSelect,
        type: typeProp,
        ...htmlProps
      } = props;
      const menu = useMenuContext();
      const {
        setFocusedIndex,
        focusedIndex,
        closeOnSelect: menuCloseOnSelect,
        onClose,
        menuRef,
        isOpen,
        menuId,
        rafId
      } = menu;
      const ref = (0, import_react2.useRef)(null);
      const id = `${menuId}-menuitem-${(0, import_react2.useId)()}`;
      const { index, register } = useMenuDescendant({
        disabled: isDisabled && !isFocusable
      });
      const onMouseEnter = (0, import_react2.useCallback)(
        (event) => {
          onMouseEnterProp == null ? void 0 : onMouseEnterProp(event);
          if (isDisabled)
            return;
          setFocusedIndex(index);
        },
        [setFocusedIndex, index, isDisabled, onMouseEnterProp]
      );
      const onMouseMove = (0, import_react2.useCallback)(
        (event) => {
          onMouseMoveProp == null ? void 0 : onMouseMoveProp(event);
          if (ref.current && !isActiveElement(ref.current)) {
            onMouseEnter(event);
          }
        },
        [onMouseEnter, onMouseMoveProp]
      );
      const onMouseLeave = (0, import_react2.useCallback)(
        (event) => {
          onMouseLeaveProp == null ? void 0 : onMouseLeaveProp(event);
          if (isDisabled)
            return;
          setFocusedIndex(-1);
        },
        [setFocusedIndex, isDisabled, onMouseLeaveProp]
      );
      const onClick = (0, import_react2.useCallback)(
        (event) => {
          onClickProp == null ? void 0 : onClickProp(event);
          if (!isTargetMenuItem(event.currentTarget))
            return;
          if (closeOnSelect != null ? closeOnSelect : menuCloseOnSelect) {
            onClose();
          }
        },
        [onClose, onClickProp, menuCloseOnSelect, closeOnSelect]
      );
      const onFocus = (0, import_react2.useCallback)(
        (event) => {
          onFocusProp == null ? void 0 : onFocusProp(event);
          setFocusedIndex(index);
        },
        [setFocusedIndex, onFocusProp, index]
      );
      const isFocused = index === focusedIndex;
      const trulyDisabled = isDisabled && !isFocusable;
      (0, import_react_use_update_effect.useUpdateEffect)(() => {
        if (!isOpen)
          return;
        if (isFocused && !trulyDisabled && ref.current) {
          if (rafId.current) {
            cancelAnimationFrame(rafId.current);
          }
          rafId.current = requestAnimationFrame(() => {
            var _a;
            (_a = ref.current) == null ? void 0 : _a.focus();
            rafId.current = null;
          });
        } else if (menuRef.current && !isActiveElement(menuRef.current)) {
          menuRef.current.focus({ preventScroll: true });
        }
      }, [isFocused, trulyDisabled, menuRef, isOpen]);
      const clickableProps = (0, import_clickable.useClickable)({
        onClick,
        onFocus,
        onMouseEnter,
        onMouseMove,
        onMouseLeave,
        ref: (0, import_react_use_merge_refs.mergeRefs)(register, ref, externalRef),
        isDisabled,
        isFocusable
      });
      return {
        ...htmlProps,
        ...clickableProps,
        type: typeProp != null ? typeProp : clickableProps.type,
        id,
        role: "menuitem",
        tabIndex: isFocused ? 0 : -1
      };
    }
    function useMenuOption(props = {}, ref = null) {
      const { type = "radio", isChecked, ...rest } = props;
      const ownProps = useMenuItem(rest, ref);
      return {
        ...ownProps,
        role: `menuitem${type}`,
        "aria-checked": isChecked
      };
    }
    function useMenuOptionGroup(props = {}) {
      const {
        children,
        type = "radio",
        value: valueProp,
        defaultValue,
        onChange: onChangeProp,
        ...htmlProps
      } = props;
      const isRadio = type === "radio";
      const fallback = isRadio ? "" : [];
      const [value, setValue] = (0, import_react_use_controllable_state.useControllableState)({
        defaultValue: defaultValue != null ? defaultValue : fallback,
        value: valueProp,
        onChange: onChangeProp
      });
      const onChange = (0, import_react2.useCallback)(
        (selectedValue) => {
          if (type === "radio" && typeof value === "string") {
            setValue(selectedValue);
          }
          if (type === "checkbox" && Array.isArray(value)) {
            const nextValue = value.includes(selectedValue) ? value.filter((item) => item !== selectedValue) : value.concat(selectedValue);
            setValue(nextValue);
          }
        },
        [value, setValue, type]
      );
      const validChildren = (0, import_react_children_utils.getValidChildren)(children);
      const clones = validChildren.map((child) => {
        if (child.type.id !== "MenuItemOption")
          return child;
        const onClick = (event) => {
          var _a, _b;
          onChange(child.props.value);
          (_b = (_a = child.props).onClick) == null ? void 0 : _b.call(_a, event);
        };
        const isChecked = type === "radio" ? child.props.value === value : value.includes(child.props.value);
        return (0, import_react2.cloneElement)(child, {
          type,
          onClick,
          isChecked
        });
      });
      return {
        ...htmlProps,
        children: clones
      };
    }
    function useMenuState() {
      const { isOpen, onClose } = useMenuContext();
      return { isOpen, onClose };
    }
    function isHTMLElement(el) {
      var _a;
      if (!isElement(el))
        return false;
      const win = (_a = el.ownerDocument.defaultView) != null ? _a : window;
      return el instanceof win.HTMLElement;
    }
    function isElement(el) {
      return el != null && typeof el == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
    }
    function useUnmountEffect(fn, deps = []) {
      return (0, import_react2.useEffect)(
        () => () => fn(),
        deps
      );
    }
    var import_jsx_runtime = require_jsx_runtime();
    var [MenuStylesProvider, useMenuStyles] = (0, import_react_context2.createContext)({
      name: `MenuStylesContext`,
      errorMessage: `useMenuStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Menu />" `
    });
    var Menu = (props) => {
      const { children } = props;
      const styles = (0, import_system.useMultiStyleConfig)("Menu", props);
      const ownProps = (0, import_system.omitThemingProps)(props);
      const { direction } = (0, import_system.useTheme)();
      const { descendants, ...ctx } = useMenu({ ...ownProps, direction });
      const context = (0, import_react3.useMemo)(() => ctx, [ctx]);
      const { isOpen, onClose, forceUpdate } = context;
      return (0, import_jsx_runtime.jsx)(MenuDescendantsProvider, { value: descendants, children: (0, import_jsx_runtime.jsx)(MenuProvider, { value: context, children: (0, import_jsx_runtime.jsx)(MenuStylesProvider, { value: styles, children: (0, import_shared_utils2.runIfFn)(children, { isOpen, onClose, forceUpdate }) }) }) });
    };
    Menu.displayName = "Menu";
    var import_system2 = require_dist12();
    var import_shared_utils3 = require_dist3();
    var import_jsx_runtime2 = require_jsx_runtime();
    var StyledMenuButton = (0, import_system2.forwardRef)((props, ref) => {
      const styles = useMenuStyles();
      return (0, import_jsx_runtime2.jsx)(
        import_system2.chakra.button,
        {
          ref,
          ...props,
          __css: {
            display: "inline-flex",
            appearance: "none",
            alignItems: "center",
            outline: 0,
            ...styles.button
          }
        }
      );
    });
    var MenuButton = (0, import_system2.forwardRef)(
      (props, ref) => {
        const { children, as: As, ...rest } = props;
        const buttonProps = useMenuButton(rest, ref);
        const Element2 = As || StyledMenuButton;
        return (0, import_jsx_runtime2.jsx)(
          Element2,
          {
            ...buttonProps,
            className: (0, import_shared_utils3.cx)("chakra-menu__menu-button", props.className),
            children: (0, import_jsx_runtime2.jsx)(
              import_system2.chakra.span,
              {
                __css: { pointerEvents: "none", flex: "1 1 auto", minW: 0 },
                children: props.children
              }
            )
          }
        );
      }
    );
    MenuButton.displayName = "MenuButton";
    var import_system3 = require_dist12();
    var import_jsx_runtime3 = require_jsx_runtime();
    var MenuCommand = (0, import_system3.forwardRef)(
      (props, ref) => {
        const styles = useMenuStyles();
        return (0, import_jsx_runtime3.jsx)(
          import_system3.chakra.span,
          {
            ref,
            ...props,
            __css: styles.command,
            className: "chakra-menu__command"
          }
        );
      }
    );
    MenuCommand.displayName = "MenuCommand";
    var import_system4 = require_dist12();
    var import_shared_utils4 = require_dist3();
    var import_jsx_runtime4 = require_jsx_runtime();
    var MenuDivider = (props) => {
      const { className, ...rest } = props;
      const styles = useMenuStyles();
      return (0, import_jsx_runtime4.jsx)(
        import_system4.chakra.hr,
        {
          "aria-orientation": "horizontal",
          className: (0, import_shared_utils4.cx)("chakra-menu__divider", className),
          ...rest,
          __css: styles.divider
        }
      );
    };
    MenuDivider.displayName = "MenuDivider";
    var import_system5 = require_dist12();
    var import_shared_utils5 = require_dist3();
    var import_jsx_runtime5 = require_jsx_runtime();
    var MenuGroup = (0, import_system5.forwardRef)((props, ref) => {
      const { title, children, className, ...rest } = props;
      const _className = (0, import_shared_utils5.cx)("chakra-menu__group__title", className);
      const styles = useMenuStyles();
      return (0, import_jsx_runtime5.jsxs)("div", { ref, className: "chakra-menu__group", role: "group", children: [
        title && (0, import_jsx_runtime5.jsx)(import_system5.chakra.p, { className: _className, ...rest, __css: styles.groupTitle, children: title }),
        children
      ] });
    });
    MenuGroup.displayName = "MenuGroup";
    var import_system6 = require_dist12();
    var import_shared_utils6 = require_dist3();
    var import_react4 = require_react();
    var import_jsx_runtime6 = require_jsx_runtime();
    var MenuIcon = (props) => {
      const { className, children, ...rest } = props;
      const child = import_react4.Children.only(children);
      const clone = (0, import_react4.isValidElement)(child) ? (0, import_react4.cloneElement)(child, {
        focusable: "false",
        "aria-hidden": true,
        className: (0, import_shared_utils6.cx)("chakra-menu__icon", child.props.className)
      }) : null;
      const _className = (0, import_shared_utils6.cx)("chakra-menu__icon-wrapper", className);
      return (0, import_jsx_runtime6.jsx)(
        import_system6.chakra.span,
        {
          className: _className,
          ...rest,
          __css: {
            display: "inline-flex",
            alignItems: "center",
            justifyContent: "center",
            flexShrink: 0
          },
          children: clone
        }
      );
    };
    MenuIcon.displayName = "MenuIcon";
    var import_system8 = require_dist12();
    var import_shared_utils7 = require_dist3();
    var import_system7 = require_dist12();
    var import_react5 = require_react();
    var import_jsx_runtime7 = require_jsx_runtime();
    var StyledMenuItem = (0, import_system7.forwardRef)(
      (props, ref) => {
        const { type, ...rest } = props;
        const styles = useMenuStyles();
        const btnType = rest.as || type ? type != null ? type : void 0 : "button";
        const buttonStyles = (0, import_react5.useMemo)(
          () => ({
            textDecoration: "none",
            color: "inherit",
            userSelect: "none",
            display: "flex",
            width: "100%",
            alignItems: "center",
            textAlign: "start",
            flex: "0 0 auto",
            outline: 0,
            ...styles.item
          }),
          [styles.item]
        );
        return (0, import_jsx_runtime7.jsx)(import_system7.chakra.button, { ref, type: btnType, ...rest, __css: buttonStyles });
      }
    );
    var import_jsx_runtime8 = require_jsx_runtime();
    var MenuItem = (0, import_system8.forwardRef)((props, ref) => {
      const {
        icon,
        iconSpacing = "0.75rem",
        command,
        commandSpacing = "0.75rem",
        children,
        ...rest
      } = props;
      const menuitemProps = useMenuItem(rest, ref);
      const shouldWrap = icon || command;
      const _children = shouldWrap ? (0, import_jsx_runtime8.jsx)("span", { style: { pointerEvents: "none", flex: 1 }, children }) : children;
      return (0, import_jsx_runtime8.jsxs)(
        StyledMenuItem,
        {
          ...menuitemProps,
          className: (0, import_shared_utils7.cx)("chakra-menu__menuitem", menuitemProps.className),
          children: [
            icon && (0, import_jsx_runtime8.jsx)(MenuIcon, { fontSize: "0.8em", marginEnd: iconSpacing, children: icon }),
            _children,
            command && (0, import_jsx_runtime8.jsx)(MenuCommand, { marginStart: commandSpacing, children: command })
          ]
        }
      );
    });
    MenuItem.displayName = "MenuItem";
    var import_system9 = require_dist12();
    var import_shared_utils8 = require_dist3();
    var import_jsx_runtime9 = require_jsx_runtime();
    var CheckIcon = (props) => (0, import_jsx_runtime9.jsx)("svg", { viewBox: "0 0 14 14", width: "1em", height: "1em", ...props, children: (0, import_jsx_runtime9.jsx)(
      "polygon",
      {
        fill: "currentColor",
        points: "5.5 11.9993304 14 3.49933039 12.5 2 5.5 8.99933039 1.5 4.9968652 0 6.49933039"
      }
    ) });
    var MenuItemOption = (0, import_system9.forwardRef)(
      (props, ref) => {
        const { icon, iconSpacing = "0.75rem", ...rest } = props;
        const optionProps = useMenuOption(rest, ref);
        return (0, import_jsx_runtime9.jsxs)(
          StyledMenuItem,
          {
            ...optionProps,
            className: (0, import_shared_utils8.cx)("chakra-menu__menuitem-option", rest.className),
            children: [
              icon !== null && (0, import_jsx_runtime9.jsx)(
                MenuIcon,
                {
                  fontSize: "0.8em",
                  marginEnd: iconSpacing,
                  opacity: props.isChecked ? 1 : 0,
                  children: icon || (0, import_jsx_runtime9.jsx)(CheckIcon, {})
                }
              ),
              (0, import_jsx_runtime9.jsx)("span", { style: { flex: 1 }, children: optionProps.children })
            ]
          }
        );
      }
    );
    MenuItemOption.id = "MenuItemOption";
    MenuItemOption.displayName = "MenuItemOption";
    var import_shared_utils9 = require_dist3();
    var import_system10 = require_dist12();
    var import_framer_motion = require_cjs();
    var import_jsx_runtime10 = require_jsx_runtime();
    var motionVariants = {
      enter: {
        visibility: "visible",
        opacity: 1,
        scale: 1,
        transition: {
          duration: 0.2,
          ease: [0.4, 0, 0.2, 1]
        }
      },
      exit: {
        transitionEnd: {
          visibility: "hidden"
        },
        opacity: 0,
        scale: 0.8,
        transition: {
          duration: 0.1,
          easings: "easeOut"
        }
      }
    };
    var MenuTransition = (0, import_system10.chakra)(import_framer_motion.motion.div);
    var MenuList = (0, import_system10.forwardRef)(function MenuList2(props, ref) {
      var _a, _b;
      const { rootProps, motionProps, ...rest } = props;
      const {
        isOpen,
        onTransitionEnd,
        unstable__animationState: animated
      } = useMenuContext();
      const listProps = useMenuList(rest, ref);
      const positionerProps = useMenuPositioner(rootProps);
      const styles = useMenuStyles();
      return (0, import_jsx_runtime10.jsx)(
        import_system10.chakra.div,
        {
          ...positionerProps,
          __css: { zIndex: (_b = props.zIndex) != null ? _b : (_a = styles.list) == null ? void 0 : _a.zIndex },
          children: (0, import_jsx_runtime10.jsx)(
            MenuTransition,
            {
              variants: motionVariants,
              initial: false,
              animate: isOpen ? "enter" : "exit",
              __css: { outline: 0, ...styles.list },
              ...motionProps,
              className: (0, import_shared_utils9.cx)("chakra-menu__menu-list", listProps.className),
              ...listProps,
              onUpdate: onTransitionEnd,
              onAnimationComplete: (0, import_shared_utils9.callAll)(
                animated.onComplete,
                listProps.onAnimationComplete
              )
            }
          )
        }
      );
    });
    MenuList.displayName = "MenuList";
    var import_shared_utils10 = require_dist3();
    var import_jsx_runtime11 = require_jsx_runtime();
    var MenuOptionGroup = (props) => {
      const { className, title, ...rest } = props;
      const ownProps = useMenuOptionGroup(rest);
      return (0, import_jsx_runtime11.jsx)(
        MenuGroup,
        {
          title,
          className: (0, import_shared_utils10.cx)("chakra-menu__option-group", className),
          ...ownProps
        }
      );
    };
    MenuOptionGroup.displayName = "MenuOptionGroup";
  }
});

// ../../node_modules/@chakra-ui/portal/dist/index.js
var require_dist58 = __commonJS({
  "../../node_modules/@chakra-ui/portal/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Portal: () => Portal,
      PortalManager: () => PortalManager,
      usePortalManager: () => usePortalManager
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react_context = require_dist13();
    var import_jsx_runtime = require_jsx_runtime();
    var [PortalManagerContextProvider, usePortalManager] = (0, import_react_context.createContext)({
      strict: false,
      name: "PortalManagerContext"
    });
    function PortalManager(props) {
      const { children, zIndex } = props;
      return (0, import_jsx_runtime.jsx)(PortalManagerContextProvider, { value: { zIndex }, children });
    }
    PortalManager.displayName = "PortalManager";
    var import_react_use_safe_layout_effect = require_dist();
    var import_react_context2 = require_dist13();
    var import_react_dom = require_react_dom();
    var import_react = require_react();
    var import_jsx_runtime2 = require_jsx_runtime();
    var [PortalContextProvider, usePortalContext] = (0, import_react_context2.createContext)({
      strict: false,
      name: "PortalContext"
    });
    var PORTAL_CLASSNAME = "chakra-portal";
    var PORTAL_SELECTOR = `.chakra-portal`;
    var Container = (props) => (0, import_jsx_runtime2.jsx)(
      "div",
      {
        className: "chakra-portal-zIndex",
        style: {
          position: "absolute",
          zIndex: props.zIndex,
          top: 0,
          left: 0,
          right: 0
        },
        children: props.children
      }
    );
    var DefaultPortal = (props) => {
      const { appendToParentPortal, children } = props;
      const [tempNode, setTempNode] = (0, import_react.useState)(null);
      const portal = (0, import_react.useRef)(null);
      const [, forceUpdate] = (0, import_react.useState)({});
      (0, import_react.useEffect)(() => forceUpdate({}), []);
      const parentPortal = usePortalContext();
      const manager = usePortalManager();
      (0, import_react_use_safe_layout_effect.useSafeLayoutEffect)(() => {
        if (!tempNode)
          return;
        const doc = tempNode.ownerDocument;
        const host = appendToParentPortal ? parentPortal != null ? parentPortal : doc.body : doc.body;
        if (!host)
          return;
        portal.current = doc.createElement("div");
        portal.current.className = PORTAL_CLASSNAME;
        host.appendChild(portal.current);
        forceUpdate({});
        const portalNode = portal.current;
        return () => {
          if (host.contains(portalNode)) {
            host.removeChild(portalNode);
          }
        };
      }, [tempNode]);
      const _children = (manager == null ? void 0 : manager.zIndex) ? (0, import_jsx_runtime2.jsx)(Container, { zIndex: manager == null ? void 0 : manager.zIndex, children }) : children;
      return portal.current ? (0, import_react_dom.createPortal)(
        (0, import_jsx_runtime2.jsx)(PortalContextProvider, { value: portal.current, children: _children }),
        portal.current
      ) : (0, import_jsx_runtime2.jsx)(
        "span",
        {
          ref: (el) => {
            if (el)
              setTempNode(el);
          }
        }
      );
    };
    var ContainerPortal = (props) => {
      const { children, containerRef, appendToParentPortal } = props;
      const containerEl = containerRef.current;
      const host = containerEl != null ? containerEl : typeof window !== "undefined" ? document.body : void 0;
      const portal = (0, import_react.useMemo)(() => {
        const node = containerEl == null ? void 0 : containerEl.ownerDocument.createElement("div");
        if (node)
          node.className = PORTAL_CLASSNAME;
        return node;
      }, [containerEl]);
      const [, forceUpdate] = (0, import_react.useState)({});
      (0, import_react_use_safe_layout_effect.useSafeLayoutEffect)(() => forceUpdate({}), []);
      (0, import_react_use_safe_layout_effect.useSafeLayoutEffect)(() => {
        if (!portal || !host)
          return;
        host.appendChild(portal);
        return () => {
          host.removeChild(portal);
        };
      }, [portal, host]);
      if (host && portal) {
        return (0, import_react_dom.createPortal)(
          (0, import_jsx_runtime2.jsx)(PortalContextProvider, { value: appendToParentPortal ? portal : null, children }),
          portal
        );
      }
      return null;
    };
    function Portal(props) {
      const portalProps = {
        appendToParentPortal: true,
        ...props
      };
      const { containerRef, ...rest } = portalProps;
      return containerRef ? (0, import_jsx_runtime2.jsx)(ContainerPortal, { containerRef, ...rest }) : (0, import_jsx_runtime2.jsx)(DefaultPortal, { ...rest });
    }
    Portal.className = PORTAL_CLASSNAME;
    Portal.selector = PORTAL_SELECTOR;
    Portal.displayName = "Portal";
  }
});

// ../../node_modules/@chakra-ui/modal/dist/index.js
var require_dist59 = __commonJS({
  "../../node_modules/@chakra-ui/modal/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var __publicField = (obj, key, value) => {
      __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    var src_exports = {};
    __export(src_exports, {
      AlertDialog: () => AlertDialog,
      AlertDialogBody: () => ModalBody,
      AlertDialogCloseButton: () => ModalCloseButton,
      AlertDialogContent: () => AlertDialogContent,
      AlertDialogFooter: () => ModalFooter,
      AlertDialogHeader: () => ModalHeader,
      AlertDialogOverlay: () => ModalOverlay,
      Drawer: () => Drawer,
      DrawerBody: () => ModalBody,
      DrawerCloseButton: () => ModalCloseButton,
      DrawerContent: () => DrawerContent,
      DrawerFooter: () => ModalFooter,
      DrawerHeader: () => ModalHeader,
      DrawerOverlay: () => ModalOverlay,
      Modal: () => Modal,
      ModalBody: () => ModalBody,
      ModalCloseButton: () => ModalCloseButton,
      ModalContent: () => ModalContent,
      ModalContextProvider: () => ModalContextProvider,
      ModalFocusScope: () => ModalFocusScope,
      ModalFooter: () => ModalFooter,
      ModalHeader: () => ModalHeader,
      ModalOverlay: () => ModalOverlay,
      useDrawerContext: () => useDrawerContext,
      useModal: () => useModal,
      useModalContext: () => useModalContext,
      useModalStyles: () => useModalStyles
    });
    module.exports = __toCommonJS2(src_exports);
    var import_system9 = require_dist12();
    var import_portal = require_dist58();
    var import_react_context = require_dist13();
    var import_system = require_dist12();
    var import_framer_motion = require_cjs();
    var import_shared_utils = require_dist3();
    var import_react_use_merge_refs = require_dist14();
    var import_aria_hidden = (init_es20152(), __toCommonJS(es2015_exports2));
    var import_react2 = require_react();
    var import_react = require_react();
    var ModalManager = class {
      constructor() {
        __publicField(this, "modals");
        this.modals = /* @__PURE__ */ new Map();
      }
      add(modal) {
        this.modals.set(modal, this.modals.size + 1);
        return this.modals.size;
      }
      remove(modal) {
        this.modals.delete(modal);
      }
      isTopModal(modal) {
        if (!modal)
          return false;
        return this.modals.get(modal) === this.modals.size;
      }
    };
    var manager = new ModalManager();
    function useModalManager(ref, isOpen) {
      const [index, setIndex] = (0, import_react.useState)(0);
      (0, import_react.useEffect)(() => {
        const node = ref.current;
        if (!node)
          return;
        if (isOpen) {
          const index2 = manager.add(node);
          setIndex(index2);
        }
        return () => {
          manager.remove(node);
          setIndex(0);
        };
      }, [isOpen, ref]);
      return index;
    }
    function useModal(props) {
      const {
        isOpen,
        onClose,
        id,
        closeOnOverlayClick = true,
        closeOnEsc = true,
        useInert = true,
        onOverlayClick: onOverlayClickProp,
        onEsc
      } = props;
      const dialogRef = (0, import_react2.useRef)(null);
      const overlayRef = (0, import_react2.useRef)(null);
      const [dialogId, headerId, bodyId] = useIds(
        id,
        `chakra-modal`,
        `chakra-modal--header`,
        `chakra-modal--body`
      );
      useAriaHidden(dialogRef, isOpen && useInert);
      useModalManager(dialogRef, isOpen);
      const mouseDownTarget = (0, import_react2.useRef)(null);
      const onMouseDown = (0, import_react2.useCallback)((event) => {
        mouseDownTarget.current = event.target;
      }, []);
      const onKeyDown = (0, import_react2.useCallback)(
        (event) => {
          if (event.key === "Escape") {
            event.stopPropagation();
            if (closeOnEsc) {
              onClose == null ? void 0 : onClose();
            }
            onEsc == null ? void 0 : onEsc();
          }
        },
        [closeOnEsc, onClose, onEsc]
      );
      const [headerMounted, setHeaderMounted] = (0, import_react2.useState)(false);
      const [bodyMounted, setBodyMounted] = (0, import_react2.useState)(false);
      const getDialogProps = (0, import_react2.useCallback)(
        (props2 = {}, ref = null) => ({
          role: "dialog",
          ...props2,
          ref: (0, import_react_use_merge_refs.mergeRefs)(ref, dialogRef),
          id: dialogId,
          tabIndex: -1,
          "aria-modal": true,
          "aria-labelledby": headerMounted ? headerId : void 0,
          "aria-describedby": bodyMounted ? bodyId : void 0,
          onClick: (0, import_shared_utils.callAllHandlers)(
            props2.onClick,
            (event) => event.stopPropagation()
          )
        }),
        [bodyId, bodyMounted, dialogId, headerId, headerMounted]
      );
      const onOverlayClick = (0, import_react2.useCallback)(
        (event) => {
          event.stopPropagation();
          if (mouseDownTarget.current !== event.target)
            return;
          if (!manager.isTopModal(dialogRef.current))
            return;
          if (closeOnOverlayClick) {
            onClose == null ? void 0 : onClose();
          }
          onOverlayClickProp == null ? void 0 : onOverlayClickProp();
        },
        [onClose, closeOnOverlayClick, onOverlayClickProp]
      );
      const getDialogContainerProps = (0, import_react2.useCallback)(
        (props2 = {}, ref = null) => ({
          ...props2,
          ref: (0, import_react_use_merge_refs.mergeRefs)(ref, overlayRef),
          onClick: (0, import_shared_utils.callAllHandlers)(props2.onClick, onOverlayClick),
          onKeyDown: (0, import_shared_utils.callAllHandlers)(props2.onKeyDown, onKeyDown),
          onMouseDown: (0, import_shared_utils.callAllHandlers)(props2.onMouseDown, onMouseDown)
        }),
        [onKeyDown, onMouseDown, onOverlayClick]
      );
      return {
        isOpen,
        onClose,
        headerId,
        bodyId,
        setBodyMounted,
        setHeaderMounted,
        dialogRef,
        overlayRef,
        getDialogProps,
        getDialogContainerProps
      };
    }
    function useAriaHidden(ref, shouldHide) {
      const currentElement = ref.current;
      (0, import_react2.useEffect)(() => {
        if (!ref.current || !shouldHide)
          return void 0;
        return (0, import_aria_hidden.hideOthers)(ref.current);
      }, [shouldHide, ref, currentElement]);
    }
    function useIds(idProp, ...prefixes) {
      const reactId = (0, import_react2.useId)();
      const id = idProp || reactId;
      return (0, import_react2.useMemo)(() => {
        return prefixes.map((prefix) => `${prefix}-${id}`);
      }, [id, prefixes]);
    }
    var import_jsx_runtime = require_jsx_runtime();
    var [ModalStylesProvider, useModalStyles] = (0, import_react_context.createContext)({
      name: `ModalStylesContext`,
      errorMessage: `useModalStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Modal />" `
    });
    var [ModalContextProvider, useModalContext] = (0, import_react_context.createContext)({
      strict: true,
      name: "ModalContext",
      errorMessage: "useModalContext: `context` is undefined. Seems you forgot to wrap modal components in `<Modal />`"
    });
    var Modal = (props) => {
      const modalProps = {
        scrollBehavior: "outside",
        autoFocus: true,
        trapFocus: true,
        returnFocusOnClose: true,
        blockScrollOnMount: true,
        allowPinchZoom: false,
        motionPreset: "scale",
        lockFocusAcrossFrames: true,
        ...props
      };
      const {
        portalProps,
        children,
        autoFocus,
        trapFocus,
        initialFocusRef,
        finalFocusRef,
        returnFocusOnClose,
        blockScrollOnMount,
        allowPinchZoom,
        preserveScrollBarGap,
        motionPreset,
        lockFocusAcrossFrames,
        onCloseComplete
      } = modalProps;
      const styles = (0, import_system.useMultiStyleConfig)("Modal", modalProps);
      const modal = useModal(modalProps);
      const context = {
        ...modal,
        autoFocus,
        trapFocus,
        initialFocusRef,
        finalFocusRef,
        returnFocusOnClose,
        blockScrollOnMount,
        allowPinchZoom,
        preserveScrollBarGap,
        motionPreset,
        lockFocusAcrossFrames
      };
      return (0, import_jsx_runtime.jsx)(ModalContextProvider, { value: context, children: (0, import_jsx_runtime.jsx)(ModalStylesProvider, { value: styles, children: (0, import_jsx_runtime.jsx)(import_framer_motion.AnimatePresence, { onExitComplete: onCloseComplete, children: context.isOpen && (0, import_jsx_runtime.jsx)(import_portal.Portal, { ...portalProps, children }) }) }) });
    };
    Modal.displayName = "Modal";
    var import_shared_utils2 = require_dist3();
    var import_system3 = require_dist12();
    var import_focus_lock = require_dist43();
    var import_framer_motion2 = require_cjs();
    var import_react3 = require_react();
    var import_react_remove_scroll = (init_es20153(), __toCommonJS(es2015_exports3));
    var import_jsx_runtime2 = require_jsx_runtime();
    function ModalFocusScope(props) {
      const {
        autoFocus,
        trapFocus,
        dialogRef,
        initialFocusRef,
        blockScrollOnMount,
        allowPinchZoom,
        finalFocusRef,
        returnFocusOnClose,
        preserveScrollBarGap,
        lockFocusAcrossFrames,
        isOpen
      } = useModalContext();
      const [isPresent, safeToRemove] = (0, import_framer_motion2.usePresence)();
      (0, import_react3.useEffect)(() => {
        if (!isPresent && safeToRemove) {
          setTimeout(safeToRemove);
        }
      }, [isPresent, safeToRemove]);
      const index = useModalManager(dialogRef, isOpen);
      return (0, import_jsx_runtime2.jsx)(
        import_focus_lock.FocusLock,
        {
          autoFocus,
          isDisabled: !trapFocus,
          initialFocusRef,
          finalFocusRef,
          restoreFocus: returnFocusOnClose,
          contentRef: dialogRef,
          lockFocusAcrossFrames,
          children: (0, import_jsx_runtime2.jsx)(
            import_react_remove_scroll.RemoveScroll,
            {
              removeScrollBar: !preserveScrollBarGap,
              allowPinchZoom,
              enabled: index === 1 && blockScrollOnMount,
              forwardProps: true,
              children: props.children
            }
          )
        }
      );
    }
    var import_system2 = require_dist12();
    var import_transition = require_dist19();
    var import_framer_motion3 = require_cjs();
    var import_react4 = require_react();
    var import_jsx_runtime3 = require_jsx_runtime();
    var transitions = {
      slideInBottom: {
        ...import_transition.slideFadeConfig,
        custom: { offsetY: 16, reverse: true }
      },
      slideInRight: {
        ...import_transition.slideFadeConfig,
        custom: { offsetX: 16, reverse: true }
      },
      scale: {
        ...import_transition.scaleFadeConfig,
        custom: { initialScale: 0.95, reverse: true }
      },
      none: {}
    };
    var MotionSection = (0, import_system2.chakra)(import_framer_motion3.motion.section);
    var getMotionProps = (preset) => {
      return transitions[preset || "none"];
    };
    var ModalTransition = (0, import_react4.forwardRef)(
      (props, ref) => {
        const { preset, motionProps = getMotionProps(preset), ...rest } = props;
        return (0, import_jsx_runtime3.jsx)(MotionSection, { ref, ...motionProps, ...rest });
      }
    );
    ModalTransition.displayName = "ModalTransition";
    var import_jsx_runtime4 = require_jsx_runtime();
    var ModalContent = (0, import_system3.forwardRef)(
      (props, ref) => {
        const {
          className,
          children,
          containerProps: rootProps,
          motionProps,
          ...rest
        } = props;
        const { getDialogProps, getDialogContainerProps } = useModalContext();
        const dialogProps = getDialogProps(rest, ref);
        const containerProps = getDialogContainerProps(rootProps);
        const _className = (0, import_shared_utils2.cx)("chakra-modal__content", className);
        const styles = useModalStyles();
        const dialogStyles = {
          display: "flex",
          flexDirection: "column",
          position: "relative",
          width: "100%",
          outline: 0,
          ...styles.dialog
        };
        const dialogContainerStyles = {
          display: "flex",
          width: "100vw",
          height: "$100vh",
          position: "fixed",
          left: 0,
          top: 0,
          ...styles.dialogContainer
        };
        const { motionPreset } = useModalContext();
        return (0, import_jsx_runtime4.jsx)(ModalFocusScope, { children: (0, import_jsx_runtime4.jsx)(
          import_system3.chakra.div,
          {
            ...containerProps,
            className: "chakra-modal__content-container",
            tabIndex: -1,
            __css: dialogContainerStyles,
            children: (0, import_jsx_runtime4.jsx)(
              ModalTransition,
              {
                preset: motionPreset,
                motionProps,
                className: _className,
                ...dialogProps,
                __css: dialogStyles,
                children
              }
            )
          }
        ) });
      }
    );
    ModalContent.displayName = "ModalContent";
    var import_shared_utils3 = require_dist3();
    var import_system4 = require_dist12();
    var import_react5 = require_react();
    var import_jsx_runtime5 = require_jsx_runtime();
    var ModalBody = (0, import_system4.forwardRef)((props, ref) => {
      const { className, ...rest } = props;
      const { bodyId, setBodyMounted } = useModalContext();
      (0, import_react5.useEffect)(() => {
        setBodyMounted(true);
        return () => setBodyMounted(false);
      }, [setBodyMounted]);
      const _className = (0, import_shared_utils3.cx)("chakra-modal__body", className);
      const styles = useModalStyles();
      return (0, import_jsx_runtime5.jsx)(
        import_system4.chakra.div,
        {
          ref,
          className: _className,
          id: bodyId,
          ...rest,
          __css: styles.body
        }
      );
    });
    ModalBody.displayName = "ModalBody";
    var import_close_button = require_dist34();
    var import_shared_utils4 = require_dist3();
    var import_system5 = require_dist12();
    var import_jsx_runtime6 = require_jsx_runtime();
    var ModalCloseButton = (0, import_system5.forwardRef)(
      (props, ref) => {
        const { onClick, className, ...rest } = props;
        const { onClose } = useModalContext();
        const _className = (0, import_shared_utils4.cx)("chakra-modal__close-btn", className);
        const styles = useModalStyles();
        return (0, import_jsx_runtime6.jsx)(
          import_close_button.CloseButton,
          {
            ref,
            __css: styles.closeButton,
            className: _className,
            onClick: (0, import_shared_utils4.callAllHandlers)(onClick, (event) => {
              event.stopPropagation();
              onClose();
            }),
            ...rest
          }
        );
      }
    );
    ModalCloseButton.displayName = "ModalCloseButton";
    var import_shared_utils5 = require_dist3();
    var import_system6 = require_dist12();
    var import_jsx_runtime7 = require_jsx_runtime();
    var ModalFooter = (0, import_system6.forwardRef)(
      (props, ref) => {
        const { className, ...rest } = props;
        const _className = (0, import_shared_utils5.cx)("chakra-modal__footer", className);
        const styles = useModalStyles();
        const footerStyles = {
          display: "flex",
          alignItems: "center",
          justifyContent: "flex-end",
          ...styles.footer
        };
        return (0, import_jsx_runtime7.jsx)(
          import_system6.chakra.footer,
          {
            ref,
            ...rest,
            __css: footerStyles,
            className: _className
          }
        );
      }
    );
    ModalFooter.displayName = "ModalFooter";
    var import_shared_utils6 = require_dist3();
    var import_system7 = require_dist12();
    var import_react6 = require_react();
    var import_jsx_runtime8 = require_jsx_runtime();
    var ModalHeader = (0, import_system7.forwardRef)(
      (props, ref) => {
        const { className, ...rest } = props;
        const { headerId, setHeaderMounted } = useModalContext();
        (0, import_react6.useEffect)(() => {
          setHeaderMounted(true);
          return () => setHeaderMounted(false);
        }, [setHeaderMounted]);
        const _className = (0, import_shared_utils6.cx)("chakra-modal__header", className);
        const styles = useModalStyles();
        const headerStyles = {
          flex: 0,
          ...styles.header
        };
        return (0, import_jsx_runtime8.jsx)(
          import_system7.chakra.header,
          {
            ref,
            className: _className,
            id: headerId,
            ...rest,
            __css: headerStyles
          }
        );
      }
    );
    ModalHeader.displayName = "ModalHeader";
    var import_shared_utils7 = require_dist3();
    var import_system8 = require_dist12();
    var import_transition2 = require_dist19();
    var import_framer_motion4 = require_cjs();
    var import_jsx_runtime9 = require_jsx_runtime();
    var MotionDiv = (0, import_system8.chakra)(import_framer_motion4.motion.div);
    var ModalOverlay = (0, import_system8.forwardRef)(
      (props, ref) => {
        const { className, transition, motionProps: _motionProps, ...rest } = props;
        const _className = (0, import_shared_utils7.cx)("chakra-modal__overlay", className);
        const styles = useModalStyles();
        const overlayStyle = {
          pos: "fixed",
          left: "0",
          top: "0",
          w: "100vw",
          h: "100vh",
          ...styles.overlay
        };
        const { motionPreset } = useModalContext();
        const defaultMotionProps = motionPreset === "none" ? {} : import_transition2.fadeConfig;
        const motionProps = _motionProps || defaultMotionProps;
        return (0, import_jsx_runtime9.jsx)(
          MotionDiv,
          {
            ...motionProps,
            __css: overlayStyle,
            ref,
            className: _className,
            ...rest
          }
        );
      }
    );
    ModalOverlay.displayName = "ModalOverlay";
    var import_jsx_runtime10 = require_jsx_runtime();
    function AlertDialog(props) {
      const { leastDestructiveRef, ...rest } = props;
      return (0, import_jsx_runtime10.jsx)(Modal, { ...rest, initialFocusRef: leastDestructiveRef });
    }
    var AlertDialogContent = (0, import_system9.forwardRef)(
      (props, ref) => (0, import_jsx_runtime10.jsx)(ModalContent, { ref, role: "alertdialog", ...props })
    );
    var import_react_context2 = require_dist13();
    var import_system10 = require_dist12();
    var import_jsx_runtime11 = require_jsx_runtime();
    var [DrawerContextProvider, useDrawerContext] = (0, import_react_context2.createContext)();
    var placementMap = {
      start: { ltr: "left", rtl: "right" },
      end: { ltr: "right", rtl: "left" }
    };
    function getDrawerPlacement(placement, dir) {
      var _a, _b;
      if (!placement)
        return;
      return (_b = (_a = placementMap[placement]) == null ? void 0 : _a[dir]) != null ? _b : placement;
    }
    function Drawer(props) {
      var _a;
      const {
        isOpen,
        onClose,
        placement: placementProp = "right",
        children,
        ...rest
      } = props;
      const theme = (0, import_system10.useTheme)();
      const drawerStyleConfig = (_a = theme.components) == null ? void 0 : _a.Drawer;
      const placement = getDrawerPlacement(placementProp, theme.direction);
      return (0, import_jsx_runtime11.jsx)(DrawerContextProvider, { value: { placement }, children: (0, import_jsx_runtime11.jsx)(
        Modal,
        {
          isOpen,
          onClose,
          styleConfig: drawerStyleConfig,
          ...rest,
          children
        }
      ) });
    }
    var import_shared_utils8 = require_dist3();
    var import_system11 = require_dist12();
    var import_transition3 = require_dist19();
    var import_jsx_runtime12 = require_jsx_runtime();
    var MotionDiv2 = (0, import_system11.chakra)(import_transition3.Slide);
    var DrawerContent = (0, import_system11.forwardRef)(
      (props, ref) => {
        const {
          className,
          children,
          motionProps,
          containerProps: rootProps,
          ...rest
        } = props;
        const { getDialogProps, getDialogContainerProps, isOpen } = useModalContext();
        const dialogProps = getDialogProps(rest, ref);
        const containerProps = getDialogContainerProps(rootProps);
        const _className = (0, import_shared_utils8.cx)("chakra-modal__content", className);
        const styles = useModalStyles();
        const dialogStyles = {
          display: "flex",
          flexDirection: "column",
          position: "relative",
          width: "100%",
          outline: 0,
          ...styles.dialog
        };
        const dialogContainerStyles = {
          display: "flex",
          width: "100vw",
          height: "$100vh",
          position: "fixed",
          left: 0,
          top: 0,
          ...styles.dialogContainer
        };
        const { placement } = useDrawerContext();
        return (0, import_jsx_runtime12.jsx)(ModalFocusScope, { children: (0, import_jsx_runtime12.jsx)(
          import_system11.chakra.div,
          {
            ...containerProps,
            className: "chakra-modal__content-container",
            __css: dialogContainerStyles,
            children: (0, import_jsx_runtime12.jsx)(
              MotionDiv2,
              {
                motionProps,
                direction: placement,
                in: isOpen,
                className: _className,
                ...dialogProps,
                __css: dialogStyles,
                children
              }
            )
          }
        ) });
      }
    );
    DrawerContent.displayName = "DrawerContent";
  }
});

// ../../node_modules/@chakra-ui/react-use-interval/dist/index.js
var require_dist60 = __commonJS({
  "../../node_modules/@chakra-ui/react-use-interval/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      useInterval: () => useInterval
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react = require_react();
    var import_react_use_callback_ref = require_dist16();
    function useInterval(callback, delay) {
      const fn = (0, import_react_use_callback_ref.useCallbackRef)(callback);
      (0, import_react.useEffect)(() => {
        let intervalId = null;
        const tick = () => fn();
        if (delay !== null) {
          intervalId = window.setInterval(tick, delay);
        }
        return () => {
          if (intervalId) {
            window.clearInterval(intervalId);
          }
        };
      }, [delay, fn]);
    }
  }
});

// ../../node_modules/@chakra-ui/number-input/dist/index.js
var require_dist61 = __commonJS({
  "../../node_modules/@chakra-ui/number-input/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      NumberDecrementStepper: () => NumberDecrementStepper,
      NumberIncrementStepper: () => NumberIncrementStepper,
      NumberInput: () => NumberInput,
      NumberInputField: () => NumberInputField,
      NumberInputStepper: () => NumberInputStepper,
      useNumberInput: () => useNumberInput,
      useNumberInputStyles: () => useNumberInputStyles
    });
    module.exports = __toCommonJS2(src_exports);
    var import_form_control = require_dist29();
    var import_react_context = require_dist13();
    var import_system = require_dist12();
    var import_shared_utils2 = require_dist3();
    var import_react4 = require_react();
    var import_icon = require_dist18();
    var import_jsx_runtime = require_jsx_runtime();
    var TriangleDownIcon = (props) => (0, import_jsx_runtime.jsx)(import_icon.Icon, { viewBox: "0 0 24 24", ...props, children: (0, import_jsx_runtime.jsx)(
      "path",
      {
        fill: "currentColor",
        d: "M21,5H3C2.621,5,2.275,5.214,2.105,5.553C1.937,5.892,1.973,6.297,2.2,6.6l9,12 c0.188,0.252,0.485,0.4,0.8,0.4s0.611-0.148,0.8-0.4l9-12c0.228-0.303,0.264-0.708,0.095-1.047C21.725,5.214,21.379,5,21,5z"
      }
    ) });
    var TriangleUpIcon = (props) => (0, import_jsx_runtime.jsx)(import_icon.Icon, { viewBox: "0 0 24 24", ...props, children: (0, import_jsx_runtime.jsx)(
      "path",
      {
        fill: "currentColor",
        d: "M12.8,5.4c-0.377-0.504-1.223-0.504-1.6,0l-9,12c-0.228,0.303-0.264,0.708-0.095,1.047 C2.275,18.786,2.621,19,3,19h18c0.379,0,0.725-0.214,0.895-0.553c0.169-0.339,0.133-0.744-0.095-1.047L12.8,5.4z"
      }
    ) });
    var import_counter = require_dist37();
    var import_react_use_event_listener = require_dist39();
    var import_react_use_update_effect = require_dist30();
    var import_react_use_safe_layout_effect = require_dist();
    var import_react_use_callback_ref = require_dist16();
    var import_react_use_merge_refs = require_dist14();
    var import_shared_utils = require_dist3();
    var import_react3 = require_react();
    var import_react = require_react();
    function useAttributeObserver(ref, attributes, fn, enabled) {
      (0, import_react.useEffect)(() => {
        var _a;
        if (!ref.current || !enabled)
          return;
        const win = (_a = ref.current.ownerDocument.defaultView) != null ? _a : window;
        const attrs = Array.isArray(attributes) ? attributes : [attributes];
        const obs = new win.MutationObserver((changes) => {
          for (const change of changes) {
            if (change.type === "attributes" && change.attributeName && attrs.includes(change.attributeName)) {
              fn(change);
            }
          }
        });
        obs.observe(ref.current, { attributes: true, attributeFilter: attrs });
        return () => obs.disconnect();
      });
    }
    var import_react_use_interval = require_dist60();
    var import_react2 = require_react();
    var CONTINUOUS_CHANGE_INTERVAL = 50;
    var CONTINUOUS_CHANGE_DELAY = 300;
    function useSpinner(increment, decrement) {
      const [isSpinning, setIsSpinning] = (0, import_react2.useState)(false);
      const [action, setAction] = (0, import_react2.useState)(null);
      const [runOnce, setRunOnce] = (0, import_react2.useState)(true);
      const timeoutRef = (0, import_react2.useRef)(null);
      const removeTimeout = () => clearTimeout(timeoutRef.current);
      (0, import_react_use_interval.useInterval)(
        () => {
          if (action === "increment") {
            increment();
          }
          if (action === "decrement") {
            decrement();
          }
        },
        isSpinning ? CONTINUOUS_CHANGE_INTERVAL : null
      );
      const up = (0, import_react2.useCallback)(() => {
        if (runOnce) {
          increment();
        }
        timeoutRef.current = setTimeout(() => {
          setRunOnce(false);
          setIsSpinning(true);
          setAction("increment");
        }, CONTINUOUS_CHANGE_DELAY);
      }, [increment, runOnce]);
      const down = (0, import_react2.useCallback)(() => {
        if (runOnce) {
          decrement();
        }
        timeoutRef.current = setTimeout(() => {
          setRunOnce(false);
          setIsSpinning(true);
          setAction("decrement");
        }, CONTINUOUS_CHANGE_DELAY);
      }, [decrement, runOnce]);
      const stop = (0, import_react2.useCallback)(() => {
        setRunOnce(true);
        setIsSpinning(false);
        removeTimeout();
      }, []);
      (0, import_react2.useEffect)(() => {
        return () => removeTimeout();
      }, []);
      return { up, down, stop, isSpinning };
    }
    var FLOATING_POINT_REGEX = /^[Ee0-9+\-.]$/;
    function isFloatingPointNumericCharacter(character) {
      return FLOATING_POINT_REGEX.test(character);
    }
    function isValidNumericKeyboardEvent(event, isValid) {
      if (event.key == null)
        return true;
      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
      const isSingleCharacterKey = event.key.length === 1;
      if (!isSingleCharacterKey || isModifierKey)
        return true;
      return isValid(event.key);
    }
    function useNumberInput(props = {}) {
      const {
        focusInputOnChange = true,
        clampValueOnBlur = true,
        keepWithinRange = true,
        min = Number.MIN_SAFE_INTEGER,
        max = Number.MAX_SAFE_INTEGER,
        step: stepProp = 1,
        isReadOnly,
        isDisabled,
        isRequired,
        isInvalid,
        pattern = "[0-9]*(.[0-9]+)?",
        inputMode = "decimal",
        allowMouseWheel,
        id,
        onChange: _,
        precision,
        name,
        "aria-describedby": ariaDescBy,
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        onFocus: onFocusProp,
        onBlur: onBlurProp,
        onInvalid: onInvalidProp,
        getAriaValueText: getAriaValueTextProp,
        isValidCharacter: isValidCharacterProp,
        format: formatValue,
        parse: parseValue,
        ...htmlProps
      } = props;
      const onFocus = (0, import_react_use_callback_ref.useCallbackRef)(onFocusProp);
      const onBlur = (0, import_react_use_callback_ref.useCallbackRef)(onBlurProp);
      const onInvalid = (0, import_react_use_callback_ref.useCallbackRef)(onInvalidProp);
      const isValidCharacter = (0, import_react_use_callback_ref.useCallbackRef)(
        isValidCharacterProp != null ? isValidCharacterProp : isFloatingPointNumericCharacter
      );
      const getAriaValueText = (0, import_react_use_callback_ref.useCallbackRef)(getAriaValueTextProp);
      const counter = (0, import_counter.useCounter)(props);
      const {
        update: updateFn,
        increment: incrementFn,
        decrement: decrementFn
      } = counter;
      const [isFocused, setFocused] = (0, import_react3.useState)(false);
      const isInteractive = !(isReadOnly || isDisabled);
      const inputRef = (0, import_react3.useRef)(null);
      const inputSelectionRef = (0, import_react3.useRef)(null);
      const incrementButtonRef = (0, import_react3.useRef)(null);
      const decrementButtonRef = (0, import_react3.useRef)(null);
      const sanitize = (0, import_react3.useCallback)(
        (value) => value.split("").filter(isValidCharacter).join(""),
        [isValidCharacter]
      );
      const parse = (0, import_react3.useCallback)(
        (value) => {
          var _a;
          return (_a = parseValue == null ? void 0 : parseValue(value)) != null ? _a : value;
        },
        [parseValue]
      );
      const format = (0, import_react3.useCallback)(
        (value) => {
          var _a;
          return ((_a = formatValue == null ? void 0 : formatValue(value)) != null ? _a : value).toString();
        },
        [formatValue]
      );
      (0, import_react_use_update_effect.useUpdateEffect)(() => {
        if (counter.valueAsNumber > max) {
          onInvalid == null ? void 0 : onInvalid("rangeOverflow", format(counter.value), counter.valueAsNumber);
        } else if (counter.valueAsNumber < min) {
          onInvalid == null ? void 0 : onInvalid("rangeOverflow", format(counter.value), counter.valueAsNumber);
        }
      }, [counter.valueAsNumber, counter.value, format, onInvalid]);
      (0, import_react_use_safe_layout_effect.useSafeLayoutEffect)(() => {
        if (!inputRef.current)
          return;
        const notInSync = inputRef.current.value != counter.value;
        if (notInSync) {
          const parsedInput = parse(inputRef.current.value);
          counter.setValue(sanitize(parsedInput));
        }
      }, [parse, sanitize]);
      const increment = (0, import_react3.useCallback)(
        (step = stepProp) => {
          if (isInteractive) {
            incrementFn(step);
          }
        },
        [incrementFn, isInteractive, stepProp]
      );
      const decrement = (0, import_react3.useCallback)(
        (step = stepProp) => {
          if (isInteractive) {
            decrementFn(step);
          }
        },
        [decrementFn, isInteractive, stepProp]
      );
      const spinner = useSpinner(increment, decrement);
      useAttributeObserver(
        incrementButtonRef,
        "disabled",
        spinner.stop,
        spinner.isSpinning
      );
      useAttributeObserver(
        decrementButtonRef,
        "disabled",
        spinner.stop,
        spinner.isSpinning
      );
      const onChange = (0, import_react3.useCallback)(
        (event) => {
          const evt = event.nativeEvent;
          if (evt.isComposing)
            return;
          const parsedInput = parse(event.currentTarget.value);
          updateFn(sanitize(parsedInput));
          inputSelectionRef.current = {
            start: event.currentTarget.selectionStart,
            end: event.currentTarget.selectionEnd
          };
        },
        [updateFn, sanitize, parse]
      );
      const _onFocus = (0, import_react3.useCallback)(
        (event) => {
          var _a, _b, _c;
          onFocus == null ? void 0 : onFocus(event);
          if (!inputSelectionRef.current)
            return;
          event.target.selectionStart = (_b = inputSelectionRef.current.start) != null ? _b : (_a = event.currentTarget.value) == null ? void 0 : _a.length;
          event.currentTarget.selectionEnd = (_c = inputSelectionRef.current.end) != null ? _c : event.currentTarget.selectionStart;
        },
        [onFocus]
      );
      const onKeyDown = (0, import_react3.useCallback)(
        (event) => {
          if (event.nativeEvent.isComposing)
            return;
          if (!isValidNumericKeyboardEvent(event, isValidCharacter)) {
            event.preventDefault();
          }
          const stepFactor = getStepFactor(event) * stepProp;
          const eventKey = event.key;
          const keyMap = {
            ArrowUp: () => increment(stepFactor),
            ArrowDown: () => decrement(stepFactor),
            Home: () => updateFn(min),
            End: () => updateFn(max)
          };
          const action = keyMap[eventKey];
          if (action) {
            event.preventDefault();
            action(event);
          }
        },
        [isValidCharacter, stepProp, increment, decrement, updateFn, min, max]
      );
      const getStepFactor = (event) => {
        let ratio = 1;
        if (event.metaKey || event.ctrlKey) {
          ratio = 0.1;
        }
        if (event.shiftKey) {
          ratio = 10;
        }
        return ratio;
      };
      const ariaValueText = (0, import_react3.useMemo)(() => {
        const text = getAriaValueText == null ? void 0 : getAriaValueText(counter.value);
        if (text != null)
          return text;
        const defaultText = counter.value.toString();
        return !defaultText ? void 0 : defaultText;
      }, [counter.value, getAriaValueText]);
      const validateAndClamp = (0, import_react3.useCallback)(() => {
        let next = counter.value;
        if (counter.value === "")
          return;
        const valueStartsWithE = /^[eE]/.test(counter.value.toString());
        if (valueStartsWithE) {
          counter.setValue("");
        } else {
          if (counter.valueAsNumber < min) {
            next = min;
          }
          if (counter.valueAsNumber > max) {
            next = max;
          }
          counter.cast(next);
        }
      }, [counter, max, min]);
      const onInputBlur = (0, import_react3.useCallback)(() => {
        setFocused(false);
        if (clampValueOnBlur) {
          validateAndClamp();
        }
      }, [clampValueOnBlur, setFocused, validateAndClamp]);
      const focusInput = (0, import_react3.useCallback)(() => {
        if (focusInputOnChange) {
          requestAnimationFrame(() => {
            var _a;
            (_a = inputRef.current) == null ? void 0 : _a.focus();
          });
        }
      }, [focusInputOnChange]);
      const spinUp = (0, import_react3.useCallback)(
        (event) => {
          event.preventDefault();
          spinner.up();
          focusInput();
        },
        [focusInput, spinner]
      );
      const spinDown = (0, import_react3.useCallback)(
        (event) => {
          event.preventDefault();
          spinner.down();
          focusInput();
        },
        [focusInput, spinner]
      );
      (0, import_react_use_event_listener.useEventListener)(
        () => inputRef.current,
        "wheel",
        (event) => {
          var _a, _b;
          const doc = (_b = (_a = inputRef.current) == null ? void 0 : _a.ownerDocument) != null ? _b : document;
          const isInputFocused = doc.activeElement === inputRef.current;
          if (!allowMouseWheel || !isInputFocused)
            return;
          event.preventDefault();
          const stepFactor = getStepFactor(event) * stepProp;
          const direction = Math.sign(event.deltaY);
          if (direction === -1) {
            increment(stepFactor);
          } else if (direction === 1) {
            decrement(stepFactor);
          }
        },
        { passive: false }
      );
      const getIncrementButtonProps = (0, import_react3.useCallback)(
        (props2 = {}, ref = null) => {
          const disabled = isDisabled || keepWithinRange && counter.isAtMax;
          return {
            ...props2,
            ref: (0, import_react_use_merge_refs.mergeRefs)(ref, incrementButtonRef),
            role: "button",
            tabIndex: -1,
            onPointerDown: (0, import_shared_utils.callAllHandlers)(props2.onPointerDown, (event) => {
              if (event.button !== 0 || disabled)
                return;
              spinUp(event);
            }),
            onPointerLeave: (0, import_shared_utils.callAllHandlers)(props2.onPointerLeave, spinner.stop),
            onPointerUp: (0, import_shared_utils.callAllHandlers)(props2.onPointerUp, spinner.stop),
            disabled,
            "aria-disabled": (0, import_shared_utils.ariaAttr)(disabled)
          };
        },
        [counter.isAtMax, keepWithinRange, spinUp, spinner.stop, isDisabled]
      );
      const getDecrementButtonProps = (0, import_react3.useCallback)(
        (props2 = {}, ref = null) => {
          const disabled = isDisabled || keepWithinRange && counter.isAtMin;
          return {
            ...props2,
            ref: (0, import_react_use_merge_refs.mergeRefs)(ref, decrementButtonRef),
            role: "button",
            tabIndex: -1,
            onPointerDown: (0, import_shared_utils.callAllHandlers)(props2.onPointerDown, (event) => {
              if (event.button !== 0 || disabled)
                return;
              spinDown(event);
            }),
            onPointerLeave: (0, import_shared_utils.callAllHandlers)(props2.onPointerLeave, spinner.stop),
            onPointerUp: (0, import_shared_utils.callAllHandlers)(props2.onPointerUp, spinner.stop),
            disabled,
            "aria-disabled": (0, import_shared_utils.ariaAttr)(disabled)
          };
        },
        [counter.isAtMin, keepWithinRange, spinDown, spinner.stop, isDisabled]
      );
      const getInputProps = (0, import_react3.useCallback)(
        (props2 = {}, ref = null) => {
          var _a, _b, _c, _d;
          return {
            name,
            inputMode,
            type: "text",
            pattern,
            "aria-labelledby": ariaLabelledBy,
            "aria-label": ariaLabel,
            "aria-describedby": ariaDescBy,
            id,
            disabled: isDisabled,
            ...props2,
            readOnly: (_a = props2.readOnly) != null ? _a : isReadOnly,
            "aria-readonly": (_b = props2.readOnly) != null ? _b : isReadOnly,
            "aria-required": (_c = props2.required) != null ? _c : isRequired,
            required: (_d = props2.required) != null ? _d : isRequired,
            ref: (0, import_react_use_merge_refs.mergeRefs)(inputRef, ref),
            value: format(counter.value),
            role: "spinbutton",
            "aria-valuemin": min,
            "aria-valuemax": max,
            "aria-valuenow": Number.isNaN(counter.valueAsNumber) ? void 0 : counter.valueAsNumber,
            "aria-invalid": (0, import_shared_utils.ariaAttr)(isInvalid != null ? isInvalid : counter.isOutOfRange),
            "aria-valuetext": ariaValueText,
            autoComplete: "off",
            autoCorrect: "off",
            onChange: (0, import_shared_utils.callAllHandlers)(props2.onChange, onChange),
            onKeyDown: (0, import_shared_utils.callAllHandlers)(props2.onKeyDown, onKeyDown),
            onFocus: (0, import_shared_utils.callAllHandlers)(
              props2.onFocus,
              _onFocus,
              () => setFocused(true)
            ),
            onBlur: (0, import_shared_utils.callAllHandlers)(props2.onBlur, onBlur, onInputBlur)
          };
        },
        [
          name,
          inputMode,
          pattern,
          ariaLabelledBy,
          ariaLabel,
          format,
          ariaDescBy,
          id,
          isDisabled,
          isRequired,
          isReadOnly,
          isInvalid,
          counter.value,
          counter.valueAsNumber,
          counter.isOutOfRange,
          min,
          max,
          ariaValueText,
          onChange,
          onKeyDown,
          _onFocus,
          onBlur,
          onInputBlur
        ]
      );
      return {
        value: format(counter.value),
        valueAsNumber: counter.valueAsNumber,
        isFocused,
        isDisabled,
        isReadOnly,
        getIncrementButtonProps,
        getDecrementButtonProps,
        getInputProps,
        htmlProps
      };
    }
    var import_jsx_runtime2 = require_jsx_runtime();
    var [NumberInputStylesProvider, useNumberInputStyles] = (0, import_react_context.createContext)({
      name: `NumberInputStylesContext`,
      errorMessage: `useNumberInputStyles returned is 'undefined'. Seems you forgot to wrap the components in "<NumberInput />" `
    });
    var [NumberInputProvider, useNumberInputContext] = (0, import_react_context.createContext)({
      name: "NumberInputContext",
      errorMessage: "useNumberInputContext: `context` is undefined. Seems you forgot to wrap number-input's components within <NumberInput />"
    });
    var NumberInput = (0, import_system.forwardRef)(
      function NumberInput2(props, ref) {
        const styles = (0, import_system.useMultiStyleConfig)("NumberInput", props);
        const ownProps = (0, import_system.omitThemingProps)(props);
        const controlProps = (0, import_form_control.useFormControlProps)(ownProps);
        const { htmlProps, ...context } = useNumberInput(controlProps);
        const ctx = (0, import_react4.useMemo)(() => context, [context]);
        return (0, import_jsx_runtime2.jsx)(NumberInputProvider, { value: ctx, children: (0, import_jsx_runtime2.jsx)(NumberInputStylesProvider, { value: styles, children: (0, import_jsx_runtime2.jsx)(
          import_system.chakra.div,
          {
            ...htmlProps,
            ref,
            className: (0, import_shared_utils2.cx)("chakra-numberinput", props.className),
            __css: {
              position: "relative",
              zIndex: 0,
              ...styles.root
            }
          }
        ) }) });
      }
    );
    NumberInput.displayName = "NumberInput";
    var NumberInputStepper = (0, import_system.forwardRef)(
      function NumberInputStepper2(props, ref) {
        const styles = useNumberInputStyles();
        return (0, import_jsx_runtime2.jsx)(
          import_system.chakra.div,
          {
            "aria-hidden": true,
            ref,
            ...props,
            __css: {
              display: "flex",
              flexDirection: "column",
              position: "absolute",
              top: "0",
              insetEnd: "0px",
              margin: "1px",
              height: "calc(100% - 2px)",
              zIndex: 1,
              ...styles.stepperGroup
            }
          }
        );
      }
    );
    NumberInputStepper.displayName = "NumberInputStepper";
    var NumberInputField = (0, import_system.forwardRef)(
      function NumberInputField2(props, ref) {
        const { getInputProps } = useNumberInputContext();
        const input = getInputProps(props, ref);
        const styles = useNumberInputStyles();
        return (0, import_jsx_runtime2.jsx)(
          import_system.chakra.input,
          {
            ...input,
            className: (0, import_shared_utils2.cx)("chakra-numberinput__field", props.className),
            __css: {
              width: "100%",
              ...styles.field
            }
          }
        );
      }
    );
    NumberInputField.displayName = "NumberInputField";
    var StyledStepper = (0, import_system.chakra)("div", {
      baseStyle: {
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        flex: 1,
        transitionProperty: "common",
        transitionDuration: "normal",
        userSelect: "none",
        cursor: "pointer",
        lineHeight: "normal"
      }
    });
    var NumberDecrementStepper = (0, import_system.forwardRef)(function NumberDecrementStepper2(props, ref) {
      var _a;
      const styles = useNumberInputStyles();
      const { getDecrementButtonProps } = useNumberInputContext();
      const decrement = getDecrementButtonProps(props, ref);
      return (0, import_jsx_runtime2.jsx)(StyledStepper, { ...decrement, __css: styles.stepper, children: (_a = props.children) != null ? _a : (0, import_jsx_runtime2.jsx)(TriangleDownIcon, {}) });
    });
    NumberDecrementStepper.displayName = "NumberDecrementStepper";
    var NumberIncrementStepper = (0, import_system.forwardRef)(function NumberIncrementStepper2(props, ref) {
      var _a;
      const { getIncrementButtonProps } = useNumberInputContext();
      const increment = getIncrementButtonProps(props, ref);
      const styles = useNumberInputStyles();
      return (0, import_jsx_runtime2.jsx)(StyledStepper, { ...increment, __css: styles.stepper, children: (_a = props.children) != null ? _a : (0, import_jsx_runtime2.jsx)(TriangleUpIcon, {}) });
    });
    NumberIncrementStepper.displayName = "NumberIncrementStepper";
  }
});

// ../../node_modules/@chakra-ui/pin-input/dist/index.js
var require_dist62 = __commonJS({
  "../../node_modules/@chakra-ui/pin-input/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      PinInput: () => PinInput,
      PinInputDescendantsProvider: () => PinInputDescendantsProvider,
      PinInputField: () => PinInputField,
      PinInputProvider: () => PinInputProvider,
      usePinInput: () => usePinInput,
      usePinInputContext: () => usePinInputContext,
      usePinInputField: () => usePinInputField
    });
    module.exports = __toCommonJS2(src_exports);
    var import_system = require_dist12();
    var import_shared_utils2 = require_dist3();
    var import_react_children_utils = require_dist24();
    var import_descendant = require_dist15();
    var import_react_use_controllable_state = require_dist17();
    var import_shared_utils = require_dist3();
    var import_react_context = require_dist13();
    var import_react_use_merge_refs = require_dist14();
    var import_react = require_react();
    var [
      PinInputDescendantsProvider,
      usePinInputDescendantsContext,
      usePinInputDescendants,
      usePinInputDescendant
    ] = (0, import_descendant.createDescendantContext)();
    var [PinInputProvider, usePinInputContext] = (0, import_react_context.createContext)({
      name: "PinInputContext",
      errorMessage: "usePinInputContext: `context` is undefined. Seems you forgot to all pin input fields within `<PinInput />`"
    });
    var toArray = (value) => value == null ? void 0 : value.split("");
    function validate(value, type) {
      const NUMERIC_REGEX = /^[0-9]+$/;
      const ALPHA_NUMERIC_REGEX = /^[a-zA-Z0-9]+$/i;
      const regex = type === "alphanumeric" ? ALPHA_NUMERIC_REGEX : NUMERIC_REGEX;
      return regex.test(value);
    }
    function usePinInput(props = {}) {
      const {
        autoFocus,
        value,
        defaultValue,
        onChange,
        onComplete,
        placeholder = "\u25CB",
        manageFocus = true,
        otp = false,
        id: idProp,
        isDisabled,
        isInvalid,
        type = "number",
        mask
      } = props;
      const uuid = (0, import_react.useId)();
      const id = idProp != null ? idProp : `pin-input-${uuid}`;
      const descendants = usePinInputDescendants();
      const [moveFocus, setMoveFocus] = (0, import_react.useState)(true);
      const [focusedIndex, setFocusedIndex] = (0, import_react.useState)(-1);
      const [values, setValues] = (0, import_react_use_controllable_state.useControllableState)({
        defaultValue: toArray(defaultValue) || [],
        value: toArray(value),
        onChange: (values2) => onChange == null ? void 0 : onChange(values2.join(""))
      });
      (0, import_react.useEffect)(() => {
        if (autoFocus) {
          const first = descendants.first();
          if (first) {
            requestAnimationFrame(() => {
              first.node.focus();
            });
          }
        }
      }, [descendants]);
      const focusNext = (0, import_react.useCallback)(
        (index) => {
          if (!moveFocus || !manageFocus)
            return;
          const next = descendants.next(index, false);
          if (next) {
            requestAnimationFrame(() => {
              next.node.focus();
            });
          }
        },
        [descendants, moveFocus, manageFocus]
      );
      const setValue = (0, import_react.useCallback)(
        (value2, index, handleFocus = true) => {
          const nextValues = [...values];
          nextValues[index] = value2;
          setValues(nextValues);
          const isComplete = value2 !== "" && nextValues.length === descendants.count() && nextValues.every(
            (inputValue) => inputValue != null && inputValue !== ""
          );
          if (isComplete) {
            onComplete == null ? void 0 : onComplete(nextValues.join(""));
          } else {
            if (handleFocus)
              focusNext(index);
          }
        },
        [values, setValues, focusNext, onComplete, descendants]
      );
      const clear = (0, import_react.useCallback)(() => {
        var _a;
        const values2 = Array(descendants.count()).fill("");
        setValues(values2);
        const first = descendants.first();
        (_a = first == null ? void 0 : first.node) == null ? void 0 : _a.focus();
      }, [descendants, setValues]);
      const getNextValue = (0, import_react.useCallback)((value2, eventValue) => {
        let nextValue = eventValue;
        if ((value2 == null ? void 0 : value2.length) > 0) {
          if (value2[0] === eventValue.charAt(0)) {
            nextValue = eventValue.charAt(1);
          } else if (value2[0] === eventValue.charAt(1)) {
            nextValue = eventValue.charAt(0);
          }
        }
        return nextValue;
      }, []);
      const getInputProps = (0, import_react.useCallback)(
        (props2) => {
          const { index, ...rest } = props2;
          const onChange2 = (event) => {
            const eventValue = event.target.value;
            const currentValue = values[index];
            const nextValue = getNextValue(currentValue, eventValue);
            if (nextValue === "") {
              setValue("", index);
              return;
            }
            if (eventValue.length > 2) {
              if (validate(eventValue, type)) {
                const nextValue2 = eventValue.split("").filter((_, index2) => index2 < descendants.count());
                setValues(nextValue2);
                if (nextValue2.length === descendants.count()) {
                  onComplete == null ? void 0 : onComplete(nextValue2.join(""));
                }
              }
            } else {
              if (validate(nextValue, type)) {
                setValue(nextValue, index);
              }
              setMoveFocus(true);
            }
          };
          const onKeyDown = (event) => {
            var _a;
            if (event.key === "Backspace" && manageFocus) {
              if (event.target.value === "") {
                const prevInput = descendants.prev(index, false);
                if (prevInput) {
                  setValue("", index - 1, false);
                  (_a = prevInput.node) == null ? void 0 : _a.focus();
                  setMoveFocus(true);
                }
              } else {
                setMoveFocus(false);
              }
            }
          };
          const onFocus = () => {
            setFocusedIndex(index);
          };
          const onBlur = () => {
            setFocusedIndex(-1);
          };
          const hasFocus = focusedIndex === index;
          const inputType = type === "number" ? "tel" : "text";
          return {
            "aria-label": "Please enter your pin code",
            inputMode: type === "number" ? "numeric" : "text",
            type: mask ? "password" : inputType,
            ...rest,
            id: `${id}-${index}`,
            disabled: isDisabled,
            "aria-invalid": (0, import_shared_utils.ariaAttr)(isInvalid),
            onChange: (0, import_shared_utils.callAllHandlers)(rest.onChange, onChange2),
            onKeyDown: (0, import_shared_utils.callAllHandlers)(rest.onKeyDown, onKeyDown),
            onFocus: (0, import_shared_utils.callAllHandlers)(rest.onFocus, onFocus),
            onBlur: (0, import_shared_utils.callAllHandlers)(rest.onBlur, onBlur),
            value: values[index] || "",
            autoComplete: otp ? "one-time-code" : "off",
            placeholder: hasFocus ? "" : placeholder
          };
        },
        [
          descendants,
          focusedIndex,
          getNextValue,
          id,
          isDisabled,
          mask,
          isInvalid,
          manageFocus,
          onComplete,
          otp,
          placeholder,
          setValue,
          setValues,
          type,
          values
        ]
      );
      return {
        getInputProps,
        id,
        descendants,
        values,
        setValue,
        setValues,
        clear
      };
    }
    function usePinInputField(props = {}, ref = null) {
      const { getInputProps } = usePinInputContext();
      const { index, register } = usePinInputDescendant();
      return getInputProps({
        ...props,
        ref: (0, import_react_use_merge_refs.mergeRefs)(register, ref),
        index
      });
    }
    var import_react2 = require_react();
    var import_jsx_runtime = require_jsx_runtime();
    function PinInput(props) {
      const styles = (0, import_system.useStyleConfig)("PinInput", props);
      const { children, ...rest } = (0, import_system.omitThemingProps)(props);
      const { descendants, ...context } = usePinInput(rest);
      const clones = (0, import_react_children_utils.getValidChildren)(children).map(
        (child) => (0, import_react2.cloneElement)(child, { __css: styles })
      );
      return (0, import_jsx_runtime.jsx)(PinInputDescendantsProvider, { value: descendants, children: (0, import_jsx_runtime.jsx)(PinInputProvider, { value: context, children: clones }) });
    }
    PinInput.displayName = "PinInput";
    var PinInputField = (0, import_system.forwardRef)(
      function PinInputField2(props, ref) {
        const inputProps = usePinInputField(props, ref);
        return (0, import_jsx_runtime.jsx)(
          import_system.chakra.input,
          {
            ...inputProps,
            className: (0, import_shared_utils2.cx)("chakra-pin-input", props.className)
          }
        );
      }
    );
    PinInputField.displayName = "PinInputField";
  }
});

// ../../node_modules/@chakra-ui/popover/dist/index.js
var require_dist63 = __commonJS({
  "../../node_modules/@chakra-ui/popover/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Popover: () => Popover,
      PopoverAnchor: () => PopoverAnchor,
      PopoverArrow: () => PopoverArrow,
      PopoverBody: () => PopoverBody,
      PopoverCloseButton: () => PopoverCloseButton,
      PopoverContent: () => PopoverContent,
      PopoverFooter: () => PopoverFooter,
      PopoverHeader: () => PopoverHeader,
      PopoverTrigger: () => PopoverTrigger,
      usePopover: () => usePopover,
      usePopoverContext: () => usePopoverContext,
      usePopoverStyles: () => usePopoverStyles
    });
    module.exports = __toCommonJS2(src_exports);
    var import_system = require_dist12();
    var import_shared_utils2 = require_dist3();
    var import_react_context = require_dist13();
    var [PopoverProvider, usePopoverContext] = (0, import_react_context.createContext)({
      name: "PopoverContext",
      errorMessage: "usePopoverContext: `context` is undefined. Seems you forgot to wrap all popover components within `<Popover />`"
    });
    var [PopoverStylesProvider, usePopoverStyles] = (0, import_react_context.createContext)({
      name: `PopoverStylesContext`,
      errorMessage: `usePopoverStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Popover />" `
    });
    var import_react_use_animation_state = require_dist55();
    var import_react_use_focus_on_pointer_down = require_dist40();
    var import_react_use_focus_effect = require_dist51();
    var import_react_use_disclosure = require_dist53();
    var import_popper = require_dist52();
    var import_react_use_merge_refs = require_dist14();
    var import_shared_utils = require_dist3();
    var import_lazy_utils = require_dist56();
    var import_react = require_react();
    var TRIGGER = {
      click: "click",
      hover: "hover"
    };
    function usePopover(props = {}) {
      const {
        closeOnBlur = true,
        closeOnEsc = true,
        initialFocusRef,
        id,
        returnFocusOnClose = true,
        autoFocus = true,
        arrowSize,
        arrowShadowColor,
        trigger = TRIGGER.click,
        openDelay = 200,
        closeDelay = 200,
        isLazy,
        lazyBehavior = "unmount",
        computePositionOnMount,
        ...popperProps
      } = props;
      const { isOpen, onClose, onOpen, onToggle } = (0, import_react_use_disclosure.useDisclosure)(props);
      const anchorRef = (0, import_react.useRef)(null);
      const triggerRef = (0, import_react.useRef)(null);
      const popoverRef = (0, import_react.useRef)(null);
      const isHoveringRef = (0, import_react.useRef)(false);
      const hasBeenOpened = (0, import_react.useRef)(false);
      if (isOpen) {
        hasBeenOpened.current = true;
      }
      const [hasHeader, setHasHeader] = (0, import_react.useState)(false);
      const [hasBody, setHasBody] = (0, import_react.useState)(false);
      const uuid = (0, import_react.useId)();
      const uid = id != null ? id : uuid;
      const [triggerId, popoverId, headerId, bodyId] = [
        "popover-trigger",
        "popover-content",
        "popover-header",
        "popover-body"
      ].map((id2) => `${id2}-${uid}`);
      const {
        referenceRef,
        getArrowProps,
        getPopperProps,
        getArrowInnerProps,
        forceUpdate
      } = (0, import_popper.usePopper)({
        ...popperProps,
        enabled: isOpen || !!computePositionOnMount
      });
      const animated = (0, import_react_use_animation_state.useAnimationState)({ isOpen, ref: popoverRef });
      (0, import_react_use_focus_on_pointer_down.useFocusOnPointerDown)({
        enabled: isOpen,
        ref: triggerRef
      });
      (0, import_react_use_focus_effect.useFocusOnHide)(popoverRef, {
        focusRef: triggerRef,
        visible: isOpen,
        shouldFocus: returnFocusOnClose && trigger === TRIGGER.click
      });
      (0, import_react_use_focus_effect.useFocusOnShow)(popoverRef, {
        focusRef: initialFocusRef,
        visible: isOpen,
        shouldFocus: autoFocus && trigger === TRIGGER.click
      });
      const shouldRenderChildren = (0, import_lazy_utils.lazyDisclosure)({
        wasSelected: hasBeenOpened.current,
        enabled: isLazy,
        mode: lazyBehavior,
        isSelected: animated.present
      });
      const getPopoverProps = (0, import_react.useCallback)(
        (props2 = {}, _ref = null) => {
          const popoverProps = {
            ...props2,
            style: {
              ...props2.style,
              transformOrigin: import_popper.popperCSSVars.transformOrigin.varRef,
              [import_popper.popperCSSVars.arrowSize.var]: arrowSize ? `${arrowSize}px` : void 0,
              [import_popper.popperCSSVars.arrowShadowColor.var]: arrowShadowColor
            },
            ref: (0, import_react_use_merge_refs.mergeRefs)(popoverRef, _ref),
            children: shouldRenderChildren ? props2.children : null,
            id: popoverId,
            tabIndex: -1,
            role: "dialog",
            onKeyDown: (0, import_shared_utils.callAllHandlers)(props2.onKeyDown, (event) => {
              if (closeOnEsc && event.key === "Escape") {
                onClose();
              }
            }),
            onBlur: (0, import_shared_utils.callAllHandlers)(props2.onBlur, (event) => {
              const relatedTarget = getRelatedTarget(event);
              const targetIsPopover = contains(popoverRef.current, relatedTarget);
              const targetIsTrigger = contains(triggerRef.current, relatedTarget);
              const isValidBlur = !targetIsPopover && !targetIsTrigger;
              if (isOpen && closeOnBlur && isValidBlur) {
                onClose();
              }
            }),
            "aria-labelledby": hasHeader ? headerId : void 0,
            "aria-describedby": hasBody ? bodyId : void 0
          };
          if (trigger === TRIGGER.hover) {
            popoverProps.role = "tooltip";
            popoverProps.onMouseEnter = (0, import_shared_utils.callAllHandlers)(props2.onMouseEnter, () => {
              isHoveringRef.current = true;
            });
            popoverProps.onMouseLeave = (0, import_shared_utils.callAllHandlers)(
              props2.onMouseLeave,
              (event) => {
                if (event.nativeEvent.relatedTarget === null) {
                  return;
                }
                isHoveringRef.current = false;
                setTimeout(() => onClose(), closeDelay);
              }
            );
          }
          return popoverProps;
        },
        [
          shouldRenderChildren,
          popoverId,
          hasHeader,
          headerId,
          hasBody,
          bodyId,
          trigger,
          closeOnEsc,
          onClose,
          isOpen,
          closeOnBlur,
          closeDelay,
          arrowShadowColor,
          arrowSize
        ]
      );
      const getPopoverPositionerProps = (0, import_react.useCallback)(
        (props2 = {}, forwardedRef = null) => getPopperProps(
          {
            ...props2,
            style: {
              visibility: isOpen ? "visible" : "hidden",
              ...props2.style
            }
          },
          forwardedRef
        ),
        [isOpen, getPopperProps]
      );
      const getAnchorProps = (0, import_react.useCallback)(
        (props2, _ref = null) => {
          return {
            ...props2,
            ref: (0, import_react_use_merge_refs.mergeRefs)(_ref, anchorRef, referenceRef)
          };
        },
        [anchorRef, referenceRef]
      );
      const openTimeout = (0, import_react.useRef)();
      const closeTimeout = (0, import_react.useRef)();
      const maybeReferenceRef = (0, import_react.useCallback)(
        (node) => {
          if (anchorRef.current == null) {
            referenceRef(node);
          }
        },
        [referenceRef]
      );
      const getTriggerProps = (0, import_react.useCallback)(
        (props2 = {}, _ref = null) => {
          const triggerProps = {
            ...props2,
            ref: (0, import_react_use_merge_refs.mergeRefs)(triggerRef, _ref, maybeReferenceRef),
            id: triggerId,
            "aria-haspopup": "dialog",
            "aria-expanded": isOpen,
            "aria-controls": popoverId
          };
          if (trigger === TRIGGER.click) {
            triggerProps.onClick = (0, import_shared_utils.callAllHandlers)(props2.onClick, onToggle);
          }
          if (trigger === TRIGGER.hover) {
            triggerProps.onFocus = (0, import_shared_utils.callAllHandlers)(props2.onFocus, () => {
              if (openTimeout.current === void 0) {
                onOpen();
              }
            });
            triggerProps.onBlur = (0, import_shared_utils.callAllHandlers)(props2.onBlur, (event) => {
              const relatedTarget = getRelatedTarget(event);
              const isValidBlur = !contains(popoverRef.current, relatedTarget);
              if (isOpen && closeOnBlur && isValidBlur) {
                onClose();
              }
            });
            triggerProps.onKeyDown = (0, import_shared_utils.callAllHandlers)(props2.onKeyDown, (event) => {
              if (event.key === "Escape") {
                onClose();
              }
            });
            triggerProps.onMouseEnter = (0, import_shared_utils.callAllHandlers)(props2.onMouseEnter, () => {
              isHoveringRef.current = true;
              openTimeout.current = window.setTimeout(() => onOpen(), openDelay);
            });
            triggerProps.onMouseLeave = (0, import_shared_utils.callAllHandlers)(props2.onMouseLeave, () => {
              isHoveringRef.current = false;
              if (openTimeout.current) {
                clearTimeout(openTimeout.current);
                openTimeout.current = void 0;
              }
              closeTimeout.current = window.setTimeout(() => {
                if (isHoveringRef.current === false) {
                  onClose();
                }
              }, closeDelay);
            });
          }
          return triggerProps;
        },
        [
          triggerId,
          isOpen,
          popoverId,
          trigger,
          maybeReferenceRef,
          onToggle,
          onOpen,
          closeOnBlur,
          onClose,
          openDelay,
          closeDelay
        ]
      );
      (0, import_react.useEffect)(() => {
        return () => {
          if (openTimeout.current) {
            clearTimeout(openTimeout.current);
          }
          if (closeTimeout.current) {
            clearTimeout(closeTimeout.current);
          }
        };
      }, []);
      const getHeaderProps = (0, import_react.useCallback)(
        (props2 = {}, ref = null) => ({
          ...props2,
          id: headerId,
          ref: (0, import_react_use_merge_refs.mergeRefs)(ref, (node) => {
            setHasHeader(!!node);
          })
        }),
        [headerId]
      );
      const getBodyProps = (0, import_react.useCallback)(
        (props2 = {}, ref = null) => ({
          ...props2,
          id: bodyId,
          ref: (0, import_react_use_merge_refs.mergeRefs)(ref, (node) => {
            setHasBody(!!node);
          })
        }),
        [bodyId]
      );
      return {
        forceUpdate,
        isOpen,
        onAnimationComplete: animated.onComplete,
        onClose,
        getAnchorProps,
        getArrowProps,
        getArrowInnerProps,
        getPopoverPositionerProps,
        getPopoverProps,
        getTriggerProps,
        getHeaderProps,
        getBodyProps
      };
    }
    function contains(parent, child) {
      return parent === child || (parent == null ? void 0 : parent.contains(child));
    }
    function getRelatedTarget(event) {
      var _a;
      const activeEl = event.currentTarget.ownerDocument.activeElement;
      return (_a = event.relatedTarget) != null ? _a : activeEl;
    }
    var import_jsx_runtime = require_jsx_runtime();
    function Popover(props) {
      const styles = (0, import_system.useMultiStyleConfig)("Popover", props);
      const { children, ...rest } = (0, import_system.omitThemingProps)(props);
      const theme = (0, import_system.useTheme)();
      const context = usePopover({ ...rest, direction: theme.direction });
      return (0, import_jsx_runtime.jsx)(PopoverProvider, { value: context, children: (0, import_jsx_runtime.jsx)(PopoverStylesProvider, { value: styles, children: (0, import_shared_utils2.runIfFn)(children, {
        isOpen: context.isOpen,
        onClose: context.onClose,
        forceUpdate: context.forceUpdate
      }) }) });
    }
    Popover.displayName = "Popover";
    var import_react2 = require_react();
    function PopoverAnchor(props) {
      const child = import_react2.Children.only(props.children);
      const { getAnchorProps } = usePopoverContext();
      return (0, import_react2.cloneElement)(child, getAnchorProps(child.props, child.ref));
    }
    PopoverAnchor.displayName = "PopoverAnchor";
    var import_system2 = require_dist12();
    var import_shared_utils3 = require_dist3();
    var import_jsx_runtime2 = require_jsx_runtime();
    var resolveVar = (scale, value) => value ? `${scale}.${value}, ${value}` : void 0;
    function PopoverArrow(props) {
      var _a;
      const { bg, bgColor, backgroundColor, shadow, boxShadow, shadowColor } = props;
      const { getArrowProps, getArrowInnerProps } = usePopoverContext();
      const styles = usePopoverStyles();
      const arrowBg = (_a = bg != null ? bg : bgColor) != null ? _a : backgroundColor;
      const arrowShadow = shadow != null ? shadow : boxShadow;
      return (0, import_jsx_runtime2.jsx)(
        import_system2.chakra.div,
        {
          ...getArrowProps(),
          className: "chakra-popover__arrow-positioner",
          children: (0, import_jsx_runtime2.jsx)(
            import_system2.chakra.div,
            {
              className: (0, import_shared_utils3.cx)("chakra-popover__arrow", props.className),
              ...getArrowInnerProps(props),
              __css: {
                "--popper-arrow-shadow-color": resolveVar("colors", shadowColor),
                "--popper-arrow-bg": resolveVar("colors", arrowBg),
                "--popper-arrow-shadow": resolveVar("shadows", arrowShadow),
                ...styles.arrow
              }
            }
          )
        }
      );
    }
    PopoverArrow.displayName = "PopoverArrow";
    var import_system3 = require_dist12();
    var import_shared_utils4 = require_dist3();
    var import_jsx_runtime3 = require_jsx_runtime();
    var PopoverBody = (0, import_system3.forwardRef)(
      function PopoverBody2(props, ref) {
        const { getBodyProps } = usePopoverContext();
        const styles = usePopoverStyles();
        return (0, import_jsx_runtime3.jsx)(
          import_system3.chakra.div,
          {
            ...getBodyProps(props, ref),
            className: (0, import_shared_utils4.cx)("chakra-popover__body", props.className),
            __css: styles.body
          }
        );
      }
    );
    PopoverBody.displayName = "PopoverBody";
    var import_close_button = require_dist34();
    var import_system4 = require_dist12();
    var import_shared_utils5 = require_dist3();
    var import_jsx_runtime4 = require_jsx_runtime();
    var PopoverCloseButton = (0, import_system4.forwardRef)(
      function PopoverCloseButton2(props, ref) {
        const { onClose } = usePopoverContext();
        const styles = usePopoverStyles();
        return (0, import_jsx_runtime4.jsx)(
          import_close_button.CloseButton,
          {
            size: "sm",
            onClick: onClose,
            className: (0, import_shared_utils5.cx)("chakra-popover__close-btn", props.className),
            __css: styles.closeButton,
            ref,
            ...props
          }
        );
      }
    );
    PopoverCloseButton.displayName = "PopoverCloseButton";
    var import_shared_utils6 = require_dist3();
    var import_system6 = require_dist12();
    var import_system5 = require_dist12();
    var import_framer_motion = require_cjs();
    var import_jsx_runtime5 = require_jsx_runtime();
    function mergeVariants(variants) {
      if (!variants)
        return;
      return {
        enter: {
          ...variants.enter,
          visibility: "visible"
        },
        exit: {
          ...variants.exit,
          transitionEnd: {
            visibility: "hidden"
          }
        }
      };
    }
    var scaleFade = {
      exit: {
        opacity: 0,
        scale: 0.95,
        transition: {
          duration: 0.1,
          ease: [0.4, 0, 1, 1]
        }
      },
      enter: {
        scale: 1,
        opacity: 1,
        transition: {
          duration: 0.15,
          ease: [0, 0, 0.2, 1]
        }
      }
    };
    var MotionSection = (0, import_system5.chakra)(import_framer_motion.motion.section);
    var PopoverTransition = (0, import_system5.forwardRef)(function PopoverTransition2(props, ref) {
      const { variants = scaleFade, ...rest } = props;
      const { isOpen } = usePopoverContext();
      return (0, import_jsx_runtime5.jsx)(
        MotionSection,
        {
          ref,
          variants: mergeVariants(variants),
          initial: false,
          animate: isOpen ? "enter" : "exit",
          ...rest
        }
      );
    });
    PopoverTransition.displayName = "PopoverTransition";
    var import_jsx_runtime6 = require_jsx_runtime();
    var PopoverContent = (0, import_system6.forwardRef)(
      function PopoverContent2(props, ref) {
        const { rootProps, motionProps, ...contentProps } = props;
        const { getPopoverProps, getPopoverPositionerProps, onAnimationComplete } = usePopoverContext();
        const styles = usePopoverStyles();
        const contentStyles = {
          position: "relative",
          display: "flex",
          flexDirection: "column",
          ...styles.content
        };
        return (0, import_jsx_runtime6.jsx)(
          import_system6.chakra.div,
          {
            ...getPopoverPositionerProps(rootProps),
            __css: styles.popper,
            className: "chakra-popover__popper",
            children: (0, import_jsx_runtime6.jsx)(
              PopoverTransition,
              {
                ...motionProps,
                ...getPopoverProps(contentProps, ref),
                onAnimationComplete: (0, import_shared_utils6.callAll)(
                  onAnimationComplete,
                  contentProps.onAnimationComplete
                ),
                className: (0, import_shared_utils6.cx)("chakra-popover__content", props.className),
                __css: contentStyles
              }
            )
          }
        );
      }
    );
    PopoverContent.displayName = "PopoverContent";
    var import_system7 = require_dist12();
    var import_shared_utils7 = require_dist3();
    var import_jsx_runtime7 = require_jsx_runtime();
    function PopoverFooter(props) {
      const styles = usePopoverStyles();
      return (0, import_jsx_runtime7.jsx)(
        import_system7.chakra.footer,
        {
          ...props,
          className: (0, import_shared_utils7.cx)("chakra-popover__footer", props.className),
          __css: styles.footer
        }
      );
    }
    PopoverFooter.displayName = "PopoverFooter";
    var import_system8 = require_dist12();
    var import_shared_utils8 = require_dist3();
    var import_jsx_runtime8 = require_jsx_runtime();
    var PopoverHeader = (0, import_system8.forwardRef)(
      function PopoverHeader2(props, ref) {
        const { getHeaderProps } = usePopoverContext();
        const styles = usePopoverStyles();
        return (0, import_jsx_runtime8.jsx)(
          import_system8.chakra.header,
          {
            ...getHeaderProps(props, ref),
            className: (0, import_shared_utils8.cx)("chakra-popover__header", props.className),
            __css: styles.header
          }
        );
      }
    );
    PopoverHeader.displayName = "PopoverHeader";
    var import_react3 = require_react();
    function PopoverTrigger(props) {
      const child = import_react3.Children.only(props.children);
      const { getTriggerProps } = usePopoverContext();
      return (0, import_react3.cloneElement)(child, getTriggerProps(child.props, child.ref));
    }
    PopoverTrigger.displayName = "PopoverTrigger";
  }
});

// ../../node_modules/@chakra-ui/progress/dist/index.js
var require_dist64 = __commonJS({
  "../../node_modules/@chakra-ui/progress/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      CircularProgress: () => CircularProgress,
      CircularProgressLabel: () => CircularProgressLabel,
      Progress: () => Progress,
      ProgressLabel: () => ProgressLabel,
      useProgressStyles: () => useProgressStyles
    });
    module.exports = __toCommonJS2(src_exports);
    var import_system4 = require_dist12();
    var import_system = require_dist12();
    function valueToPercent(value, min, max) {
      return (value - min) * 100 / (max - min);
    }
    var spin = (0, import_system.keyframes)({
      "0%": {
        strokeDasharray: "1, 400",
        strokeDashoffset: "0"
      },
      "50%": {
        strokeDasharray: "400, 400",
        strokeDashoffset: "-100"
      },
      "100%": {
        strokeDasharray: "400, 400",
        strokeDashoffset: "-260"
      }
    });
    var rotate = (0, import_system.keyframes)({
      "0%": {
        transform: "rotate(0deg)"
      },
      "100%": {
        transform: "rotate(360deg)"
      }
    });
    var progress = (0, import_system.keyframes)({
      "0%": { left: "-40%" },
      "100%": { left: "100%" }
    });
    var stripe = (0, import_system.keyframes)({
      from: { backgroundPosition: "1rem 0" },
      to: { backgroundPosition: "0 0" }
    });
    function getProgressProps(options) {
      const {
        value = 0,
        min,
        max,
        valueText,
        getValueText,
        isIndeterminate,
        role = "progressbar"
      } = options;
      const percent = valueToPercent(value, min, max);
      const getAriaValueText = () => {
        if (value == null)
          return void 0;
        return typeof getValueText === "function" ? getValueText(value, percent) : valueText;
      };
      return {
        bind: {
          "data-indeterminate": isIndeterminate ? "" : void 0,
          "aria-valuemax": max,
          "aria-valuemin": min,
          "aria-valuenow": isIndeterminate ? void 0 : value,
          "aria-valuetext": getAriaValueText(),
          role
        },
        percent,
        value
      };
    }
    var import_system2 = require_dist12();
    var import_jsx_runtime = require_jsx_runtime();
    var Shape = (props) => {
      const { size, isIndeterminate, ...rest } = props;
      return (0, import_jsx_runtime.jsx)(
        import_system2.chakra.svg,
        {
          viewBox: "0 0 100 100",
          __css: {
            width: size,
            height: size,
            animation: isIndeterminate ? `${rotate} 2s linear infinite` : void 0
          },
          ...rest
        }
      );
    };
    Shape.displayName = "Shape";
    var import_system3 = require_dist12();
    var import_jsx_runtime2 = require_jsx_runtime();
    var Circle = (props) => (0, import_jsx_runtime2.jsx)(import_system3.chakra.circle, { cx: 50, cy: 50, r: 42, fill: "transparent", ...props });
    Circle.displayName = "Circle";
    var import_jsx_runtime3 = require_jsx_runtime();
    var CircularProgress = (0, import_system4.forwardRef)(
      (props, ref) => {
        var _a;
        const {
          size = "48px",
          max = 100,
          min = 0,
          valueText,
          getValueText,
          value,
          capIsRound,
          children,
          thickness = "10px",
          color = "#0078d4",
          trackColor = "#edebe9",
          isIndeterminate,
          ...rest
        } = props;
        const progress2 = getProgressProps({
          min,
          max,
          value,
          valueText,
          getValueText,
          isIndeterminate
        });
        const determinant = isIndeterminate ? void 0 : ((_a = progress2.percent) != null ? _a : 0) * 2.64;
        const strokeDasharray = determinant == null ? void 0 : `${determinant} ${264 - determinant}`;
        const indicatorProps = isIndeterminate ? {
          css: { animation: `${spin} 1.5s linear infinite` }
        } : {
          strokeDashoffset: 66,
          strokeDasharray,
          transitionProperty: "stroke-dasharray, stroke",
          transitionDuration: "0.6s",
          transitionTimingFunction: "ease"
        };
        const rootStyles = {
          display: "inline-block",
          position: "relative",
          verticalAlign: "middle",
          fontSize: size
        };
        return (0, import_jsx_runtime3.jsxs)(
          import_system4.chakra.div,
          {
            ref,
            className: "chakra-progress",
            ...progress2.bind,
            ...rest,
            __css: rootStyles,
            children: [
              (0, import_jsx_runtime3.jsxs)(Shape, { size, isIndeterminate, children: [
                (0, import_jsx_runtime3.jsx)(
                  Circle,
                  {
                    stroke: trackColor,
                    strokeWidth: thickness,
                    className: "chakra-progress__track"
                  }
                ),
                (0, import_jsx_runtime3.jsx)(
                  Circle,
                  {
                    stroke: color,
                    strokeWidth: thickness,
                    className: "chakra-progress__indicator",
                    strokeLinecap: capIsRound ? "round" : void 0,
                    opacity: progress2.value === 0 && !isIndeterminate ? 0 : void 0,
                    ...indicatorProps
                  }
                )
              ] }),
              children
            ]
          }
        );
      }
    );
    CircularProgress.displayName = "CircularProgress";
    var import_system5 = require_dist12();
    var import_react_context = require_dist13();
    var import_jsx_runtime4 = require_jsx_runtime();
    var [ProgressStylesProvider, useProgressStyles] = (0, import_react_context.createContext)({
      name: `ProgressStylesContext`,
      errorMessage: `useProgressStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Progress />" `
    });
    var ProgressFilledTrack = (0, import_system5.forwardRef)(
      (props, ref) => {
        const { min, max, value, isIndeterminate, role, ...rest } = props;
        const progress2 = getProgressProps({
          value,
          min,
          max,
          isIndeterminate,
          role
        });
        const styles = useProgressStyles();
        const trackStyles = {
          height: "100%",
          ...styles.filledTrack
        };
        return (0, import_jsx_runtime4.jsx)(
          import_system5.chakra.div,
          {
            ref,
            style: { width: `${progress2.percent}%`, ...rest.style },
            ...progress2.bind,
            ...rest,
            __css: trackStyles
          }
        );
      }
    );
    var Progress = (0, import_system5.forwardRef)((props, ref) => {
      var _a;
      const {
        value,
        min = 0,
        max = 100,
        hasStripe,
        isAnimated,
        children,
        borderRadius: propBorderRadius,
        isIndeterminate,
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-valuetext": ariaValueText,
        title,
        role,
        ...rest
      } = (0, import_system5.omitThemingProps)(props);
      const styles = (0, import_system5.useMultiStyleConfig)("Progress", props);
      const borderRadius = propBorderRadius != null ? propBorderRadius : (_a = styles.track) == null ? void 0 : _a.borderRadius;
      const stripeAnimation = { animation: `${stripe} 1s linear infinite` };
      const shouldAddStripe = !isIndeterminate && hasStripe;
      const shouldAnimateStripe = shouldAddStripe && isAnimated;
      const css = {
        ...shouldAnimateStripe && stripeAnimation,
        ...isIndeterminate && {
          position: "absolute",
          willChange: "left",
          minWidth: "50%",
          animation: `${progress} 1s ease infinite normal none running`
        }
      };
      const trackStyles = {
        overflow: "hidden",
        position: "relative",
        ...styles.track
      };
      return (0, import_jsx_runtime4.jsx)(
        import_system5.chakra.div,
        {
          ref,
          borderRadius,
          __css: trackStyles,
          ...rest,
          children: (0, import_jsx_runtime4.jsxs)(ProgressStylesProvider, { value: styles, children: [
            (0, import_jsx_runtime4.jsx)(
              ProgressFilledTrack,
              {
                "aria-label": ariaLabel,
                "aria-labelledby": ariaLabelledBy,
                "aria-valuetext": ariaValueText,
                min,
                max,
                value,
                isIndeterminate,
                css,
                borderRadius,
                title,
                role
              }
            ),
            children
          ] })
        }
      );
    });
    Progress.displayName = "Progress";
    var import_system6 = require_dist12();
    var import_jsx_runtime5 = require_jsx_runtime();
    var ProgressLabel = (props) => {
      const styles = useProgressStyles();
      const labelStyles = {
        top: "50%",
        left: "50%",
        width: "100%",
        textAlign: "center",
        position: "absolute",
        transform: "translate(-50%, -50%)",
        ...styles.label
      };
      return (0, import_jsx_runtime5.jsx)(import_system6.chakra.div, { ...props, __css: labelStyles });
    };
    ProgressLabel.displayName = "ProgressLabel";
    var import_system7 = require_dist12();
    var CircularProgressLabel = (0, import_system7.chakra)("div", {
      baseStyle: {
        fontSize: "0.24em",
        top: "50%",
        left: "50%",
        width: "100%",
        textAlign: "center",
        position: "absolute",
        transform: "translate(-50%, -50%)"
      }
    });
    CircularProgressLabel.displayName = "CircularProgressLabel";
  }
});

// ../../node_modules/@chakra-ui/radio/dist/index.js
var require_dist65 = __commonJS({
  "../../node_modules/@chakra-ui/radio/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Radio: () => Radio,
      RadioGroup: () => RadioGroup,
      useRadio: () => useRadio,
      useRadioGroup: () => useRadioGroup,
      useRadioGroupContext: () => useRadioGroupContext
    });
    module.exports = __toCommonJS2(src_exports);
    var import_system2 = require_dist12();
    var import_shared_utils4 = require_dist3();
    function split(object, keys) {
      const picked = {};
      const omitted = {};
      for (const [key, value] of Object.entries(object)) {
        if (keys.includes(key))
          picked[key] = value;
        else
          omitted[key] = value;
      }
      return [picked, omitted];
    }
    var import_system = require_dist12();
    var import_shared_utils2 = require_dist3();
    var import_react_context = require_dist13();
    var import_shared_utils = require_dist3();
    var import_react_use_merge_refs = require_dist14();
    var import_react = require_react();
    function isInputEvent(value) {
      return value && (0, import_shared_utils.isObject)(value) && (0, import_shared_utils.isObject)(value.target);
    }
    function useRadioGroup(props = {}) {
      const {
        onChange: onChangeProp,
        value: valueProp,
        defaultValue,
        name: nameProp,
        isDisabled,
        isFocusable,
        isNative,
        ...htmlProps
      } = props;
      const [valueState, setValue] = (0, import_react.useState)(defaultValue || "");
      const isControlled = typeof valueProp !== "undefined";
      const value = isControlled ? valueProp : valueState;
      const ref = (0, import_react.useRef)(null);
      const focus = (0, import_react.useCallback)(() => {
        const rootNode = ref.current;
        if (!rootNode)
          return;
        let query = `input:not(:disabled):checked`;
        const firstEnabledAndCheckedInput = rootNode.querySelector(
          query
        );
        if (firstEnabledAndCheckedInput) {
          firstEnabledAndCheckedInput.focus();
          return;
        }
        query = `input:not(:disabled)`;
        const firstEnabledInput = rootNode.querySelector(query);
        firstEnabledInput == null ? void 0 : firstEnabledInput.focus();
      }, []);
      const uuid = (0, import_react.useId)();
      const fallbackName = `radio-${uuid}`;
      const name = nameProp || fallbackName;
      const onChange = (0, import_react.useCallback)(
        (eventOrValue) => {
          const nextValue = isInputEvent(eventOrValue) ? eventOrValue.target.value : eventOrValue;
          if (!isControlled) {
            setValue(nextValue);
          }
          onChangeProp == null ? void 0 : onChangeProp(String(nextValue));
        },
        [onChangeProp, isControlled]
      );
      const getRootProps = (0, import_react.useCallback)(
        (props2 = {}, forwardedRef = null) => ({
          ...props2,
          ref: (0, import_react_use_merge_refs.mergeRefs)(forwardedRef, ref),
          role: "radiogroup"
        }),
        []
      );
      const getRadioProps = (0, import_react.useCallback)(
        (props2 = {}, ref2 = null) => {
          const checkedKey = isNative ? "checked" : "isChecked";
          return {
            ...props2,
            ref: ref2,
            name,
            [checkedKey]: value != null ? props2.value === value : void 0,
            onChange(event) {
              onChange(event);
            },
            "data-radiogroup": true
          };
        },
        [isNative, name, onChange, value]
      );
      return {
        getRootProps,
        getRadioProps,
        name,
        ref,
        focus,
        setValue,
        value,
        onChange,
        isDisabled,
        isFocusable,
        htmlProps
      };
    }
    var import_react2 = require_react();
    var import_jsx_runtime = require_jsx_runtime();
    var [RadioGroupProvider, useRadioGroupContext] = (0, import_react_context.createContext)({
      name: "RadioGroupContext",
      strict: false
    });
    var RadioGroup = (0, import_system.forwardRef)((props, ref) => {
      const {
        colorScheme,
        size,
        variant,
        children,
        className,
        isDisabled,
        isFocusable,
        ...rest
      } = props;
      const { value, onChange, getRootProps, name, htmlProps } = useRadioGroup(rest);
      const group = (0, import_react2.useMemo)(
        () => ({
          name,
          size,
          onChange,
          colorScheme,
          value,
          variant,
          isDisabled,
          isFocusable
        }),
        [
          name,
          size,
          onChange,
          colorScheme,
          value,
          variant,
          isDisabled,
          isFocusable
        ]
      );
      return (0, import_jsx_runtime.jsx)(RadioGroupProvider, { value: group, children: (0, import_jsx_runtime.jsx)(
        import_system.chakra.div,
        {
          ...getRootProps(htmlProps, ref),
          className: (0, import_shared_utils2.cx)("chakra-radio-group", className),
          children
        }
      ) });
    });
    RadioGroup.displayName = "RadioGroup";
    var import_form_control = require_dist29();
    var import_shared_utils3 = require_dist3();
    var visuallyHiddenStyle = {
      border: "0",
      clip: "rect(0, 0, 0, 0)",
      height: "1px",
      width: "1px",
      margin: "-1px",
      padding: "0",
      overflow: "hidden",
      whiteSpace: "nowrap",
      position: "absolute"
    };
    var import_focus_visible = require_dist32();
    var import_react3 = require_react();
    function useRadio(props = {}) {
      const {
        defaultChecked,
        isChecked: isCheckedProp,
        isFocusable,
        isDisabled: isDisabledProp,
        isReadOnly: isReadOnlyProp,
        isRequired: isRequiredProp,
        onChange,
        isInvalid: isInvalidProp,
        name,
        value,
        id: idProp,
        "data-radiogroup": dataRadioGroup,
        "aria-describedby": ariaDescribedBy,
        ...htmlProps
      } = props;
      const uuid = `radio-${(0, import_react3.useId)()}`;
      const formControl = (0, import_form_control.useFormControlContext)();
      const group = useRadioGroupContext();
      const isWithinRadioGroup = !!group || !!dataRadioGroup;
      const isWithinFormControl = !!formControl;
      let id = isWithinFormControl && !isWithinRadioGroup ? formControl.id : uuid;
      id = idProp != null ? idProp : id;
      const isDisabled = isDisabledProp != null ? isDisabledProp : formControl == null ? void 0 : formControl.isDisabled;
      const isReadOnly = isReadOnlyProp != null ? isReadOnlyProp : formControl == null ? void 0 : formControl.isReadOnly;
      const isRequired = isRequiredProp != null ? isRequiredProp : formControl == null ? void 0 : formControl.isRequired;
      const isInvalid = isInvalidProp != null ? isInvalidProp : formControl == null ? void 0 : formControl.isInvalid;
      const [isFocusVisible, setIsFocusVisible] = (0, import_react3.useState)(false);
      const [isFocused, setFocused] = (0, import_react3.useState)(false);
      const [isHovered, setHovering] = (0, import_react3.useState)(false);
      const [isActive, setActive] = (0, import_react3.useState)(false);
      const [isCheckedState, setChecked] = (0, import_react3.useState)(Boolean(defaultChecked));
      const isControlled = typeof isCheckedProp !== "undefined";
      const isChecked = isControlled ? isCheckedProp : isCheckedState;
      (0, import_react3.useEffect)(() => {
        return (0, import_focus_visible.trackFocusVisible)(setIsFocusVisible);
      }, []);
      const handleChange = (0, import_react3.useCallback)(
        (event) => {
          if (isReadOnly || isDisabled) {
            event.preventDefault();
            return;
          }
          if (!isControlled) {
            setChecked(event.target.checked);
          }
          onChange == null ? void 0 : onChange(event);
        },
        [isControlled, isDisabled, isReadOnly, onChange]
      );
      const onKeyDown = (0, import_react3.useCallback)(
        (event) => {
          if (event.key === " ") {
            setActive(true);
          }
        },
        [setActive]
      );
      const onKeyUp = (0, import_react3.useCallback)(
        (event) => {
          if (event.key === " ") {
            setActive(false);
          }
        },
        [setActive]
      );
      const getRadioProps = (0, import_react3.useCallback)(
        (props2 = {}, ref = null) => ({
          ...props2,
          ref,
          "data-active": (0, import_shared_utils3.dataAttr)(isActive),
          "data-hover": (0, import_shared_utils3.dataAttr)(isHovered),
          "data-disabled": (0, import_shared_utils3.dataAttr)(isDisabled),
          "data-invalid": (0, import_shared_utils3.dataAttr)(isInvalid),
          "data-checked": (0, import_shared_utils3.dataAttr)(isChecked),
          "data-focus": (0, import_shared_utils3.dataAttr)(isFocused),
          "data-focus-visible": (0, import_shared_utils3.dataAttr)(isFocused && isFocusVisible),
          "data-readonly": (0, import_shared_utils3.dataAttr)(isReadOnly),
          "aria-hidden": true,
          onMouseDown: (0, import_shared_utils3.callAllHandlers)(props2.onMouseDown, () => setActive(true)),
          onMouseUp: (0, import_shared_utils3.callAllHandlers)(props2.onMouseUp, () => setActive(false)),
          onMouseEnter: (0, import_shared_utils3.callAllHandlers)(
            props2.onMouseEnter,
            () => setHovering(true)
          ),
          onMouseLeave: (0, import_shared_utils3.callAllHandlers)(
            props2.onMouseLeave,
            () => setHovering(false)
          )
        }),
        [
          isActive,
          isHovered,
          isDisabled,
          isInvalid,
          isChecked,
          isFocused,
          isReadOnly,
          isFocusVisible
        ]
      );
      const { onFocus, onBlur } = formControl != null ? formControl : {};
      const getInputProps = (0, import_react3.useCallback)(
        (props2 = {}, ref = null) => {
          const trulyDisabled = isDisabled && !isFocusable;
          return {
            ...props2,
            id,
            ref,
            type: "radio",
            name,
            value,
            onChange: (0, import_shared_utils3.callAllHandlers)(props2.onChange, handleChange),
            onBlur: (0, import_shared_utils3.callAllHandlers)(
              onBlur,
              props2.onBlur,
              () => setFocused(false)
            ),
            onFocus: (0, import_shared_utils3.callAllHandlers)(
              onFocus,
              props2.onFocus,
              () => setFocused(true)
            ),
            onKeyDown: (0, import_shared_utils3.callAllHandlers)(props2.onKeyDown, onKeyDown),
            onKeyUp: (0, import_shared_utils3.callAllHandlers)(props2.onKeyUp, onKeyUp),
            checked: isChecked,
            disabled: trulyDisabled,
            readOnly: isReadOnly,
            required: isRequired,
            "aria-invalid": (0, import_shared_utils3.ariaAttr)(isInvalid),
            "aria-disabled": (0, import_shared_utils3.ariaAttr)(trulyDisabled),
            "aria-required": (0, import_shared_utils3.ariaAttr)(isRequired),
            "data-readonly": (0, import_shared_utils3.dataAttr)(isReadOnly),
            "aria-describedby": ariaDescribedBy,
            style: visuallyHiddenStyle
          };
        },
        [
          isDisabled,
          isFocusable,
          id,
          name,
          value,
          handleChange,
          onBlur,
          onFocus,
          onKeyDown,
          onKeyUp,
          isChecked,
          isReadOnly,
          isRequired,
          isInvalid,
          ariaDescribedBy
        ]
      );
      const getLabelProps = (props2 = {}, ref = null) => ({
        ...props2,
        ref,
        onMouseDown: (0, import_shared_utils3.callAllHandlers)(props2.onMouseDown, stopEvent),
        "data-disabled": (0, import_shared_utils3.dataAttr)(isDisabled),
        "data-checked": (0, import_shared_utils3.dataAttr)(isChecked),
        "data-invalid": (0, import_shared_utils3.dataAttr)(isInvalid)
      });
      const getRootProps = (props2, ref = null) => ({
        ...props2,
        ref,
        "data-disabled": (0, import_shared_utils3.dataAttr)(isDisabled),
        "data-checked": (0, import_shared_utils3.dataAttr)(isChecked),
        "data-invalid": (0, import_shared_utils3.dataAttr)(isInvalid)
      });
      const state = {
        isInvalid,
        isFocused,
        isChecked,
        isActive,
        isHovered,
        isDisabled,
        isReadOnly,
        isRequired
      };
      return {
        state,
        getCheckboxProps: getRadioProps,
        getRadioProps,
        getInputProps,
        getLabelProps,
        getRootProps,
        htmlProps
      };
    }
    function stopEvent(event) {
      event.preventDefault();
      event.stopPropagation();
    }
    var import_jsx_runtime2 = require_jsx_runtime();
    var Radio = (0, import_system2.forwardRef)((props, ref) => {
      var _a;
      const group = useRadioGroupContext();
      const { onChange: onChangeProp, value: valueProp } = props;
      const styles = (0, import_system2.useMultiStyleConfig)("Radio", { ...group, ...props });
      const ownProps = (0, import_system2.omitThemingProps)(props);
      const {
        spacing = "0.5rem",
        children,
        isDisabled = group == null ? void 0 : group.isDisabled,
        isFocusable = group == null ? void 0 : group.isFocusable,
        inputProps: htmlInputProps,
        ...rest
      } = ownProps;
      let isChecked = props.isChecked;
      if ((group == null ? void 0 : group.value) != null && valueProp != null) {
        isChecked = group.value === valueProp;
      }
      let onChange = onChangeProp;
      if ((group == null ? void 0 : group.onChange) && valueProp != null) {
        onChange = (0, import_shared_utils4.callAll)(group.onChange, onChangeProp);
      }
      const name = (_a = props == null ? void 0 : props.name) != null ? _a : group == null ? void 0 : group.name;
      const {
        getInputProps,
        getCheckboxProps,
        getLabelProps,
        getRootProps,
        htmlProps
      } = useRadio({
        ...rest,
        isChecked,
        isFocusable,
        isDisabled,
        onChange,
        name
      });
      const [layoutProps, otherProps] = split(htmlProps, import_system2.layoutPropNames);
      const checkboxProps = getCheckboxProps(otherProps);
      const inputProps = getInputProps(htmlInputProps, ref);
      const labelProps = getLabelProps();
      const rootProps = Object.assign({}, layoutProps, getRootProps());
      const rootStyles = {
        display: "inline-flex",
        alignItems: "center",
        verticalAlign: "top",
        cursor: "pointer",
        position: "relative",
        ...styles.container
      };
      const checkboxStyles = {
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        flexShrink: 0,
        ...styles.control
      };
      const labelStyles = {
        userSelect: "none",
        marginStart: spacing,
        ...styles.label
      };
      return (0, import_jsx_runtime2.jsxs)(import_system2.chakra.label, { className: "chakra-radio", ...rootProps, __css: rootStyles, children: [
        (0, import_jsx_runtime2.jsx)("input", { className: "chakra-radio__input", ...inputProps }),
        (0, import_jsx_runtime2.jsx)(
          import_system2.chakra.span,
          {
            className: "chakra-radio__control",
            ...checkboxProps,
            __css: checkboxStyles
          }
        ),
        children && (0, import_jsx_runtime2.jsx)(
          import_system2.chakra.span,
          {
            className: "chakra-radio__label",
            ...labelProps,
            __css: labelStyles,
            children
          }
        )
      ] });
    });
    Radio.displayName = "Radio";
  }
});

// ../../node_modules/@chakra-ui/select/dist/index.js
var require_dist66 = __commonJS({
  "../../node_modules/@chakra-ui/select/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Select: () => Select,
      SelectField: () => SelectField
    });
    module.exports = __toCommonJS2(src_exports);
    var import_form_control = require_dist29();
    var import_system2 = require_dist12();
    var import_shared_utils2 = require_dist3();
    function split(object, keys) {
      const picked = {};
      const omitted = {};
      for (const [key, value] of Object.entries(object)) {
        if (keys.includes(key))
          picked[key] = value;
        else
          omitted[key] = value;
      }
      return [picked, omitted];
    }
    var import_react = require_react();
    var import_shared_utils = require_dist3();
    var import_system = require_dist12();
    var import_jsx_runtime = require_jsx_runtime();
    var SelectField = (0, import_system.forwardRef)(
      function SelectField2(props, ref) {
        const { children, placeholder, className, ...rest } = props;
        return (0, import_jsx_runtime.jsxs)(
          import_system.chakra.select,
          {
            ...rest,
            ref,
            className: (0, import_shared_utils.cx)("chakra-select", className),
            children: [
              placeholder && (0, import_jsx_runtime.jsx)("option", { value: "", children: placeholder }),
              children
            ]
          }
        );
      }
    );
    SelectField.displayName = "SelectField";
    var import_jsx_runtime2 = require_jsx_runtime();
    var Select = (0, import_system2.forwardRef)((props, ref) => {
      var _a;
      const styles = (0, import_system2.useMultiStyleConfig)("Select", props);
      const {
        rootProps,
        placeholder,
        icon,
        color,
        height,
        h,
        minH,
        minHeight,
        iconColor,
        iconSize,
        ...rest
      } = (0, import_system2.omitThemingProps)(props);
      const [layoutProps, otherProps] = split(rest, import_system2.layoutPropNames);
      const ownProps = (0, import_form_control.useFormControl)(otherProps);
      const rootStyles = {
        width: "100%",
        height: "fit-content",
        position: "relative",
        color
      };
      const fieldStyles = {
        paddingEnd: "2rem",
        ...styles.field,
        _focus: {
          zIndex: "unset",
          ...(_a = styles.field) == null ? void 0 : _a["_focus"]
        }
      };
      return (0, import_jsx_runtime2.jsxs)(
        import_system2.chakra.div,
        {
          className: "chakra-select__wrapper",
          __css: rootStyles,
          ...layoutProps,
          ...rootProps,
          children: [
            (0, import_jsx_runtime2.jsx)(
              SelectField,
              {
                ref,
                height: h != null ? h : height,
                minH: minH != null ? minH : minHeight,
                placeholder,
                ...ownProps,
                __css: fieldStyles,
                children: props.children
              }
            ),
            (0, import_jsx_runtime2.jsx)(
              SelectIcon,
              {
                "data-disabled": (0, import_shared_utils2.dataAttr)(ownProps.disabled),
                ...(iconColor || color) && { color: iconColor || color },
                __css: styles.icon,
                ...iconSize && { fontSize: iconSize },
                children: icon
              }
            )
          ]
        }
      );
    });
    Select.displayName = "Select";
    var DefaultIcon = (props) => (0, import_jsx_runtime2.jsx)("svg", { viewBox: "0 0 24 24", ...props, children: (0, import_jsx_runtime2.jsx)(
      "path",
      {
        fill: "currentColor",
        d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
      }
    ) });
    var IconWrapper = (0, import_system2.chakra)("div", {
      baseStyle: {
        position: "absolute",
        display: "inline-flex",
        alignItems: "center",
        justifyContent: "center",
        pointerEvents: "none",
        top: "50%",
        transform: "translateY(-50%)"
      }
    });
    var SelectIcon = (props) => {
      const { children = (0, import_jsx_runtime2.jsx)(DefaultIcon, {}), ...rest } = props;
      const clone = (0, import_react.cloneElement)(children, {
        role: "presentation",
        className: "chakra-select__icon",
        focusable: false,
        "aria-hidden": true,
        style: {
          width: "1em",
          height: "1em",
          color: "currentColor"
        }
      });
      return (0, import_jsx_runtime2.jsx)(IconWrapper, { ...rest, className: "chakra-select__icon-wrapper", children: (0, import_react.isValidElement)(children) ? clone : null });
    };
    SelectIcon.displayName = "SelectIcon";
  }
});

// ../../node_modules/@chakra-ui/react-use-previous/dist/index.js
var require_dist67 = __commonJS({
  "../../node_modules/@chakra-ui/react-use-previous/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      usePrevious: () => usePrevious
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react = require_react();
    function usePrevious(value) {
      const ref = (0, import_react.useRef)();
      (0, import_react.useEffect)(() => {
        ref.current = value;
      }, [value]);
      return ref.current;
    }
  }
});

// ../../node_modules/@chakra-ui/skeleton/dist/index.js
var require_dist68 = __commonJS({
  "../../node_modules/@chakra-ui/skeleton/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Skeleton: () => Skeleton,
      SkeletonCircle: () => SkeletonCircle,
      SkeletonText: () => SkeletonText
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react_use_previous = require_dist67();
    var import_shared_utils = require_dist3();
    var import_system = require_dist12();
    var import_react = require_react();
    function useIsFirstRender() {
      const isFirstRender = (0, import_react.useRef)(true);
      (0, import_react.useEffect)(() => {
        isFirstRender.current = false;
      }, []);
      return isFirstRender.current;
    }
    var import_jsx_runtime = require_jsx_runtime();
    var StyledSkeleton = (0, import_system.chakra)("div", {
      baseStyle: {
        boxShadow: "none",
        backgroundClip: "padding-box",
        cursor: "default",
        color: "transparent",
        pointerEvents: "none",
        userSelect: "none",
        "&::before, &::after, *": {
          visibility: "hidden"
        }
      }
    });
    var $startColor = (0, import_system.cssVar)("skeleton-start-color");
    var $endColor = (0, import_system.cssVar)("skeleton-end-color");
    var fade = (0, import_system.keyframes)({
      from: { opacity: 0 },
      to: { opacity: 1 }
    });
    var bgFade = (0, import_system.keyframes)({
      from: {
        borderColor: $startColor.reference,
        background: $startColor.reference
      },
      to: {
        borderColor: $endColor.reference,
        background: $endColor.reference
      }
    });
    var Skeleton = (0, import_system.forwardRef)((props, ref) => {
      const skeletonProps = {
        ...props,
        fadeDuration: typeof props.fadeDuration === "number" ? props.fadeDuration : 0.4,
        speed: typeof props.speed === "number" ? props.speed : 0.8
      };
      const styles = (0, import_system.useStyleConfig)("Skeleton", skeletonProps);
      const isFirstRender = useIsFirstRender();
      const {
        startColor = "",
        endColor = "",
        isLoaded,
        fadeDuration,
        speed,
        className,
        fitContent,
        ...rest
      } = (0, import_system.omitThemingProps)(skeletonProps);
      const [startColorVar, endColorVar] = (0, import_system.useToken)("colors", [
        startColor,
        endColor
      ]);
      const wasPreviouslyLoaded = (0, import_react_use_previous.usePrevious)(isLoaded);
      const _className = (0, import_shared_utils.cx)("chakra-skeleton", className);
      const cssVarStyles = {
        ...startColorVar && { [$startColor.variable]: startColorVar },
        ...endColorVar && { [$endColor.variable]: endColorVar }
      };
      if (isLoaded) {
        const animation = isFirstRender || wasPreviouslyLoaded ? "none" : `${fade} ${fadeDuration}s`;
        return (0, import_jsx_runtime.jsx)(
          import_system.chakra.div,
          {
            ref,
            className: _className,
            __css: { animation },
            ...rest
          }
        );
      }
      return (0, import_jsx_runtime.jsx)(
        StyledSkeleton,
        {
          ref,
          className: _className,
          ...rest,
          __css: {
            width: fitContent ? "fit-content" : void 0,
            ...styles,
            ...cssVarStyles,
            _dark: { ...styles["_dark"], ...cssVarStyles },
            animation: `${speed}s linear infinite alternate ${bgFade}`
          }
        }
      );
    });
    Skeleton.displayName = "Skeleton";
    var import_media_query = require_dist49();
    var import_system2 = require_dist12();
    var import_shared_utils2 = require_dist3();
    var import_jsx_runtime2 = require_jsx_runtime();
    function range(count) {
      return Array(count).fill(1).map((_, index) => index + 1);
    }
    var defaultNoOfLines = 3;
    var SkeletonText = (props) => {
      const {
        noOfLines = defaultNoOfLines,
        spacing = "0.5rem",
        skeletonHeight = "0.5rem",
        className,
        startColor,
        endColor,
        isLoaded,
        fadeDuration,
        speed,
        variant,
        size,
        colorScheme,
        children,
        ...rest
      } = props;
      const noOfLinesValue = (0, import_media_query.useBreakpointValue)(
        typeof noOfLines === "number" ? [noOfLines] : noOfLines
      ) || defaultNoOfLines;
      const numbers = range(noOfLinesValue);
      const getWidth = (index) => {
        if (noOfLinesValue > 1) {
          return index === numbers.length ? "80%" : "100%";
        }
        return "100%";
      };
      const _className = (0, import_shared_utils2.cx)("chakra-skeleton__group", className);
      return (0, import_jsx_runtime2.jsx)(import_system2.chakra.div, { className: _className, ...rest, children: numbers.map((number, index) => {
        if (isLoaded && index > 0) {
          return null;
        }
        const sizeProps = isLoaded ? null : {
          mb: number === numbers.length ? "0" : spacing,
          width: getWidth(number),
          height: skeletonHeight
        };
        return (0, import_jsx_runtime2.jsx)(
          Skeleton,
          {
            startColor,
            endColor,
            isLoaded,
            fadeDuration,
            speed,
            variant,
            size,
            colorScheme,
            ...sizeProps,
            children: index === 0 ? children : void 0
          },
          numbers.length.toString() + number
        );
      }) });
    };
    SkeletonText.displayName = "SkeletonText";
    var import_jsx_runtime3 = require_jsx_runtime();
    var SkeletonCircle = ({
      size = "2rem",
      ...rest
    }) => (0, import_jsx_runtime3.jsx)(Skeleton, { borderRadius: "full", boxSize: size, ...rest });
    SkeletonCircle.displayName = "SkeletonCircle";
  }
});

// ../../node_modules/@chakra-ui/event-utils/dist/index.js
var require_dist69 = __commonJS({
  "../../node_modules/@chakra-ui/event-utils/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      addDomEvent: () => addDomEvent,
      addPointerEvent: () => addPointerEvent,
      getEventPoint: () => getEventPoint,
      isMouseEvent: () => isMouseEvent,
      isMultiTouchEvent: () => isMultiTouchEvent,
      isTouchEvent: () => isTouchEvent
    });
    module.exports = __toCommonJS2(src_exports);
    function addDomEvent(target, eventName, handler, options) {
      target.addEventListener(eventName, handler, options);
      return () => {
        target.removeEventListener(eventName, handler, options);
      };
    }
    function isMouseEvent(event) {
      const win = getEventWindow(event);
      if (typeof win.PointerEvent !== "undefined" && event instanceof win.PointerEvent) {
        return !!(event.pointerType === "mouse");
      }
      return event instanceof win.MouseEvent;
    }
    function isTouchEvent(event) {
      const hasTouches = !!event.touches;
      return hasTouches;
    }
    function isMultiTouchEvent(event) {
      return isTouchEvent(event) && event.touches.length > 1;
    }
    function getEventWindow(event) {
      var _a;
      return (_a = event.view) != null ? _a : window;
    }
    function pointFromTouch(e, type = "page") {
      const point = e.touches[0] || e.changedTouches[0];
      return { x: point[`${type}X`], y: point[`${type}Y`] };
    }
    function pointFromMouse(point, type = "page") {
      return {
        x: point[`${type}X`],
        y: point[`${type}Y`]
      };
    }
    function getEventPoint(event, type = "page") {
      return isTouchEvent(event) ? pointFromTouch(event, type) : pointFromMouse(event, type);
    }
    function filter(cb) {
      return (event) => {
        const isMouse = isMouseEvent(event);
        if (!isMouse || isMouse && event.button === 0) {
          cb(event);
        }
      };
    }
    function wrap(cb, filterPrimary = false) {
      function listener(event) {
        cb(event, { point: getEventPoint(event) });
      }
      const fn = filterPrimary ? filter(listener) : listener;
      return fn;
    }
    function addPointerEvent(target, type, cb, options) {
      return addDomEvent(target, type, wrap(cb, type === "pointerdown"), options);
    }
  }
});

// ../../node_modules/@chakra-ui/react-use-latest-ref/dist/index.js
var require_dist70 = __commonJS({
  "../../node_modules/@chakra-ui/react-use-latest-ref/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      useLatestRef: () => useLatestRef
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react = require_react();
    function useLatestRef(value) {
      const ref = (0, import_react.useRef)(null);
      ref.current = value;
      return ref;
    }
  }
});

// ../../node_modules/@chakra-ui/react-use-pan-event/dist/index.js
var require_dist71 = __commonJS({
  "../../node_modules/@chakra-ui/react-use-pan-event/dist/index.js"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var __publicField = (obj, key, value) => {
      __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    var src_exports = {};
    __export(src_exports, {
      usePanEvent: () => usePanEvent
    });
    module.exports = __toCommonJS2(src_exports);
    var import_event_utils2 = require_dist69();
    var import_react_use_latest_ref = require_dist70();
    var import_react = require_react();
    var import_event_utils = require_dist69();
    var import_framesync = __toESM(require_framesync_cjs());
    var PanEvent = class {
      constructor(event, handlers, threshold) {
        __publicField(this, "history", []);
        __publicField(this, "startEvent", null);
        __publicField(this, "lastEvent", null);
        __publicField(this, "lastEventInfo", null);
        __publicField(this, "handlers", {});
        __publicField(this, "removeListeners", () => {
        });
        __publicField(this, "threshold", 3);
        __publicField(this, "win");
        __publicField(this, "updatePoint", () => {
          if (!(this.lastEvent && this.lastEventInfo))
            return;
          const info2 = getPanInfo(this.lastEventInfo, this.history);
          const isPanStarted = this.startEvent !== null;
          const isDistancePastThreshold = distance(info2.offset, { x: 0, y: 0 }) >= this.threshold;
          if (!isPanStarted && !isDistancePastThreshold)
            return;
          const { timestamp: timestamp2 } = (0, import_framesync.getFrameData)();
          this.history.push({ ...info2.point, timestamp: timestamp2 });
          const { onStart, onMove } = this.handlers;
          if (!isPanStarted) {
            onStart == null ? void 0 : onStart(this.lastEvent, info2);
            this.startEvent = this.lastEvent;
          }
          onMove == null ? void 0 : onMove(this.lastEvent, info2);
        });
        __publicField(this, "onPointerMove", (event2, info2) => {
          this.lastEvent = event2;
          this.lastEventInfo = info2;
          import_framesync.default.update(this.updatePoint, true);
        });
        __publicField(this, "onPointerUp", (event2, info2) => {
          const panInfo = getPanInfo(info2, this.history);
          const { onEnd, onSessionEnd } = this.handlers;
          onSessionEnd == null ? void 0 : onSessionEnd(event2, panInfo);
          this.end();
          if (!onEnd || !this.startEvent)
            return;
          onEnd == null ? void 0 : onEnd(event2, panInfo);
        });
        var _a;
        this.win = (_a = event.view) != null ? _a : window;
        if ((0, import_event_utils.isMultiTouchEvent)(event))
          return;
        this.handlers = handlers;
        if (threshold) {
          this.threshold = threshold;
        }
        event.stopPropagation();
        event.preventDefault();
        const info = { point: (0, import_event_utils.getEventPoint)(event) };
        const { timestamp } = (0, import_framesync.getFrameData)();
        this.history = [{ ...info.point, timestamp }];
        const { onSessionStart } = handlers;
        onSessionStart == null ? void 0 : onSessionStart(event, getPanInfo(info, this.history));
        this.removeListeners = pipe(
          (0, import_event_utils.addPointerEvent)(this.win, "pointermove", this.onPointerMove),
          (0, import_event_utils.addPointerEvent)(this.win, "pointerup", this.onPointerUp),
          (0, import_event_utils.addPointerEvent)(this.win, "pointercancel", this.onPointerUp)
        );
      }
      updateHandlers(handlers) {
        this.handlers = handlers;
      }
      end() {
        var _a;
        (_a = this.removeListeners) == null ? void 0 : _a.call(this);
        import_framesync.cancelSync.update(this.updatePoint);
      }
    };
    function subtract(a, b) {
      return { x: a.x - b.x, y: a.y - b.y };
    }
    function getPanInfo(info, history) {
      return {
        point: info.point,
        delta: subtract(info.point, history[history.length - 1]),
        offset: subtract(info.point, history[0]),
        velocity: getVelocity(history, 0.1)
      };
    }
    var toMilliseconds = (v) => v * 1e3;
    function getVelocity(history, timeDelta) {
      if (history.length < 2) {
        return { x: 0, y: 0 };
      }
      let i = history.length - 1;
      let timestampedPoint = null;
      const lastPoint = history[history.length - 1];
      while (i >= 0) {
        timestampedPoint = history[i];
        if (lastPoint.timestamp - timestampedPoint.timestamp > toMilliseconds(timeDelta)) {
          break;
        }
        i--;
      }
      if (!timestampedPoint) {
        return { x: 0, y: 0 };
      }
      const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;
      if (time === 0) {
        return { x: 0, y: 0 };
      }
      const currentVelocity = {
        x: (lastPoint.x - timestampedPoint.x) / time,
        y: (lastPoint.y - timestampedPoint.y) / time
      };
      if (currentVelocity.x === Infinity) {
        currentVelocity.x = 0;
      }
      if (currentVelocity.y === Infinity) {
        currentVelocity.y = 0;
      }
      return currentVelocity;
    }
    function pipe(...fns) {
      return (v) => fns.reduce((a, b) => b(a), v);
    }
    function distance1D(a, b) {
      return Math.abs(a - b);
    }
    function isPoint(point) {
      return "x" in point && "y" in point;
    }
    function distance(a, b) {
      if (typeof a === "number" && typeof b === "number") {
        return distance1D(a, b);
      }
      if (isPoint(a) && isPoint(b)) {
        const xDelta = distance1D(a.x, b.x);
        const yDelta = distance1D(a.y, b.y);
        return Math.sqrt(xDelta ** 2 + yDelta ** 2);
      }
      return 0;
    }
    function usePanEvent(ref, options) {
      const {
        onPan,
        onPanStart,
        onPanEnd,
        onPanSessionStart,
        onPanSessionEnd,
        threshold
      } = options;
      const hasPanEvents = Boolean(
        onPan || onPanStart || onPanEnd || onPanSessionStart || onPanSessionEnd
      );
      const panSession = (0, import_react.useRef)(null);
      const handlersRef = (0, import_react_use_latest_ref.useLatestRef)({
        onSessionStart: onPanSessionStart,
        onSessionEnd: onPanSessionEnd,
        onStart: onPanStart,
        onMove: onPan,
        onEnd(event, info) {
          panSession.current = null;
          onPanEnd == null ? void 0 : onPanEnd(event, info);
        }
      });
      (0, import_react.useEffect)(() => {
        var _a;
        (_a = panSession.current) == null ? void 0 : _a.updateHandlers(handlersRef.current);
      });
      (0, import_react.useEffect)(() => {
        const node = ref.current;
        if (!node || !hasPanEvents)
          return;
        function onPointerDown(event) {
          panSession.current = new PanEvent(event, handlersRef.current, threshold);
        }
        return (0, import_event_utils2.addPointerEvent)(node, "pointerdown", onPointerDown);
      }, [ref, hasPanEvents, handlersRef, threshold]);
      (0, import_react.useEffect)(() => {
        return () => {
          var _a;
          (_a = panSession.current) == null ? void 0 : _a.end();
          panSession.current = null;
        };
      }, []);
    }
  }
});

// ../../node_modules/@zag-js/element-size/dist/index.js
var require_dist72 = __commonJS({
  "../../node_modules/@zag-js/element-size/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      trackElementSize: () => trackElementSize,
      trackElementsSize: () => trackElementsSize
    });
    module.exports = __toCommonJS2(src_exports);
    function trackElementSize(element, callback) {
      var _a;
      if (!element) {
        callback(void 0);
        return;
      }
      callback({ width: element.offsetWidth, height: element.offsetHeight });
      const win = (_a = element.ownerDocument.defaultView) != null ? _a : window;
      const observer = new win.ResizeObserver((entries) => {
        if (!Array.isArray(entries) || !entries.length)
          return;
        const [entry] = entries;
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        callback({ width, height });
      });
      observer.observe(element, { box: "border-box" });
      return () => observer.unobserve(element);
    }
    function trackElementsSize(options) {
      const { getNodes, observeMutation = true, callback } = options;
      const cleanups = [];
      let firstNode = null;
      function trigger() {
        const elements = getNodes();
        firstNode = elements[0];
        const fns = elements.map(
          (element, index) => trackElementSize(element, (size) => {
            callback(size, index);
          })
        );
        cleanups.push(...fns);
      }
      trigger();
      if (observeMutation) {
        const fn = trackMutation(firstNode, trigger);
        cleanups.push(fn);
      }
      return () => {
        cleanups.forEach((cleanup) => {
          cleanup == null ? void 0 : cleanup();
        });
      };
    }
    function trackMutation(el, cb) {
      var _a, _b;
      if (!el || !el.parentElement)
        return;
      const win = (_b = (_a = el.ownerDocument) == null ? void 0 : _a.defaultView) != null ? _b : window;
      const observer = new win.MutationObserver(() => {
        cb();
      });
      observer.observe(el.parentElement, { childList: true });
      return () => {
        observer.disconnect();
      };
    }
  }
});

// ../../node_modules/@chakra-ui/react-use-size/dist/index.js
var require_dist73 = __commonJS({
  "../../node_modules/@chakra-ui/react-use-size/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      useSize: () => useSize,
      useSizes: () => useSizes
    });
    module.exports = __toCommonJS2(src_exports);
    var import_element_size = require_dist72();
    var import_react = require_react();
    var useSafeLayoutEffect = Boolean(globalThis == null ? void 0 : globalThis.document) ? import_react.useLayoutEffect : import_react.useEffect;
    function trackMutation(el, cb) {
      var _a, _b;
      if (!el || !el.parentElement)
        return;
      const win = (_b = (_a = el.ownerDocument) == null ? void 0 : _a.defaultView) != null ? _b : window;
      const observer = new win.MutationObserver(() => {
        cb();
      });
      observer.observe(el.parentElement, { childList: true });
      return () => {
        observer.disconnect();
      };
    }
    function useSizes({
      getNodes,
      observeMutation = true
    }) {
      const [sizes, setSizes] = (0, import_react.useState)([]);
      const [count, setCount] = (0, import_react.useState)(0);
      useSafeLayoutEffect(() => {
        const elements = getNodes();
        const cleanups = elements.map(
          (element, index) => (0, import_element_size.trackElementSize)(element, (size) => {
            setSizes((sizes2) => {
              return [
                ...sizes2.slice(0, index),
                size,
                ...sizes2.slice(index + 1)
              ];
            });
          })
        );
        if (observeMutation) {
          const firstNode = elements[0];
          cleanups.push(
            trackMutation(firstNode, () => {
              setCount((count2) => count2 + 1);
            })
          );
        }
        return () => {
          cleanups.forEach((cleanup) => {
            cleanup == null ? void 0 : cleanup();
          });
        };
      }, [count]);
      return sizes;
    }
    function isRef(ref) {
      return typeof ref === "object" && ref !== null && "current" in ref;
    }
    function useSize(subject) {
      const [size] = useSizes({
        observeMutation: false,
        getNodes() {
          const node = isRef(subject) ? subject.current : subject;
          return [node];
        }
      });
      return size;
    }
  }
});

// ../../node_modules/@chakra-ui/slider/dist/index.js
var require_dist74 = __commonJS({
  "../../node_modules/@chakra-ui/slider/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      RangeSlider: () => RangeSlider,
      RangeSliderFilledTrack: () => RangeSliderFilledTrack,
      RangeSliderMark: () => RangeSliderMark,
      RangeSliderProvider: () => RangeSliderProvider,
      RangeSliderThumb: () => RangeSliderThumb,
      RangeSliderTrack: () => RangeSliderTrack,
      Slider: () => Slider,
      SliderFilledTrack: () => SliderFilledTrack,
      SliderMark: () => SliderMark,
      SliderProvider: () => SliderProvider,
      SliderThumb: () => SliderThumb,
      SliderTrack: () => SliderTrack,
      useRangeSlider: () => useRangeSlider,
      useRangeSliderContext: () => useRangeSliderContext,
      useRangeSliderStyles: () => useRangeSliderStyles,
      useSlider: () => useSlider,
      useSliderContext: () => useSliderContext,
      useSliderStyles: () => useSliderStyles
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react_context = require_dist13();
    var import_system = require_dist12();
    var dataAttr = (condition) => condition ? "" : void 0;
    var ariaAttr = (condition) => condition ? true : void 0;
    var cx = (...classNames) => classNames.filter(Boolean).join(" ");
    function callAllHandlers(...fns) {
      return function func(event) {
        fns.some((fn) => {
          fn == null ? void 0 : fn(event);
          return event == null ? void 0 : event.defaultPrevented;
        });
      };
    }
    var import_react2 = require_react();
    var import_react_use_pan_event = require_dist71();
    var import_react_use_controllable_state = require_dist17();
    var import_react_use_callback_ref = require_dist16();
    var import_react_use_update_effect = require_dist30();
    var import_react_use_merge_refs = require_dist14();
    var import_number_utils = require_dist36();
    var import_react = require_react();
    function getIds(id) {
      return {
        root: `slider-root-${id}`,
        getThumb: (i) => `slider-thumb-${id}-${i}`,
        getInput: (i) => `slider-input-${id}-${i}`,
        track: `slider-track-${id}`,
        innerTrack: `slider-filled-track-${id}`,
        getMarker: (i) => `slider-marker-${id}-${i}`,
        output: `slider-output-${id}`
      };
    }
    function orient(options) {
      const { orientation, vertical, horizontal } = options;
      return orientation === "vertical" ? vertical : horizontal;
    }
    var zeroSize = { width: 0, height: 0 };
    var normalize = (a) => a || zeroSize;
    function getStyles(options) {
      const { orientation, thumbPercents, thumbRects, isReversed } = options;
      const getThumbStyle = (i) => {
        var _a;
        const rect = (_a = thumbRects[i]) != null ? _a : zeroSize;
        return {
          position: "absolute",
          userSelect: "none",
          WebkitUserSelect: "none",
          MozUserSelect: "none",
          msUserSelect: "none",
          touchAction: "none",
          ...orient({
            orientation,
            vertical: {
              bottom: `calc(${thumbPercents[i]}% - ${rect.height / 2}px)`
            },
            horizontal: {
              left: `calc(${thumbPercents[i]}% - ${rect.width / 2}px)`
            }
          })
        };
      };
      const size = orientation === "vertical" ? thumbRects.reduce(
        (a, b) => normalize(a).height > normalize(b).height ? a : b,
        zeroSize
      ) : thumbRects.reduce(
        (a, b) => normalize(a).width > normalize(b).width ? a : b,
        zeroSize
      );
      const rootStyle = {
        position: "relative",
        touchAction: "none",
        WebkitTapHighlightColor: "rgba(0,0,0,0)",
        userSelect: "none",
        outline: 0,
        ...orient({
          orientation,
          vertical: size ? {
            paddingLeft: size.width / 2,
            paddingRight: size.width / 2
          } : {},
          horizontal: size ? {
            paddingTop: size.height / 2,
            paddingBottom: size.height / 2
          } : {}
        })
      };
      const trackStyle = {
        position: "absolute",
        ...orient({
          orientation,
          vertical: {
            left: "50%",
            transform: "translateX(-50%)",
            height: "100%"
          },
          horizontal: {
            top: "50%",
            transform: "translateY(-50%)",
            width: "100%"
          }
        })
      };
      const isSingleThumb = thumbPercents.length === 1;
      const fallback = [0, isReversed ? 100 - thumbPercents[0] : thumbPercents[0]];
      const range = isSingleThumb ? fallback : thumbPercents;
      let start = range[0];
      if (!isSingleThumb && isReversed) {
        start = 100 - start;
      }
      const percent = Math.abs(range[range.length - 1] - range[0]);
      const innerTrackStyle = {
        ...trackStyle,
        ...orient({
          orientation,
          vertical: isReversed ? { height: `${percent}%`, top: `${start}%` } : { height: `${percent}%`, bottom: `${start}%` },
          horizontal: isReversed ? { width: `${percent}%`, right: `${start}%` } : { width: `${percent}%`, left: `${start}%` }
        })
      };
      return { trackStyle, innerTrackStyle, rootStyle, getThumbStyle };
    }
    function getIsReversed(options) {
      const { isReversed, direction, orientation } = options;
      if (direction === "ltr" || orientation === "vertical") {
        return isReversed;
      }
      return !isReversed;
    }
    var import_react_use_size = require_dist73();
    function useRangeSlider(props) {
      const {
        min = 0,
        max = 100,
        onChange,
        value: valueProp,
        defaultValue,
        isReversed: isReversedProp,
        direction = "ltr",
        orientation = "horizontal",
        id: idProp,
        isDisabled,
        isReadOnly,
        onChangeStart: onChangeStartProp,
        onChangeEnd: onChangeEndProp,
        step = 1,
        getAriaValueText: getAriaValueTextProp,
        "aria-valuetext": ariaValueText,
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        name,
        focusThumbOnChange = true,
        minStepsBetweenThumbs = 0,
        ...htmlProps
      } = props;
      const onChangeStart = (0, import_react_use_callback_ref.useCallbackRef)(onChangeStartProp);
      const onChangeEnd = (0, import_react_use_callback_ref.useCallbackRef)(onChangeEndProp);
      const getAriaValueText = (0, import_react_use_callback_ref.useCallbackRef)(getAriaValueTextProp);
      const isReversed = getIsReversed({
        isReversed: isReversedProp,
        direction,
        orientation
      });
      const [valueState, setValue] = (0, import_react_use_controllable_state.useControllableState)({
        value: valueProp,
        defaultValue: defaultValue != null ? defaultValue : [25, 75],
        onChange
      });
      if (!Array.isArray(valueState)) {
        throw new TypeError(
          `[range-slider] You passed an invalid value for \`value\` or \`defaultValue\`, expected \`Array\` but got \`${typeof valueState}\``
        );
      }
      const [isDragging, setDragging] = (0, import_react.useState)(false);
      const [isFocused, setFocused] = (0, import_react.useState)(false);
      const [activeIndex, setActiveIndex] = (0, import_react.useState)(-1);
      const isInteractive = !(isDisabled || isReadOnly);
      const initialValue = (0, import_react.useRef)(valueState);
      const value = valueState.map((val) => (0, import_number_utils.clampValue)(val, min, max));
      const spacing = minStepsBetweenThumbs * step;
      const valueBounds = getValueBounds(value, min, max, spacing);
      const stateRef = (0, import_react.useRef)({
        eventSource: null,
        value: [],
        valueBounds: []
      });
      stateRef.current.value = value;
      stateRef.current.valueBounds = valueBounds;
      const reversedValue = value.map((val) => max - val + min);
      const thumbValues = isReversed ? reversedValue : value;
      const thumbPercents = thumbValues.map((val) => (0, import_number_utils.valueToPercent)(val, min, max));
      const isVertical = orientation === "vertical";
      const trackRef = (0, import_react.useRef)(null);
      const rootRef = (0, import_react.useRef)(null);
      const thumbRects = (0, import_react_use_size.useSizes)({
        getNodes() {
          const rootNode = rootRef.current;
          const thumbNodes = rootNode == null ? void 0 : rootNode.querySelectorAll("[role=slider]");
          return thumbNodes ? Array.from(thumbNodes) : [];
        }
      });
      const reactId = (0, import_react.useId)();
      const uuid = idProp != null ? idProp : reactId;
      const ids = getIds(uuid);
      const getValueFromPointer = (0, import_react.useCallback)(
        (event) => {
          var _a, _b;
          if (!trackRef.current)
            return;
          stateRef.current.eventSource = "pointer";
          const rect = trackRef.current.getBoundingClientRect();
          const { clientX, clientY } = (_b = (_a = event.touches) == null ? void 0 : _a[0]) != null ? _b : event;
          const diff = isVertical ? rect.bottom - clientY : clientX - rect.left;
          const length = isVertical ? rect.height : rect.width;
          let percent = diff / length;
          if (isReversed)
            percent = 1 - percent;
          return (0, import_number_utils.percentToValue)(percent, min, max);
        },
        [isVertical, isReversed, max, min]
      );
      const tenSteps = (max - min) / 10;
      const oneStep = step || (max - min) / 100;
      const actions = (0, import_react.useMemo)(
        () => ({
          setValueAtIndex(index, val) {
            if (!isInteractive)
              return;
            const bounds = stateRef.current.valueBounds[index];
            val = parseFloat((0, import_number_utils.roundValueToStep)(val, bounds.min, oneStep));
            val = (0, import_number_utils.clampValue)(val, bounds.min, bounds.max);
            const next = [...stateRef.current.value];
            next[index] = val;
            setValue(next);
          },
          setActiveIndex,
          stepUp(index, step2 = oneStep) {
            const valueAtIndex = stateRef.current.value[index];
            const next = isReversed ? valueAtIndex - step2 : valueAtIndex + step2;
            actions.setValueAtIndex(index, next);
          },
          stepDown(index, step2 = oneStep) {
            const valueAtIndex = stateRef.current.value[index];
            const next = isReversed ? valueAtIndex + step2 : valueAtIndex - step2;
            actions.setValueAtIndex(index, next);
          },
          reset() {
            setValue(initialValue.current);
          }
        }),
        [oneStep, isReversed, setValue, isInteractive]
      );
      const onKeyDown = (0, import_react.useCallback)(
        (event) => {
          const eventKey = event.key;
          const keyMap = {
            ArrowRight: () => actions.stepUp(activeIndex),
            ArrowUp: () => actions.stepUp(activeIndex),
            ArrowLeft: () => actions.stepDown(activeIndex),
            ArrowDown: () => actions.stepDown(activeIndex),
            PageUp: () => actions.stepUp(activeIndex, tenSteps),
            PageDown: () => actions.stepDown(activeIndex, tenSteps),
            Home: () => {
              const { min: value2 } = valueBounds[activeIndex];
              actions.setValueAtIndex(activeIndex, value2);
            },
            End: () => {
              const { max: value2 } = valueBounds[activeIndex];
              actions.setValueAtIndex(activeIndex, value2);
            }
          };
          const action = keyMap[eventKey];
          if (action) {
            event.preventDefault();
            event.stopPropagation();
            action(event);
            stateRef.current.eventSource = "keyboard";
          }
        },
        [actions, activeIndex, tenSteps, valueBounds]
      );
      const { getThumbStyle, rootStyle, trackStyle, innerTrackStyle } = (0, import_react.useMemo)(
        () => getStyles({
          isReversed,
          orientation,
          thumbRects,
          thumbPercents
        }),
        [isReversed, orientation, thumbPercents, thumbRects]
      );
      const focusThumb = (0, import_react.useCallback)(
        (index) => {
          var _a;
          const idx = index != null ? index : activeIndex;
          if (idx !== -1 && focusThumbOnChange) {
            const id = ids.getThumb(idx);
            const thumb = (_a = rootRef.current) == null ? void 0 : _a.ownerDocument.getElementById(id);
            if (thumb) {
              setTimeout(() => thumb.focus());
            }
          }
        },
        [focusThumbOnChange, activeIndex, ids]
      );
      (0, import_react_use_update_effect.useUpdateEffect)(() => {
        if (stateRef.current.eventSource === "keyboard") {
          onChangeEnd == null ? void 0 : onChangeEnd(stateRef.current.value);
        }
      }, [value, onChangeEnd]);
      const onPanSessionStart = (event) => {
        const pointValue = getValueFromPointer(event) || 0;
        const distances = stateRef.current.value.map(
          (val) => Math.abs(val - pointValue)
        );
        const closest = Math.min(...distances);
        let index = distances.indexOf(closest);
        const thumbsAtPosition = distances.filter(
          (distance) => distance === closest
        );
        const isThumbStacked = thumbsAtPosition.length > 1;
        if (isThumbStacked && pointValue > stateRef.current.value[index]) {
          index = index + thumbsAtPosition.length - 1;
        }
        setActiveIndex(index);
        actions.setValueAtIndex(index, pointValue);
        focusThumb(index);
      };
      const onPan = (event) => {
        if (activeIndex == -1)
          return;
        const pointValue = getValueFromPointer(event) || 0;
        setActiveIndex(activeIndex);
        actions.setValueAtIndex(activeIndex, pointValue);
        focusThumb(activeIndex);
      };
      (0, import_react_use_pan_event.usePanEvent)(rootRef, {
        onPanSessionStart(event) {
          if (!isInteractive)
            return;
          setDragging(true);
          onPanSessionStart(event);
          onChangeStart == null ? void 0 : onChangeStart(stateRef.current.value);
        },
        onPanSessionEnd() {
          if (!isInteractive)
            return;
          setDragging(false);
          onChangeEnd == null ? void 0 : onChangeEnd(stateRef.current.value);
        },
        onPan(event) {
          if (!isInteractive)
            return;
          onPan(event);
        }
      });
      const getRootProps = (0, import_react.useCallback)(
        (props2 = {}, ref = null) => {
          return {
            ...props2,
            ...htmlProps,
            id: ids.root,
            ref: (0, import_react_use_merge_refs.mergeRefs)(ref, rootRef),
            tabIndex: -1,
            "aria-disabled": ariaAttr(isDisabled),
            "data-focused": dataAttr(isFocused),
            style: { ...props2.style, ...rootStyle }
          };
        },
        [htmlProps, isDisabled, isFocused, rootStyle, ids]
      );
      const getTrackProps = (0, import_react.useCallback)(
        (props2 = {}, ref = null) => {
          return {
            ...props2,
            ref: (0, import_react_use_merge_refs.mergeRefs)(ref, trackRef),
            id: ids.track,
            "data-disabled": dataAttr(isDisabled),
            style: { ...props2.style, ...trackStyle }
          };
        },
        [isDisabled, trackStyle, ids]
      );
      const getInnerTrackProps = (0, import_react.useCallback)(
        (props2 = {}, ref = null) => {
          return {
            ...props2,
            ref,
            id: ids.innerTrack,
            style: {
              ...props2.style,
              ...innerTrackStyle
            }
          };
        },
        [innerTrackStyle, ids]
      );
      const getThumbProps = (0, import_react.useCallback)(
        (props2, ref = null) => {
          var _a;
          const { index, ...rest } = props2;
          const valueAtIndex = value[index];
          if (valueAtIndex == null) {
            throw new TypeError(
              `[range-slider > thumb] Cannot find value at index \`${index}\`. The \`value\` or \`defaultValue\` length is : ${value.length}`
            );
          }
          const bounds = valueBounds[index];
          return {
            ...rest,
            ref,
            role: "slider",
            tabIndex: isInteractive ? 0 : void 0,
            id: ids.getThumb(index),
            "data-active": dataAttr(isDragging && activeIndex === index),
            "aria-valuetext": (_a = getAriaValueText == null ? void 0 : getAriaValueText(valueAtIndex)) != null ? _a : ariaValueText == null ? void 0 : ariaValueText[index],
            "aria-valuemin": bounds.min,
            "aria-valuemax": bounds.max,
            "aria-valuenow": valueAtIndex,
            "aria-orientation": orientation,
            "aria-disabled": ariaAttr(isDisabled),
            "aria-readonly": ariaAttr(isReadOnly),
            "aria-label": ariaLabel == null ? void 0 : ariaLabel[index],
            "aria-labelledby": (ariaLabel == null ? void 0 : ariaLabel[index]) ? void 0 : ariaLabelledBy == null ? void 0 : ariaLabelledBy[index],
            style: { ...props2.style, ...getThumbStyle(index) },
            onKeyDown: callAllHandlers(props2.onKeyDown, onKeyDown),
            onFocus: callAllHandlers(props2.onFocus, () => {
              setFocused(true);
              setActiveIndex(index);
            }),
            onBlur: callAllHandlers(props2.onBlur, () => {
              setFocused(false);
              setActiveIndex(-1);
            })
          };
        },
        [
          ids,
          value,
          valueBounds,
          isInteractive,
          isDragging,
          activeIndex,
          getAriaValueText,
          ariaValueText,
          orientation,
          isDisabled,
          isReadOnly,
          ariaLabel,
          ariaLabelledBy,
          getThumbStyle,
          onKeyDown,
          setFocused
        ]
      );
      const getOutputProps = (0, import_react.useCallback)(
        (props2 = {}, ref = null) => {
          return {
            ...props2,
            ref,
            id: ids.output,
            htmlFor: value.map((v, i) => ids.getThumb(i)).join(" "),
            "aria-live": "off"
          };
        },
        [ids, value]
      );
      const getMarkerProps = (0, import_react.useCallback)(
        (props2, ref = null) => {
          const { value: v, ...rest } = props2;
          const isInRange = !(v < min || v > max);
          const isHighlighted = v >= value[0] && v <= value[value.length - 1];
          let percent = (0, import_number_utils.valueToPercent)(v, min, max);
          percent = isReversed ? 100 - percent : percent;
          const markerStyle = {
            position: "absolute",
            pointerEvents: "none",
            ...orient({
              orientation,
              vertical: { bottom: `${percent}%` },
              horizontal: { left: `${percent}%` }
            })
          };
          return {
            ...rest,
            ref,
            id: ids.getMarker(props2.value),
            role: "presentation",
            "aria-hidden": true,
            "data-disabled": dataAttr(isDisabled),
            "data-invalid": dataAttr(!isInRange),
            "data-highlighted": dataAttr(isHighlighted),
            style: {
              ...props2.style,
              ...markerStyle
            }
          };
        },
        [isDisabled, isReversed, max, min, orientation, value, ids]
      );
      const getInputProps = (0, import_react.useCallback)(
        (props2, ref = null) => {
          const { index, ...rest } = props2;
          return {
            ...rest,
            ref,
            id: ids.getInput(index),
            type: "hidden",
            value: value[index],
            name: Array.isArray(name) ? name[index] : `${name}-${index}`
          };
        },
        [name, value, ids]
      );
      const state = {
        value,
        isFocused,
        isDragging,
        getThumbPercent: (index) => thumbPercents[index],
        getThumbMinValue: (index) => valueBounds[index].min,
        getThumbMaxValue: (index) => valueBounds[index].max
      };
      return {
        state,
        actions,
        getRootProps,
        getTrackProps,
        getInnerTrackProps,
        getThumbProps,
        getMarkerProps,
        getInputProps,
        getOutputProps
      };
    }
    function getValueBounds(arr, min, max, spacing) {
      return arr.map((v, i) => {
        const _min = i === 0 ? min : arr[i - 1] + spacing;
        const _max = i === arr.length - 1 ? max : arr[i + 1] - spacing;
        return { min: _min, max: _max };
      });
    }
    var import_jsx_runtime = require_jsx_runtime();
    var [RangeSliderProvider, useRangeSliderContext] = (0, import_react_context.createContext)({
      name: "SliderContext",
      errorMessage: "useSliderContext: `context` is undefined. Seems you forgot to wrap all slider components within <RangeSlider />"
    });
    var [RangeSliderStylesProvider, useRangeSliderStyles] = (0, import_react_context.createContext)({
      name: `RangeSliderStylesContext`,
      errorMessage: `useRangeSliderStyles returned is 'undefined'. Seems you forgot to wrap the components in "<RangeSlider />" `
    });
    var RangeSlider = (0, import_system.forwardRef)(
      function RangeSlider2(props, ref) {
        const sliderProps = {
          orientation: "horizontal",
          ...props
        };
        const styles = (0, import_system.useMultiStyleConfig)("Slider", sliderProps);
        const ownProps = (0, import_system.omitThemingProps)(sliderProps);
        const { direction } = (0, import_system.useTheme)();
        ownProps.direction = direction;
        const { getRootProps, ...context } = useRangeSlider(ownProps);
        const ctx = (0, import_react2.useMemo)(
          () => ({ ...context, name: sliderProps.name }),
          [context, sliderProps.name]
        );
        return (0, import_jsx_runtime.jsx)(RangeSliderProvider, { value: ctx, children: (0, import_jsx_runtime.jsx)(RangeSliderStylesProvider, { value: styles, children: (0, import_jsx_runtime.jsx)(
          import_system.chakra.div,
          {
            ...getRootProps({}, ref),
            className: "chakra-slider",
            __css: styles.container,
            children: sliderProps.children
          }
        ) }) });
      }
    );
    RangeSlider.displayName = "RangeSlider";
    var RangeSliderThumb = (0, import_system.forwardRef)(
      function RangeSliderThumb2(props, ref) {
        const { getThumbProps, getInputProps, name } = useRangeSliderContext();
        const styles = useRangeSliderStyles();
        const thumbProps = getThumbProps(props, ref);
        return (0, import_jsx_runtime.jsxs)(
          import_system.chakra.div,
          {
            ...thumbProps,
            className: cx("chakra-slider__thumb", props.className),
            __css: styles.thumb,
            children: [
              thumbProps.children,
              name && (0, import_jsx_runtime.jsx)("input", { ...getInputProps({ index: props.index }) })
            ]
          }
        );
      }
    );
    RangeSliderThumb.displayName = "RangeSliderThumb";
    var RangeSliderTrack = (0, import_system.forwardRef)(
      function RangeSliderTrack2(props, ref) {
        const { getTrackProps } = useRangeSliderContext();
        const styles = useRangeSliderStyles();
        const trackProps = getTrackProps(props, ref);
        return (0, import_jsx_runtime.jsx)(
          import_system.chakra.div,
          {
            ...trackProps,
            className: cx("chakra-slider__track", props.className),
            __css: styles.track,
            "data-testid": "chakra-range-slider-track"
          }
        );
      }
    );
    RangeSliderTrack.displayName = "RangeSliderTrack";
    var RangeSliderFilledTrack = (0, import_system.forwardRef)(function RangeSliderFilledTrack2(props, ref) {
      const { getInnerTrackProps } = useRangeSliderContext();
      const styles = useRangeSliderStyles();
      const trackProps = getInnerTrackProps(props, ref);
      return (0, import_jsx_runtime.jsx)(
        import_system.chakra.div,
        {
          ...trackProps,
          className: "chakra-slider__filled-track",
          __css: styles.filledTrack
        }
      );
    });
    RangeSliderFilledTrack.displayName = "RangeSliderFilledTrack";
    var RangeSliderMark = (0, import_system.forwardRef)(
      function RangeSliderMark2(props, ref) {
        const { getMarkerProps } = useRangeSliderContext();
        const markProps = getMarkerProps(props, ref);
        return (0, import_jsx_runtime.jsx)(
          import_system.chakra.div,
          {
            ...markProps,
            className: cx("chakra-slider__marker", props.className)
          }
        );
      }
    );
    RangeSliderMark.displayName = "RangeSliderMark";
    var import_react_context2 = require_dist13();
    var import_system2 = require_dist12();
    var import_react_use_pan_event2 = require_dist71();
    var import_react_use_callback_ref2 = require_dist16();
    var import_react_use_update_effect2 = require_dist30();
    var import_react_use_controllable_state2 = require_dist17();
    var import_react_use_size2 = require_dist73();
    var import_react_use_merge_refs2 = require_dist14();
    var import_react_use_latest_ref = require_dist70();
    var import_number_utils2 = require_dist36();
    var import_react3 = require_react();
    function useSlider(props) {
      var _a;
      const {
        min = 0,
        max = 100,
        onChange,
        value: valueProp,
        defaultValue,
        isReversed: isReversedProp,
        direction = "ltr",
        orientation = "horizontal",
        id: idProp,
        isDisabled,
        isReadOnly,
        onChangeStart: onChangeStartProp,
        onChangeEnd: onChangeEndProp,
        step = 1,
        getAriaValueText: getAriaValueTextProp,
        "aria-valuetext": ariaValueText,
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        name,
        focusThumbOnChange = true,
        ...htmlProps
      } = props;
      const onChangeStart = (0, import_react_use_callback_ref2.useCallbackRef)(onChangeStartProp);
      const onChangeEnd = (0, import_react_use_callback_ref2.useCallbackRef)(onChangeEndProp);
      const getAriaValueText = (0, import_react_use_callback_ref2.useCallbackRef)(getAriaValueTextProp);
      const isReversed = getIsReversed({
        isReversed: isReversedProp,
        direction,
        orientation
      });
      const [computedValue, setValue] = (0, import_react_use_controllable_state2.useControllableState)({
        value: valueProp,
        defaultValue: defaultValue != null ? defaultValue : getDefaultValue(min, max),
        onChange
      });
      const [isDragging, setDragging] = (0, import_react3.useState)(false);
      const [isFocused, setFocused] = (0, import_react3.useState)(false);
      const isInteractive = !(isDisabled || isReadOnly);
      const tenSteps = (max - min) / 10;
      const oneStep = step || (max - min) / 100;
      const value = (0, import_number_utils2.clampValue)(computedValue, min, max);
      const reversedValue = max - value + min;
      const trackValue = isReversed ? reversedValue : value;
      const thumbPercent = (0, import_number_utils2.valueToPercent)(trackValue, min, max);
      const isVertical = orientation === "vertical";
      const stateRef = (0, import_react_use_latest_ref.useLatestRef)({
        min,
        max,
        step,
        isDisabled,
        value,
        isInteractive,
        isReversed,
        isVertical,
        eventSource: null,
        focusThumbOnChange,
        orientation
      });
      const trackRef = (0, import_react3.useRef)(null);
      const thumbRef = (0, import_react3.useRef)(null);
      const rootRef = (0, import_react3.useRef)(null);
      const reactId = (0, import_react3.useId)();
      const uuid = idProp != null ? idProp : reactId;
      const [thumbId, trackId] = [`slider-thumb-${uuid}`, `slider-track-${uuid}`];
      const getValueFromPointer = (0, import_react3.useCallback)(
        (event) => {
          var _a2, _b;
          if (!trackRef.current)
            return;
          const state2 = stateRef.current;
          state2.eventSource = "pointer";
          const trackRect = trackRef.current.getBoundingClientRect();
          const { clientX, clientY } = (_b = (_a2 = event.touches) == null ? void 0 : _a2[0]) != null ? _b : event;
          const diff = isVertical ? trackRect.bottom - clientY : clientX - trackRect.left;
          const length = isVertical ? trackRect.height : trackRect.width;
          let percent = diff / length;
          if (isReversed) {
            percent = 1 - percent;
          }
          let nextValue = (0, import_number_utils2.percentToValue)(percent, state2.min, state2.max);
          if (state2.step) {
            nextValue = parseFloat(
              (0, import_number_utils2.roundValueToStep)(nextValue, state2.min, state2.step)
            );
          }
          nextValue = (0, import_number_utils2.clampValue)(nextValue, state2.min, state2.max);
          return nextValue;
        },
        [isVertical, isReversed, stateRef]
      );
      const constrain = (0, import_react3.useCallback)(
        (value2) => {
          const state2 = stateRef.current;
          if (!state2.isInteractive)
            return;
          value2 = parseFloat((0, import_number_utils2.roundValueToStep)(value2, state2.min, oneStep));
          value2 = (0, import_number_utils2.clampValue)(value2, state2.min, state2.max);
          setValue(value2);
        },
        [oneStep, setValue, stateRef]
      );
      const actions = (0, import_react3.useMemo)(
        () => ({
          stepUp(step2 = oneStep) {
            const next = isReversed ? value - step2 : value + step2;
            constrain(next);
          },
          stepDown(step2 = oneStep) {
            const next = isReversed ? value + step2 : value - step2;
            constrain(next);
          },
          reset() {
            constrain(defaultValue || 0);
          },
          stepTo(value2) {
            constrain(value2);
          }
        }),
        [constrain, isReversed, value, oneStep, defaultValue]
      );
      const onKeyDown = (0, import_react3.useCallback)(
        (event) => {
          const state2 = stateRef.current;
          const keyMap = {
            ArrowRight: () => actions.stepUp(),
            ArrowUp: () => actions.stepUp(),
            ArrowLeft: () => actions.stepDown(),
            ArrowDown: () => actions.stepDown(),
            PageUp: () => actions.stepUp(tenSteps),
            PageDown: () => actions.stepDown(tenSteps),
            Home: () => constrain(state2.min),
            End: () => constrain(state2.max)
          };
          const action = keyMap[event.key];
          if (action) {
            event.preventDefault();
            event.stopPropagation();
            action(event);
            state2.eventSource = "keyboard";
          }
        },
        [actions, constrain, tenSteps, stateRef]
      );
      const valueText = (_a = getAriaValueText == null ? void 0 : getAriaValueText(value)) != null ? _a : ariaValueText;
      const thumbSize = (0, import_react_use_size2.useSize)(thumbRef);
      const { getThumbStyle, rootStyle, trackStyle, innerTrackStyle } = (0, import_react3.useMemo)(() => {
        const state2 = stateRef.current;
        const thumbRect = thumbSize != null ? thumbSize : { width: 0, height: 0 };
        return getStyles({
          isReversed,
          orientation: state2.orientation,
          thumbRects: [thumbRect],
          thumbPercents: [thumbPercent]
        });
      }, [isReversed, thumbSize, thumbPercent, stateRef]);
      const focusThumb = (0, import_react3.useCallback)(() => {
        const state2 = stateRef.current;
        if (state2.focusThumbOnChange) {
          setTimeout(() => {
            var _a2;
            return (_a2 = thumbRef.current) == null ? void 0 : _a2.focus();
          });
        }
      }, [stateRef]);
      (0, import_react_use_update_effect2.useUpdateEffect)(() => {
        const state2 = stateRef.current;
        focusThumb();
        if (state2.eventSource === "keyboard") {
          onChangeEnd == null ? void 0 : onChangeEnd(state2.value);
        }
      }, [value, onChangeEnd]);
      function setValueFromPointer(event) {
        const nextValue = getValueFromPointer(event);
        if (nextValue != null && nextValue !== stateRef.current.value) {
          setValue(nextValue);
        }
      }
      (0, import_react_use_pan_event2.usePanEvent)(rootRef, {
        onPanSessionStart(event) {
          const state2 = stateRef.current;
          if (!state2.isInteractive)
            return;
          setDragging(true);
          focusThumb();
          setValueFromPointer(event);
          onChangeStart == null ? void 0 : onChangeStart(state2.value);
        },
        onPanSessionEnd() {
          const state2 = stateRef.current;
          if (!state2.isInteractive)
            return;
          setDragging(false);
          onChangeEnd == null ? void 0 : onChangeEnd(state2.value);
        },
        onPan(event) {
          const state2 = stateRef.current;
          if (!state2.isInteractive)
            return;
          setValueFromPointer(event);
        }
      });
      const getRootProps = (0, import_react3.useCallback)(
        (props2 = {}, ref = null) => {
          return {
            ...props2,
            ...htmlProps,
            ref: (0, import_react_use_merge_refs2.mergeRefs)(ref, rootRef),
            tabIndex: -1,
            "aria-disabled": ariaAttr(isDisabled),
            "data-focused": dataAttr(isFocused),
            style: {
              ...props2.style,
              ...rootStyle
            }
          };
        },
        [htmlProps, isDisabled, isFocused, rootStyle]
      );
      const getTrackProps = (0, import_react3.useCallback)(
        (props2 = {}, ref = null) => {
          return {
            ...props2,
            ref: (0, import_react_use_merge_refs2.mergeRefs)(ref, trackRef),
            id: trackId,
            "data-disabled": dataAttr(isDisabled),
            style: {
              ...props2.style,
              ...trackStyle
            }
          };
        },
        [isDisabled, trackId, trackStyle]
      );
      const getInnerTrackProps = (0, import_react3.useCallback)(
        (props2 = {}, ref = null) => {
          return {
            ...props2,
            ref,
            style: {
              ...props2.style,
              ...innerTrackStyle
            }
          };
        },
        [innerTrackStyle]
      );
      const getThumbProps = (0, import_react3.useCallback)(
        (props2 = {}, ref = null) => {
          return {
            ...props2,
            ref: (0, import_react_use_merge_refs2.mergeRefs)(ref, thumbRef),
            role: "slider",
            tabIndex: isInteractive ? 0 : void 0,
            id: thumbId,
            "data-active": dataAttr(isDragging),
            "aria-valuetext": valueText,
            "aria-valuemin": min,
            "aria-valuemax": max,
            "aria-valuenow": value,
            "aria-orientation": orientation,
            "aria-disabled": ariaAttr(isDisabled),
            "aria-readonly": ariaAttr(isReadOnly),
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabel ? void 0 : ariaLabelledBy,
            style: {
              ...props2.style,
              ...getThumbStyle(0)
            },
            onKeyDown: callAllHandlers(props2.onKeyDown, onKeyDown),
            onFocus: callAllHandlers(props2.onFocus, () => setFocused(true)),
            onBlur: callAllHandlers(props2.onBlur, () => setFocused(false))
          };
        },
        [
          isInteractive,
          thumbId,
          isDragging,
          valueText,
          min,
          max,
          value,
          orientation,
          isDisabled,
          isReadOnly,
          ariaLabel,
          ariaLabelledBy,
          getThumbStyle,
          onKeyDown
        ]
      );
      const getMarkerProps = (0, import_react3.useCallback)(
        (props2, ref = null) => {
          const isInRange = !(props2.value < min || props2.value > max);
          const isHighlighted = value >= props2.value;
          const markerPercent = (0, import_number_utils2.valueToPercent)(props2.value, min, max);
          const markerStyle = {
            position: "absolute",
            pointerEvents: "none",
            ...orient2({
              orientation,
              vertical: {
                bottom: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`
              },
              horizontal: {
                left: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`
              }
            })
          };
          return {
            ...props2,
            ref,
            role: "presentation",
            "aria-hidden": true,
            "data-disabled": dataAttr(isDisabled),
            "data-invalid": dataAttr(!isInRange),
            "data-highlighted": dataAttr(isHighlighted),
            style: {
              ...props2.style,
              ...markerStyle
            }
          };
        },
        [isDisabled, isReversed, max, min, orientation, value]
      );
      const getInputProps = (0, import_react3.useCallback)(
        (props2 = {}, ref = null) => {
          return {
            ...props2,
            ref,
            type: "hidden",
            value,
            name
          };
        },
        [name, value]
      );
      const state = { value, isFocused, isDragging };
      return {
        state,
        actions,
        getRootProps,
        getTrackProps,
        getInnerTrackProps,
        getThumbProps,
        getMarkerProps,
        getInputProps
      };
    }
    function orient2(options) {
      const { orientation, vertical, horizontal } = options;
      return orientation === "vertical" ? vertical : horizontal;
    }
    function getDefaultValue(min, max) {
      return max < min ? min : min + (max - min) / 2;
    }
    var import_jsx_runtime2 = require_jsx_runtime();
    var [SliderProvider, useSliderContext] = (0, import_react_context2.createContext)({
      name: "SliderContext",
      hookName: "useSliderContext",
      providerName: "<Slider />"
    });
    var [SliderStylesProvider, useSliderStyles] = (0, import_react_context2.createContext)({
      name: `SliderStylesContext`,
      hookName: `useSliderStyles`,
      providerName: "<Slider />"
    });
    var Slider = (0, import_system2.forwardRef)((props, ref) => {
      var _a;
      const sliderProps = {
        ...props,
        orientation: (_a = props == null ? void 0 : props.orientation) != null ? _a : "horizontal"
      };
      const styles = (0, import_system2.useMultiStyleConfig)("Slider", sliderProps);
      const ownProps = (0, import_system2.omitThemingProps)(sliderProps);
      const { direction } = (0, import_system2.useTheme)();
      ownProps.direction = direction;
      const { getInputProps, getRootProps, ...context } = useSlider(ownProps);
      const rootProps = getRootProps();
      const inputProps = getInputProps({}, ref);
      return (0, import_jsx_runtime2.jsx)(SliderProvider, { value: context, children: (0, import_jsx_runtime2.jsx)(SliderStylesProvider, { value: styles, children: (0, import_jsx_runtime2.jsxs)(
        import_system2.chakra.div,
        {
          ...rootProps,
          className: cx("chakra-slider", sliderProps.className),
          __css: styles.container,
          children: [
            sliderProps.children,
            (0, import_jsx_runtime2.jsx)("input", { ...inputProps })
          ]
        }
      ) }) });
    });
    Slider.displayName = "Slider";
    var SliderThumb = (0, import_system2.forwardRef)((props, ref) => {
      const { getThumbProps } = useSliderContext();
      const styles = useSliderStyles();
      const thumbProps = getThumbProps(props, ref);
      return (0, import_jsx_runtime2.jsx)(
        import_system2.chakra.div,
        {
          ...thumbProps,
          className: cx("chakra-slider__thumb", props.className),
          __css: styles.thumb
        }
      );
    });
    SliderThumb.displayName = "SliderThumb";
    var SliderTrack = (0, import_system2.forwardRef)((props, ref) => {
      const { getTrackProps } = useSliderContext();
      const styles = useSliderStyles();
      const trackProps = getTrackProps(props, ref);
      return (0, import_jsx_runtime2.jsx)(
        import_system2.chakra.div,
        {
          ...trackProps,
          className: cx("chakra-slider__track", props.className),
          __css: styles.track
        }
      );
    });
    SliderTrack.displayName = "SliderTrack";
    var SliderFilledTrack = (0, import_system2.forwardRef)(
      (props, ref) => {
        const { getInnerTrackProps } = useSliderContext();
        const styles = useSliderStyles();
        const trackProps = getInnerTrackProps(props, ref);
        return (0, import_jsx_runtime2.jsx)(
          import_system2.chakra.div,
          {
            ...trackProps,
            className: cx("chakra-slider__filled-track", props.className),
            __css: styles.filledTrack
          }
        );
      }
    );
    SliderFilledTrack.displayName = "SliderFilledTrack";
    var SliderMark = (0, import_system2.forwardRef)((props, ref) => {
      const { getMarkerProps } = useSliderContext();
      const styles = useSliderStyles();
      const markProps = getMarkerProps(props, ref);
      return (0, import_jsx_runtime2.jsx)(
        import_system2.chakra.div,
        {
          ...markProps,
          className: cx("chakra-slider__marker", props.className),
          __css: styles.mark
        }
      );
    });
    SliderMark.displayName = "SliderMark";
  }
});

// ../../node_modules/@chakra-ui/stat/dist/index.js
var require_dist75 = __commonJS({
  "../../node_modules/@chakra-ui/stat/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Stat: () => Stat,
      StatArrow: () => StatArrow,
      StatDownArrow: () => StatDownArrow,
      StatGroup: () => StatGroup,
      StatHelpText: () => StatHelpText,
      StatLabel: () => StatLabel,
      StatNumber: () => StatNumber,
      StatUpArrow: () => StatUpArrow,
      useStatStyles: () => useStatStyles
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react_context = require_dist13();
    var import_system = require_dist12();
    var import_shared_utils = require_dist3();
    var import_jsx_runtime = require_jsx_runtime();
    var [StatStylesProvider, useStatStyles] = (0, import_react_context.createContext)({
      name: `StatStylesContext`,
      errorMessage: `useStatStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Stat />" `
    });
    var Stat = (0, import_system.forwardRef)(function Stat2(props, ref) {
      const styles = (0, import_system.useMultiStyleConfig)("Stat", props);
      const statStyles = {
        position: "relative",
        flex: "1 1 0%",
        ...styles.container
      };
      const { className, children, ...rest } = (0, import_system.omitThemingProps)(props);
      return (0, import_jsx_runtime.jsx)(StatStylesProvider, { value: styles, children: (0, import_jsx_runtime.jsx)(
        import_system.chakra.div,
        {
          ref,
          ...rest,
          className: (0, import_shared_utils.cx)("chakra-stat", className),
          __css: statStyles,
          children: (0, import_jsx_runtime.jsx)("dl", { children })
        }
      ) });
    });
    Stat.displayName = "Stat";
    var import_icon = require_dist18();
    var import_system2 = require_dist12();
    var import_jsx_runtime2 = require_jsx_runtime();
    var StatDownArrow = (props) => (0, import_jsx_runtime2.jsx)(import_icon.Icon, { color: "red.400", ...props, children: (0, import_jsx_runtime2.jsx)(
      "path",
      {
        fill: "currentColor",
        d: "M21,5H3C2.621,5,2.275,5.214,2.105,5.553C1.937,5.892,1.973,6.297,2.2,6.6l9,12 c0.188,0.252,0.485,0.4,0.8,0.4s0.611-0.148,0.8-0.4l9-12c0.228-0.303,0.264-0.708,0.095-1.047C21.725,5.214,21.379,5,21,5z"
      }
    ) });
    StatDownArrow.displayName = "StatDownArrow";
    function StatUpArrow(props) {
      return (0, import_jsx_runtime2.jsx)(import_icon.Icon, { color: "green.400", ...props, children: (0, import_jsx_runtime2.jsx)(
        "path",
        {
          fill: "currentColor",
          d: "M12.8,5.4c-0.377-0.504-1.223-0.504-1.6,0l-9,12c-0.228,0.303-0.264,0.708-0.095,1.047 C2.275,18.786,2.621,19,3,19h18c0.379,0,0.725-0.214,0.895-0.553c0.169-0.339,0.133-0.744-0.095-1.047L12.8,5.4z"
        }
      ) });
    }
    StatUpArrow.displayName = "StatUpArrow";
    function StatArrow(props) {
      const { type, "aria-label": ariaLabel, ...rest } = props;
      const styles = useStatStyles();
      const BaseIcon = type === "increase" ? StatUpArrow : StatDownArrow;
      const defaultAriaLabel = type === "increase" ? "increased by" : "decreased by";
      const label = ariaLabel || defaultAriaLabel;
      return (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
        (0, import_jsx_runtime2.jsx)(import_system2.chakra.span, { srOnly: true, children: label }),
        (0, import_jsx_runtime2.jsx)(BaseIcon, { "aria-hidden": true, ...rest, __css: styles.icon })
      ] });
    }
    StatArrow.displayName = "StatArrow";
    var import_shared_utils2 = require_dist3();
    var import_system3 = require_dist12();
    var import_jsx_runtime3 = require_jsx_runtime();
    var StatGroup = (0, import_system3.forwardRef)(function StatGroup2(props, ref) {
      return (0, import_jsx_runtime3.jsx)(
        import_system3.chakra.div,
        {
          ...props,
          ref,
          role: "group",
          className: (0, import_shared_utils2.cx)("chakra-stat__group", props.className),
          __css: {
            display: "flex",
            flexWrap: "wrap",
            justifyContent: "space-around",
            alignItems: "flex-start"
          }
        }
      );
    });
    StatGroup.displayName = "StatGroup";
    var import_shared_utils3 = require_dist3();
    var import_system4 = require_dist12();
    var import_jsx_runtime4 = require_jsx_runtime();
    var StatHelpText = (0, import_system4.forwardRef)(
      function StatHelpText2(props, ref) {
        const styles = useStatStyles();
        return (0, import_jsx_runtime4.jsx)(
          import_system4.chakra.dd,
          {
            ref,
            ...props,
            className: (0, import_shared_utils3.cx)("chakra-stat__help-text", props.className),
            __css: styles.helpText
          }
        );
      }
    );
    StatHelpText.displayName = "StatHelpText";
    var import_shared_utils4 = require_dist3();
    var import_system5 = require_dist12();
    var import_jsx_runtime5 = require_jsx_runtime();
    var StatLabel = (0, import_system5.forwardRef)(function StatLabel2(props, ref) {
      const styles = useStatStyles();
      return (0, import_jsx_runtime5.jsx)(
        import_system5.chakra.dt,
        {
          ref,
          ...props,
          className: (0, import_shared_utils4.cx)("chakra-stat__label", props.className),
          __css: styles.label
        }
      );
    });
    StatLabel.displayName = "StatLabel";
    var import_shared_utils5 = require_dist3();
    var import_system6 = require_dist12();
    var import_jsx_runtime6 = require_jsx_runtime();
    var StatNumber = (0, import_system6.forwardRef)(function StatNumber2(props, ref) {
      const styles = useStatStyles();
      return (0, import_jsx_runtime6.jsx)(
        import_system6.chakra.dd,
        {
          ref,
          ...props,
          className: (0, import_shared_utils5.cx)("chakra-stat__number", props.className),
          __css: {
            ...styles.number,
            fontFeatureSettings: "pnum",
            fontVariantNumeric: "proportional-nums"
          }
        }
      );
    });
    StatNumber.displayName = "StatNumber";
  }
});

// ../../node_modules/@chakra-ui/stepper/dist/index.js
var require_dist76 = __commonJS({
  "../../node_modules/@chakra-ui/stepper/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Step: () => Step,
      StepDescription: () => StepDescription,
      StepIcon: () => StepIcon,
      StepIndicator: () => StepIndicator,
      StepIndicatorContent: () => StepIndicatorContent,
      StepNumber: () => StepNumber,
      StepSeparator: () => StepSeparator,
      StepStatus: () => StepStatus,
      StepTitle: () => StepTitle,
      Stepper: () => Stepper,
      useStepContext: () => useStepContext,
      useStepperStyles: () => useStepperStyles,
      useSteps: () => useSteps
    });
    module.exports = __toCommonJS2(src_exports);
    var import_shared_utils = require_dist3();
    var import_system2 = require_dist12();
    var import_react_context = require_dist13();
    var import_system = require_dist12();
    var [StepContextProvider, useStepContext] = (0, import_react_context.createContext)(
      { name: "StepContext" }
    );
    var [StepperStylesProvider, useStepperStyles] = (0, import_system.createStylesContext)("Stepper");
    var import_jsx_runtime = require_jsx_runtime();
    var Step = (0, import_system2.forwardRef)(function Step2(props, ref) {
      const { orientation, status, showLastSeparator } = useStepContext();
      const styles = useStepperStyles();
      return (0, import_jsx_runtime.jsx)(
        import_system2.chakra.div,
        {
          ref,
          "data-status": status,
          "data-orientation": orientation,
          "data-stretch": (0, import_shared_utils.dataAttr)(showLastSeparator),
          __css: styles.step,
          ...props,
          className: (0, import_shared_utils.cx)("chakra-step", props.className)
        }
      );
    });
    var import_shared_utils2 = require_dist3();
    var import_system3 = require_dist12();
    var import_jsx_runtime2 = require_jsx_runtime();
    var StepDescription = (0, import_system3.forwardRef)(function StepDescription2(props, ref) {
      const { status } = useStepContext();
      const styles = useStepperStyles();
      return (0, import_jsx_runtime2.jsx)(
        import_system3.chakra.p,
        {
          ref,
          "data-status": status,
          ...props,
          className: (0, import_shared_utils2.cx)("chakra-step__description", props.className),
          __css: styles.description
        }
      );
    });
    var import_icon = require_dist18();
    var import_shared_utils3 = require_dist3();
    var import_jsx_runtime3 = require_jsx_runtime();
    function CheckIcon(props) {
      return (0, import_jsx_runtime3.jsx)(
        "svg",
        {
          stroke: "currentColor",
          fill: "currentColor",
          strokeWidth: "0",
          viewBox: "0 0 20 20",
          "aria-hidden": "true",
          height: "1em",
          width: "1em",
          ...props,
          children: (0, import_jsx_runtime3.jsx)(
            "path",
            {
              fillRule: "evenodd",
              d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
              clipRule: "evenodd"
            }
          )
        }
      );
    }
    var import_jsx_runtime4 = require_jsx_runtime();
    function StepIcon(props) {
      const { status } = useStepContext();
      const styles = useStepperStyles();
      const icon = status === "complete" ? CheckIcon : void 0;
      return (0, import_jsx_runtime4.jsx)(
        import_icon.Icon,
        {
          as: icon,
          __css: styles.icon,
          ...props,
          className: (0, import_shared_utils3.cx)("chakra-step__icon", props.className)
        }
      );
    }
    var import_shared_utils6 = require_dist3();
    var import_system5 = require_dist12();
    var import_shared_utils4 = require_dist3();
    var import_system4 = require_dist12();
    var import_jsx_runtime5 = require_jsx_runtime();
    var StepNumber = (0, import_system4.forwardRef)(function StepNumber2(props, ref) {
      const { children, ...restProps } = props;
      const { status, index } = useStepContext();
      const styles = useStepperStyles();
      return (0, import_jsx_runtime5.jsx)(
        import_system4.chakra.div,
        {
          ref,
          "data-status": status,
          __css: styles.number,
          ...restProps,
          className: (0, import_shared_utils4.cx)("chakra-step__number", props.className),
          children: children || index + 1
        }
      );
    });
    var import_shared_utils5 = require_dist3();
    var import_jsx_runtime6 = require_jsx_runtime();
    function StepStatus(props) {
      const { complete, incomplete, active } = props;
      const context = useStepContext();
      let render = null;
      switch (context.status) {
        case "complete":
          render = (0, import_shared_utils5.runIfFn)(complete, context);
          break;
        case "incomplete":
          render = (0, import_shared_utils5.runIfFn)(incomplete, context);
          break;
        case "active":
          render = (0, import_shared_utils5.runIfFn)(active, context);
          break;
      }
      return render ? (0, import_jsx_runtime6.jsx)(import_jsx_runtime6.Fragment, { children: render }) : null;
    }
    var import_jsx_runtime7 = require_jsx_runtime();
    function StepIndicator(props) {
      const { status } = useStepContext();
      const styles = useStepperStyles();
      return (0, import_jsx_runtime7.jsx)(
        import_system5.chakra.div,
        {
          "data-status": status,
          ...props,
          __css: styles.indicator,
          className: (0, import_shared_utils6.cx)("chakra-step__indicator", props.className)
        }
      );
    }
    function StepIndicatorContent() {
      return (0, import_jsx_runtime7.jsx)(
        StepStatus,
        {
          complete: (0, import_jsx_runtime7.jsx)(StepIcon, {}),
          incomplete: (0, import_jsx_runtime7.jsx)(StepNumber, {}),
          active: (0, import_jsx_runtime7.jsx)(StepNumber, {})
        }
      );
    }
    var import_shared_utils7 = require_dist3();
    var import_system6 = require_dist12();
    var import_jsx_runtime8 = require_jsx_runtime();
    var StepSeparator = (0, import_system6.forwardRef)(function StepSeparator2(props, ref) {
      const { orientation, status, isLast, showLastSeparator } = useStepContext();
      const styles = useStepperStyles();
      if (isLast && !showLastSeparator)
        return null;
      return (0, import_jsx_runtime8.jsx)(
        import_system6.chakra.div,
        {
          ref,
          role: "separator",
          "data-orientation": orientation,
          "data-status": status,
          __css: styles.separator,
          ...props,
          className: (0, import_shared_utils7.cx)("chakra-step__separator", props.className)
        }
      );
    });
    var import_shared_utils8 = require_dist3();
    var import_system7 = require_dist12();
    var import_jsx_runtime9 = require_jsx_runtime();
    var StepTitle = (0, import_system7.forwardRef)(function StepTitle2(props, ref) {
      const { status } = useStepContext();
      const styles = useStepperStyles();
      return (0, import_jsx_runtime9.jsx)(
        import_system7.chakra.h3,
        {
          ref,
          "data-status": status,
          ...props,
          __css: styles.title,
          className: (0, import_shared_utils8.cx)("chakra-step__title", props.className)
        }
      );
    });
    var import_shared_utils9 = require_dist3();
    var import_system8 = require_dist12();
    var import_react = require_react();
    var import_jsx_runtime10 = require_jsx_runtime();
    var Stepper = (0, import_system8.forwardRef)(function Stepper2(props, ref) {
      const styles = (0, import_system8.useMultiStyleConfig)("Stepper", props);
      const {
        children,
        index,
        orientation = "horizontal",
        showLastSeparator = false,
        ...restProps
      } = (0, import_system8.omitThemingProps)(props);
      const stepElements = import_react.Children.toArray(children);
      const stepCount = stepElements.length;
      function getStatus(step) {
        if (step < index)
          return "complete";
        if (step > index)
          return "incomplete";
        return "active";
      }
      return (0, import_jsx_runtime10.jsx)(
        import_system8.chakra.div,
        {
          ref,
          "aria-label": "Progress",
          "data-orientation": orientation,
          ...restProps,
          __css: styles.stepper,
          className: (0, import_shared_utils9.cx)("chakra-stepper", props.className),
          children: (0, import_jsx_runtime10.jsx)(StepperStylesProvider, { value: styles, children: stepElements.map((child, index2) => (0, import_jsx_runtime10.jsx)(
            StepContextProvider,
            {
              value: {
                index: index2,
                status: getStatus(index2),
                orientation,
                showLastSeparator,
                count: stepCount,
                isFirst: index2 === 0,
                isLast: index2 === stepCount - 1
              },
              children: child
            },
            index2
          )) })
        }
      );
    });
    var import_react2 = require_react();
    function useSteps(props = {}) {
      const { index = 0, count } = props;
      const [activeStep, setActiveStep] = (0, import_react2.useState)(index);
      const maxStep = typeof count === "number" ? count - 1 : 0;
      const activeStepPercent = activeStep / maxStep;
      return {
        activeStep,
        setActiveStep,
        activeStepPercent,
        isActiveStep(step) {
          return step === activeStep;
        },
        isCompleteStep(step) {
          return step < activeStep;
        },
        isIncompleteStep(step) {
          return step > activeStep;
        },
        getStatus(step) {
          if (step < activeStep)
            return "complete";
          if (step > activeStep)
            return "incomplete";
          return "active";
        },
        goToNext() {
          setActiveStep((step) => {
            return typeof count === "number" ? Math.min(count, step + 1) : step + 1;
          });
        },
        goToPrevious() {
          setActiveStep((step) => Math.max(0, step - 1));
        }
      };
    }
  }
});

// ../../node_modules/@chakra-ui/switch/dist/index.js
var require_dist77 = __commonJS({
  "../../node_modules/@chakra-ui/switch/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Switch: () => Switch
    });
    module.exports = __toCommonJS2(src_exports);
    var import_checkbox = require_dist33();
    var import_system = require_dist12();
    var import_shared_utils = require_dist3();
    var import_react = require_react();
    var import_jsx_runtime = require_jsx_runtime();
    var Switch = (0, import_system.forwardRef)(function Switch2(props, ref) {
      const styles = (0, import_system.useMultiStyleConfig)("Switch", props);
      const { spacing = "0.5rem", children, ...ownProps } = (0, import_system.omitThemingProps)(props);
      const {
        state,
        getInputProps,
        getCheckboxProps,
        getRootProps,
        getLabelProps
      } = (0, import_checkbox.useCheckbox)(ownProps);
      const containerStyles = (0, import_react.useMemo)(
        () => ({
          display: "inline-block",
          position: "relative",
          verticalAlign: "middle",
          lineHeight: 0,
          ...styles.container
        }),
        [styles.container]
      );
      const trackStyles = (0, import_react.useMemo)(
        () => ({
          display: "inline-flex",
          flexShrink: 0,
          justifyContent: "flex-start",
          boxSizing: "content-box",
          cursor: "pointer",
          ...styles.track
        }),
        [styles.track]
      );
      const labelStyles = (0, import_react.useMemo)(
        () => ({
          userSelect: "none",
          marginStart: spacing,
          ...styles.label
        }),
        [spacing, styles.label]
      );
      return (0, import_jsx_runtime.jsxs)(
        import_system.chakra.label,
        {
          ...getRootProps(),
          className: (0, import_shared_utils.cx)("chakra-switch", props.className),
          __css: containerStyles,
          children: [
            (0, import_jsx_runtime.jsx)("input", { className: "chakra-switch__input", ...getInputProps({}, ref) }),
            (0, import_jsx_runtime.jsx)(
              import_system.chakra.span,
              {
                ...getCheckboxProps(),
                className: "chakra-switch__track",
                __css: trackStyles,
                children: (0, import_jsx_runtime.jsx)(
                  import_system.chakra.span,
                  {
                    __css: styles.thumb,
                    className: "chakra-switch__thumb",
                    "data-checked": (0, import_shared_utils.dataAttr)(state.isChecked),
                    "data-hover": (0, import_shared_utils.dataAttr)(state.isHovered)
                  }
                )
              }
            ),
            children && (0, import_jsx_runtime.jsx)(
              import_system.chakra.span,
              {
                className: "chakra-switch__label",
                ...getLabelProps(),
                __css: labelStyles,
                children
              }
            )
          ]
        }
      );
    });
    Switch.displayName = "Switch";
  }
});

// ../../node_modules/@chakra-ui/table/dist/index.js
var require_dist78 = __commonJS({
  "../../node_modules/@chakra-ui/table/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Table: () => Table,
      TableCaption: () => TableCaption,
      TableContainer: () => TableContainer,
      Tbody: () => Tbody,
      Td: () => Td,
      Tfoot: () => Tfoot,
      Th: () => Th,
      Thead: () => Thead,
      Tr: () => Tr,
      useTableStyles: () => useTableStyles
    });
    module.exports = __toCommonJS2(src_exports);
    var import_system = require_dist12();
    var import_shared_utils = require_dist3();
    var import_react_context = require_dist13();
    var import_jsx_runtime = require_jsx_runtime();
    var [TableStylesProvider, useTableStyles] = (0, import_react_context.createContext)({
      name: `TableStylesContext`,
      errorMessage: `useTableStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Table />" `
    });
    var Table = (0, import_system.forwardRef)((props, ref) => {
      const styles = (0, import_system.useMultiStyleConfig)("Table", props);
      const { className, layout, ...tableProps } = (0, import_system.omitThemingProps)(props);
      return (0, import_jsx_runtime.jsx)(TableStylesProvider, { value: styles, children: (0, import_jsx_runtime.jsx)(
        import_system.chakra.table,
        {
          ref,
          __css: { tableLayout: layout, ...styles.table },
          className: (0, import_shared_utils.cx)("chakra-table", className),
          ...tableProps
        }
      ) });
    });
    Table.displayName = "Table";
    var import_system2 = require_dist12();
    var import_jsx_runtime2 = require_jsx_runtime();
    var TableCaption = (0, import_system2.forwardRef)(
      (props, ref) => {
        const { placement = "bottom", ...rest } = props;
        const styles = useTableStyles();
        return (0, import_jsx_runtime2.jsx)(
          import_system2.chakra.caption,
          {
            ...rest,
            ref,
            __css: {
              ...styles.caption,
              captionSide: placement
            }
          }
        );
      }
    );
    TableCaption.displayName = "TableCaption";
    var import_system3 = require_dist12();
    var import_shared_utils2 = require_dist3();
    var import_jsx_runtime3 = require_jsx_runtime();
    var TableContainer = (0, import_system3.forwardRef)(
      (props, ref) => {
        var _a;
        const { overflow, overflowX, className, ...rest } = props;
        return (0, import_jsx_runtime3.jsx)(
          import_system3.chakra.div,
          {
            ref,
            className: (0, import_shared_utils2.cx)("chakra-table__container", className),
            ...rest,
            __css: {
              display: "block",
              whiteSpace: "nowrap",
              WebkitOverflowScrolling: "touch",
              overflowX: (_a = overflow != null ? overflow : overflowX) != null ? _a : "auto",
              overflowY: "hidden",
              maxWidth: "100%"
            }
          }
        );
      }
    );
    var import_system4 = require_dist12();
    var import_jsx_runtime4 = require_jsx_runtime();
    var Tbody = (0, import_system4.forwardRef)((props, ref) => {
      const styles = useTableStyles();
      return (0, import_jsx_runtime4.jsx)(import_system4.chakra.tbody, { ...props, ref, __css: styles.tbody });
    });
    var import_system5 = require_dist12();
    var import_jsx_runtime5 = require_jsx_runtime();
    var Td = (0, import_system5.forwardRef)(
      ({ isNumeric, ...rest }, ref) => {
        const styles = useTableStyles();
        return (0, import_jsx_runtime5.jsx)(
          import_system5.chakra.td,
          {
            ...rest,
            ref,
            __css: styles.td,
            "data-is-numeric": isNumeric
          }
        );
      }
    );
    var import_system6 = require_dist12();
    var import_jsx_runtime6 = require_jsx_runtime();
    var Tfoot = (0, import_system6.forwardRef)((props, ref) => {
      const styles = useTableStyles();
      return (0, import_jsx_runtime6.jsx)(import_system6.chakra.tfoot, { ...props, ref, __css: styles.tfoot });
    });
    var import_system7 = require_dist12();
    var import_jsx_runtime7 = require_jsx_runtime();
    var Th = (0, import_system7.forwardRef)(
      ({ isNumeric, ...rest }, ref) => {
        const styles = useTableStyles();
        return (0, import_jsx_runtime7.jsx)(
          import_system7.chakra.th,
          {
            ...rest,
            ref,
            __css: styles.th,
            "data-is-numeric": isNumeric
          }
        );
      }
    );
    var import_system8 = require_dist12();
    var import_jsx_runtime8 = require_jsx_runtime();
    var Thead = (0, import_system8.forwardRef)((props, ref) => {
      const styles = useTableStyles();
      return (0, import_jsx_runtime8.jsx)(import_system8.chakra.thead, { ...props, ref, __css: styles.thead });
    });
    var import_system9 = require_dist12();
    var import_jsx_runtime9 = require_jsx_runtime();
    var Tr = (0, import_system9.forwardRef)((props, ref) => {
      const styles = useTableStyles();
      return (0, import_jsx_runtime9.jsx)(import_system9.chakra.tr, { ...props, ref, __css: styles.tr });
    });
  }
});

// ../../node_modules/@chakra-ui/tabs/dist/index.js
var require_dist79 = __commonJS({
  "../../node_modules/@chakra-ui/tabs/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Tab: () => Tab,
      TabIndicator: () => TabIndicator,
      TabList: () => TabList,
      TabPanel: () => TabPanel,
      TabPanels: () => TabPanels,
      Tabs: () => Tabs,
      TabsDescendantsProvider: () => TabsDescendantsProvider,
      TabsProvider: () => TabsProvider,
      useTab: () => useTab,
      useTabIndicator: () => useTabIndicator,
      useTabList: () => useTabList,
      useTabPanel: () => useTabPanel,
      useTabPanels: () => useTabPanels,
      useTabs: () => useTabs,
      useTabsContext: () => useTabsContext,
      useTabsDescendant: () => useTabsDescendant,
      useTabsDescendants: () => useTabsDescendants,
      useTabsDescendantsContext: () => useTabsDescendantsContext,
      useTabsStyles: () => useTabsStyles
    });
    module.exports = __toCommonJS2(src_exports);
    var import_shared_utils3 = require_dist3();
    var import_system2 = require_dist12();
    var import_react_context2 = require_dist13();
    var import_system = require_dist12();
    var import_shared_utils2 = require_dist3();
    var import_react2 = require_react();
    var import_clickable = require_dist50();
    var import_descendant = require_dist15();
    var import_react_context = require_dist13();
    var import_react_use_safe_layout_effect = require_dist();
    var import_react_use_controllable_state = require_dist17();
    var import_react_children_utils = require_dist24();
    var import_react_use_merge_refs = require_dist14();
    var import_lazy_utils = require_dist56();
    var import_shared_utils = require_dist3();
    var import_react = require_react();
    var [
      TabsDescendantsProvider,
      useTabsDescendantsContext,
      useTabsDescendants,
      useTabsDescendant
    ] = (0, import_descendant.createDescendantContext)();
    function useTabs(props) {
      var _a;
      const {
        defaultIndex,
        onChange,
        index,
        isManual,
        isLazy,
        lazyBehavior = "unmount",
        orientation = "horizontal",
        direction = "ltr",
        ...htmlProps
      } = props;
      const [focusedIndex, setFocusedIndex] = (0, import_react.useState)(defaultIndex != null ? defaultIndex : 0);
      const [selectedIndex, setSelectedIndex] = (0, import_react_use_controllable_state.useControllableState)({
        defaultValue: defaultIndex != null ? defaultIndex : 0,
        value: index,
        onChange
      });
      (0, import_react.useEffect)(() => {
        if (index != null) {
          setFocusedIndex(index);
        }
      }, [index]);
      const descendants = useTabsDescendants();
      const uuid = (0, import_react.useId)();
      const uid = (_a = props.id) != null ? _a : uuid;
      const id = `tabs-${uid}`;
      return {
        id,
        selectedIndex,
        focusedIndex,
        setSelectedIndex,
        setFocusedIndex,
        isManual,
        isLazy,
        lazyBehavior,
        orientation,
        descendants,
        direction,
        htmlProps
      };
    }
    var [TabsProvider, useTabsContext] = (0, import_react_context.createContext)({
      name: "TabsContext",
      errorMessage: "useTabsContext: `context` is undefined. Seems you forgot to wrap all tabs components within <Tabs />"
    });
    function useTabList(props) {
      const { focusedIndex, orientation, direction } = useTabsContext();
      const descendants = useTabsDescendantsContext();
      const onKeyDown = (0, import_react.useCallback)(
        (event) => {
          const nextTab = () => {
            var _a;
            const next = descendants.nextEnabled(focusedIndex);
            if (next)
              (_a = next.node) == null ? void 0 : _a.focus();
          };
          const prevTab = () => {
            var _a;
            const prev = descendants.prevEnabled(focusedIndex);
            if (prev)
              (_a = prev.node) == null ? void 0 : _a.focus();
          };
          const firstTab = () => {
            var _a;
            const first = descendants.firstEnabled();
            if (first)
              (_a = first.node) == null ? void 0 : _a.focus();
          };
          const lastTab = () => {
            var _a;
            const last = descendants.lastEnabled();
            if (last)
              (_a = last.node) == null ? void 0 : _a.focus();
          };
          const isHorizontal = orientation === "horizontal";
          const isVertical = orientation === "vertical";
          const eventKey = event.key;
          const ArrowStart = direction === "ltr" ? "ArrowLeft" : "ArrowRight";
          const ArrowEnd = direction === "ltr" ? "ArrowRight" : "ArrowLeft";
          const keyMap = {
            [ArrowStart]: () => isHorizontal && prevTab(),
            [ArrowEnd]: () => isHorizontal && nextTab(),
            ArrowDown: () => isVertical && nextTab(),
            ArrowUp: () => isVertical && prevTab(),
            Home: firstTab,
            End: lastTab
          };
          const action = keyMap[eventKey];
          if (action) {
            event.preventDefault();
            action(event);
          }
        },
        [descendants, focusedIndex, orientation, direction]
      );
      return {
        ...props,
        role: "tablist",
        "aria-orientation": orientation,
        onKeyDown: (0, import_shared_utils.callAllHandlers)(props.onKeyDown, onKeyDown)
      };
    }
    function useTab(props) {
      const { isDisabled, isFocusable, ...htmlProps } = props;
      const { setSelectedIndex, isManual, id, setFocusedIndex, selectedIndex } = useTabsContext();
      const { index, register } = useTabsDescendant({
        disabled: isDisabled && !isFocusable
      });
      const isSelected = index === selectedIndex;
      const onClick = () => {
        setSelectedIndex(index);
      };
      const onFocus = () => {
        setFocusedIndex(index);
        const isDisabledButFocusable = isDisabled && isFocusable;
        const shouldSelect = !isManual && !isDisabledButFocusable;
        if (shouldSelect) {
          setSelectedIndex(index);
        }
      };
      const clickableProps = (0, import_clickable.useClickable)({
        ...htmlProps,
        ref: (0, import_react_use_merge_refs.mergeRefs)(register, props.ref),
        isDisabled,
        isFocusable,
        onClick: (0, import_shared_utils.callAllHandlers)(props.onClick, onClick)
      });
      const type = "button";
      return {
        ...clickableProps,
        id: makeTabId(id, index),
        role: "tab",
        tabIndex: isSelected ? 0 : -1,
        type,
        "aria-selected": isSelected,
        "aria-controls": makeTabPanelId(id, index),
        onFocus: isDisabled ? void 0 : (0, import_shared_utils.callAllHandlers)(props.onFocus, onFocus)
      };
    }
    var [TabPanelProvider, useTabPanelContext] = (0, import_react_context.createContext)({});
    function useTabPanels(props) {
      const context = useTabsContext();
      const { id, selectedIndex } = context;
      const validChildren = (0, import_react_children_utils.getValidChildren)(props.children);
      const children = validChildren.map(
        (child, index) => (0, import_react.createElement)(
          TabPanelProvider,
          {
            key: index,
            value: {
              isSelected: index === selectedIndex,
              id: makeTabPanelId(id, index),
              tabId: makeTabId(id, index),
              selectedIndex
            }
          },
          child
        )
      );
      return { ...props, children };
    }
    function useTabPanel(props) {
      const { children, ...htmlProps } = props;
      const { isLazy, lazyBehavior } = useTabsContext();
      const { isSelected, id, tabId } = useTabPanelContext();
      const hasBeenSelected = (0, import_react.useRef)(false);
      if (isSelected) {
        hasBeenSelected.current = true;
      }
      const shouldRenderChildren = (0, import_lazy_utils.lazyDisclosure)({
        wasSelected: hasBeenSelected.current,
        isSelected,
        enabled: isLazy,
        mode: lazyBehavior
      });
      return {
        tabIndex: 0,
        ...htmlProps,
        children: shouldRenderChildren ? children : null,
        role: "tabpanel",
        "aria-labelledby": tabId,
        hidden: !isSelected,
        id
      };
    }
    function useTabIndicator() {
      const context = useTabsContext();
      const descendants = useTabsDescendantsContext();
      const { selectedIndex, orientation } = context;
      const isHorizontal = orientation === "horizontal";
      const isVertical = orientation === "vertical";
      const [rect, setRect] = (0, import_react.useState)(() => {
        if (isHorizontal)
          return { left: 0, width: 0 };
        if (isVertical)
          return { top: 0, height: 0 };
        return void 0;
      });
      const [hasMeasured, setHasMeasured] = (0, import_react.useState)(false);
      (0, import_react_use_safe_layout_effect.useSafeLayoutEffect)(() => {
        if (selectedIndex == null)
          return;
        const tab = descendants.item(selectedIndex);
        if (tab == null)
          return;
        if (isHorizontal) {
          setRect({ left: tab.node.offsetLeft, width: tab.node.offsetWidth });
        }
        if (isVertical) {
          setRect({ top: tab.node.offsetTop, height: tab.node.offsetHeight });
        }
        const id = requestAnimationFrame(() => {
          setHasMeasured(true);
        });
        return () => {
          if (id) {
            cancelAnimationFrame(id);
          }
        };
      }, [selectedIndex, isHorizontal, isVertical, descendants]);
      return {
        position: "absolute",
        transitionProperty: "left, right, top, bottom, height, width",
        transitionDuration: hasMeasured ? "200ms" : "0ms",
        transitionTimingFunction: "cubic-bezier(0, 0, 0.2, 1)",
        ...rect
      };
    }
    function makeTabId(id, index) {
      return `${id}--tab-${index}`;
    }
    function makeTabPanelId(id, index) {
      return `${id}--tabpanel-${index}`;
    }
    var import_jsx_runtime = require_jsx_runtime();
    var [TabsStylesProvider, useTabsStyles] = (0, import_react_context2.createContext)({
      name: `TabsStylesContext`,
      errorMessage: `useTabsStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Tabs />" `
    });
    var Tabs = (0, import_system.forwardRef)(function Tabs2(props, ref) {
      const styles = (0, import_system.useMultiStyleConfig)("Tabs", props);
      const { children, className, ...rest } = (0, import_system.omitThemingProps)(props);
      const { htmlProps, descendants, ...ctx } = useTabs(rest);
      const context = (0, import_react2.useMemo)(() => ctx, [ctx]);
      const { isFitted: _, ...rootProps } = htmlProps;
      return (0, import_jsx_runtime.jsx)(TabsDescendantsProvider, { value: descendants, children: (0, import_jsx_runtime.jsx)(TabsProvider, { value: context, children: (0, import_jsx_runtime.jsx)(TabsStylesProvider, { value: styles, children: (0, import_jsx_runtime.jsx)(
        import_system.chakra.div,
        {
          className: (0, import_shared_utils2.cx)("chakra-tabs", className),
          ref,
          ...rootProps,
          __css: styles.root,
          children
        }
      ) }) }) });
    });
    Tabs.displayName = "Tabs";
    var import_jsx_runtime2 = require_jsx_runtime();
    var Tab = (0, import_system2.forwardRef)(function Tab2(props, ref) {
      const styles = useTabsStyles();
      const tabProps = useTab({ ...props, ref });
      const tabStyles = {
        outline: "0",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        ...styles.tab
      };
      return (0, import_jsx_runtime2.jsx)(
        import_system2.chakra.button,
        {
          ...tabProps,
          className: (0, import_shared_utils3.cx)("chakra-tabs__tab", props.className),
          __css: tabStyles
        }
      );
    });
    Tab.displayName = "Tab";
    var import_shared_utils4 = require_dist3();
    var import_system3 = require_dist12();
    var import_jsx_runtime3 = require_jsx_runtime();
    var TabIndicator = (0, import_system3.forwardRef)(
      function TabIndicator2(props, ref) {
        const indicatorStyle = useTabIndicator();
        const style = {
          ...props.style,
          ...indicatorStyle
        };
        const styles = useTabsStyles();
        return (0, import_jsx_runtime3.jsx)(
          import_system3.chakra.div,
          {
            ref,
            ...props,
            className: (0, import_shared_utils4.cx)("chakra-tabs__tab-indicator", props.className),
            style,
            __css: styles.indicator
          }
        );
      }
    );
    TabIndicator.displayName = "TabIndicator";
    var import_shared_utils5 = require_dist3();
    var import_system4 = require_dist12();
    var import_jsx_runtime4 = require_jsx_runtime();
    var TabList = (0, import_system4.forwardRef)(function TabList2(props, ref) {
      const tablistProps = useTabList({ ...props, ref });
      const styles = useTabsStyles();
      const tablistStyles = {
        display: "flex",
        ...styles.tablist
      };
      return (0, import_jsx_runtime4.jsx)(
        import_system4.chakra.div,
        {
          ...tablistProps,
          className: (0, import_shared_utils5.cx)("chakra-tabs__tablist", props.className),
          __css: tablistStyles
        }
      );
    });
    TabList.displayName = "TabList";
    var import_shared_utils6 = require_dist3();
    var import_system5 = require_dist12();
    var import_jsx_runtime5 = require_jsx_runtime();
    var TabPanel = (0, import_system5.forwardRef)(function TabPanel2(props, ref) {
      const panelProps = useTabPanel({ ...props, ref });
      const styles = useTabsStyles();
      return (0, import_jsx_runtime5.jsx)(
        import_system5.chakra.div,
        {
          outline: "0",
          ...panelProps,
          className: (0, import_shared_utils6.cx)("chakra-tabs__tab-panel", props.className),
          __css: styles.tabpanel
        }
      );
    });
    TabPanel.displayName = "TabPanel";
    var import_shared_utils7 = require_dist3();
    var import_system6 = require_dist12();
    var import_jsx_runtime6 = require_jsx_runtime();
    var TabPanels = (0, import_system6.forwardRef)(function TabPanels2(props, ref) {
      const panelsProps = useTabPanels(props);
      const styles = useTabsStyles();
      return (0, import_jsx_runtime6.jsx)(
        import_system6.chakra.div,
        {
          ...panelsProps,
          width: "100%",
          ref,
          className: (0, import_shared_utils7.cx)("chakra-tabs__tab-panels", props.className),
          __css: styles.tabpanels
        }
      );
    });
    TabPanels.displayName = "TabPanels";
  }
});

// ../../node_modules/@chakra-ui/tag/dist/index.js
var require_dist80 = __commonJS({
  "../../node_modules/@chakra-ui/tag/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Tag: () => Tag,
      TagCloseButton: () => TagCloseButton,
      TagLabel: () => TagLabel,
      TagLeftIcon: () => TagLeftIcon,
      TagRightIcon: () => TagRightIcon,
      useTagStyles: () => useTagStyles
    });
    module.exports = __toCommonJS2(src_exports);
    var import_icon = require_dist18();
    var import_react_context = require_dist13();
    var import_system = require_dist12();
    var import_jsx_runtime = require_jsx_runtime();
    var [TagStylesProvider, useTagStyles] = (0, import_react_context.createContext)({
      name: `TagStylesContext`,
      errorMessage: `useTagStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Tag />" `
    });
    var Tag = (0, import_system.forwardRef)((props, ref) => {
      const styles = (0, import_system.useMultiStyleConfig)("Tag", props);
      const ownProps = (0, import_system.omitThemingProps)(props);
      const containerStyles = {
        display: "inline-flex",
        verticalAlign: "top",
        alignItems: "center",
        maxWidth: "100%",
        ...styles.container
      };
      return (0, import_jsx_runtime.jsx)(TagStylesProvider, { value: styles, children: (0, import_jsx_runtime.jsx)(import_system.chakra.span, { ref, ...ownProps, __css: containerStyles }) });
    });
    Tag.displayName = "Tag";
    var TagLabel = (0, import_system.forwardRef)((props, ref) => {
      const styles = useTagStyles();
      return (0, import_jsx_runtime.jsx)(import_system.chakra.span, { ref, noOfLines: 1, ...props, __css: styles.label });
    });
    TagLabel.displayName = "TagLabel";
    var TagLeftIcon = (0, import_system.forwardRef)((props, ref) => (0, import_jsx_runtime.jsx)(import_icon.Icon, { ref, verticalAlign: "top", marginEnd: "0.5rem", ...props }));
    TagLeftIcon.displayName = "TagLeftIcon";
    var TagRightIcon = (0, import_system.forwardRef)((props, ref) => (0, import_jsx_runtime.jsx)(import_icon.Icon, { ref, verticalAlign: "top", marginStart: "0.5rem", ...props }));
    TagRightIcon.displayName = "TagRightIcon";
    var TagCloseIcon = (props) => (0, import_jsx_runtime.jsx)(import_icon.Icon, { verticalAlign: "inherit", viewBox: "0 0 512 512", ...props, children: (0, import_jsx_runtime.jsx)(
      "path",
      {
        fill: "currentColor",
        d: "M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z"
      }
    ) });
    TagCloseIcon.displayName = "TagCloseIcon";
    var TagCloseButton = (0, import_system.forwardRef)(
      (props, ref) => {
        const { isDisabled, children, ...rest } = props;
        const styles = useTagStyles();
        const btnStyles = {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          outline: "0",
          ...styles.closeButton
        };
        return (0, import_jsx_runtime.jsx)(
          import_system.chakra.button,
          {
            ref,
            "aria-label": "close",
            ...rest,
            type: "button",
            disabled: isDisabled,
            __css: btnStyles,
            children: children || (0, import_jsx_runtime.jsx)(TagCloseIcon, {})
          }
        );
      }
    );
    TagCloseButton.displayName = "TagCloseButton";
  }
});

// ../../node_modules/@chakra-ui/textarea/dist/index.js
var require_dist81 = __commonJS({
  "../../node_modules/@chakra-ui/textarea/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Textarea: () => Textarea
    });
    module.exports = __toCommonJS2(src_exports);
    var import_form_control = require_dist29();
    var import_system = require_dist12();
    var import_shared_utils = require_dist3();
    function omit(object, keysToOmit = []) {
      const clone = Object.assign({}, object);
      for (const key of keysToOmit) {
        if (key in clone) {
          delete clone[key];
        }
      }
      return clone;
    }
    var import_jsx_runtime = require_jsx_runtime();
    var omitted = ["h", "minH", "height", "minHeight"];
    var Textarea = (0, import_system.forwardRef)((props, ref) => {
      const styles = (0, import_system.useStyleConfig)("Textarea", props);
      const { className, rows, ...rest } = (0, import_system.omitThemingProps)(props);
      const textareaProps = (0, import_form_control.useFormControl)(rest);
      const textareaStyles = rows ? omit(styles, omitted) : styles;
      return (0, import_jsx_runtime.jsx)(
        import_system.chakra.textarea,
        {
          ref,
          rows,
          ...textareaProps,
          className: (0, import_shared_utils.cx)("chakra-textarea", className),
          __css: textareaStyles
        }
      );
    });
    Textarea.displayName = "Textarea";
  }
});

// ../../node_modules/@chakra-ui/react-use-timeout/dist/index.js
var require_dist82 = __commonJS({
  "../../node_modules/@chakra-ui/react-use-timeout/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      useTimeout: () => useTimeout
    });
    module.exports = __toCommonJS2(src_exports);
    var import_react = require_react();
    var import_react_use_callback_ref = require_dist16();
    function useTimeout(callback, delay) {
      const fn = (0, import_react_use_callback_ref.useCallbackRef)(callback);
      (0, import_react.useEffect)(() => {
        if (delay == null)
          return void 0;
        let timeoutId = null;
        timeoutId = window.setTimeout(() => {
          fn();
        }, delay);
        return () => {
          if (timeoutId) {
            window.clearTimeout(timeoutId);
          }
        };
      }, [delay, fn]);
    }
  }
});

// ../../node_modules/@chakra-ui/toast/dist/index.js
var require_dist83 = __commonJS({
  "../../node_modules/@chakra-ui/toast/dist/index.js"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Toast: () => Toast,
      ToastOptionProvider: () => ToastOptionProvider,
      ToastProvider: () => ToastProvider,
      createRenderToast: () => createRenderToast,
      createStandaloneToast: () => createStandaloneToast,
      createToastFn: () => createToastFn,
      getToastPlacement: () => getToastPlacement,
      useToast: () => useToast
    });
    module.exports = __toCommonJS2(src_exports);
    var import_system3 = require_dist12();
    var import_alert = require_dist22();
    var import_system = require_dist12();
    var import_close_button = require_dist34();
    var import_shared_utils = require_dist3();
    function getToastPlacement(position, dir) {
      var _a;
      const computedPosition = position != null ? position : "bottom";
      const logicals = {
        "top-start": { ltr: "top-left", rtl: "top-right" },
        "top-end": { ltr: "top-right", rtl: "top-left" },
        "bottom-start": { ltr: "bottom-left", rtl: "bottom-right" },
        "bottom-end": { ltr: "bottom-right", rtl: "bottom-left" }
      };
      const logical = logicals[computedPosition];
      return (_a = logical == null ? void 0 : logical[dir]) != null ? _a : computedPosition;
    }
    var findById = (arr, id) => arr.find((toast) => toast.id === id);
    function findToast(toasts, id) {
      const position = getToastPosition(toasts, id);
      const index = position ? toasts[position].findIndex((toast) => toast.id === id) : -1;
      return {
        position,
        index
      };
    }
    function getToastPosition(toasts, id) {
      for (const [position, values] of Object.entries(toasts)) {
        if (findById(values, id)) {
          return position;
        }
      }
    }
    function getToastStyle(position) {
      const isRighty = position.includes("right");
      const isLefty = position.includes("left");
      let alignItems = "center";
      if (isRighty)
        alignItems = "flex-end";
      if (isLefty)
        alignItems = "flex-start";
      return {
        display: "flex",
        flexDirection: "column",
        alignItems
      };
    }
    function getToastListStyle(position) {
      const isTopOrBottom = position === "top" || position === "bottom";
      const margin = isTopOrBottom ? "0 auto" : void 0;
      const top = position.includes("top") ? "env(safe-area-inset-top, 0px)" : void 0;
      const bottom = position.includes("bottom") ? "env(safe-area-inset-bottom, 0px)" : void 0;
      const right = !position.includes("left") ? "env(safe-area-inset-right, 0px)" : void 0;
      const left = !position.includes("right") ? "env(safe-area-inset-left, 0px)" : void 0;
      return {
        position: "fixed",
        zIndex: "var(--toast-z-index, 5500)",
        pointerEvents: "none",
        display: "flex",
        flexDirection: "column",
        margin,
        top,
        bottom,
        right,
        left
      };
    }
    var initialState = {
      top: [],
      "top-left": [],
      "top-right": [],
      "bottom-left": [],
      bottom: [],
      "bottom-right": []
    };
    var toastStore = createStore(initialState);
    function createStore(initialState2) {
      let state = initialState2;
      const listeners = /* @__PURE__ */ new Set();
      const setState = (setStateFn) => {
        state = setStateFn(state);
        listeners.forEach((l) => l());
      };
      return {
        getState: () => state,
        subscribe: (listener) => {
          listeners.add(listener);
          return () => {
            setState(() => initialState2);
            listeners.delete(listener);
          };
        },
        removeToast: (id, position) => {
          setState((prevState) => ({
            ...prevState,
            [position]: prevState[position].filter((toast) => toast.id != id)
          }));
        },
        notify: (message, options) => {
          const toast = createToast(message, options);
          const { position, id } = toast;
          setState((prevToasts) => {
            var _a, _b;
            const isTop = position.includes("top");
            const toasts = isTop ? [toast, ...(_a = prevToasts[position]) != null ? _a : []] : [...(_b = prevToasts[position]) != null ? _b : [], toast];
            return {
              ...prevToasts,
              [position]: toasts
            };
          });
          return id;
        },
        update: (id, options) => {
          if (!id)
            return;
          setState((prevState) => {
            const nextState = { ...prevState };
            const { position, index } = findToast(nextState, id);
            if (position && index !== -1) {
              nextState[position][index] = {
                ...nextState[position][index],
                ...options,
                message: createRenderToast(options)
              };
            }
            return nextState;
          });
        },
        closeAll: ({ positions } = {}) => {
          setState((prev) => {
            const allPositions = [
              "bottom",
              "bottom-right",
              "bottom-left",
              "top",
              "top-left",
              "top-right"
            ];
            const positionsToClose = positions != null ? positions : allPositions;
            return positionsToClose.reduce(
              (acc, position) => {
                acc[position] = prev[position].map((toast) => ({
                  ...toast,
                  requestClose: true
                }));
                return acc;
              },
              { ...prev }
            );
          });
        },
        close: (id) => {
          setState((prevState) => {
            const position = getToastPosition(prevState, id);
            if (!position)
              return prevState;
            return {
              ...prevState,
              [position]: prevState[position].map((toast) => {
                if (toast.id == id) {
                  return {
                    ...toast,
                    requestClose: true
                  };
                }
                return toast;
              })
            };
          });
        },
        isActive: (id) => Boolean(findToast(toastStore.getState(), id).position)
      };
    }
    var counter = 0;
    function createToast(message, options = {}) {
      var _a, _b;
      counter += 1;
      const id = (_a = options.id) != null ? _a : counter;
      const position = (_b = options.position) != null ? _b : "bottom";
      return {
        id,
        message,
        position,
        duration: options.duration,
        onCloseComplete: options.onCloseComplete,
        onRequestRemove: () => toastStore.removeToast(String(id), position),
        status: options.status,
        requestClose: false,
        containerStyle: options.containerStyle
      };
    }
    var import_jsx_runtime = require_jsx_runtime();
    var Toast = (props) => {
      const {
        status,
        variant = "solid",
        id,
        title,
        isClosable,
        onClose,
        description,
        colorScheme,
        icon
      } = props;
      const ids = id ? {
        root: `toast-${id}`,
        title: `toast-${id}-title`,
        description: `toast-${id}-description`
      } : void 0;
      return (0, import_jsx_runtime.jsxs)(
        import_alert.Alert,
        {
          addRole: false,
          status,
          variant,
          id: ids == null ? void 0 : ids.root,
          alignItems: "start",
          borderRadius: "md",
          boxShadow: "lg",
          paddingEnd: 8,
          textAlign: "start",
          width: "auto",
          colorScheme,
          children: [
            (0, import_jsx_runtime.jsx)(import_alert.AlertIcon, { children: icon }),
            (0, import_jsx_runtime.jsxs)(import_system.chakra.div, { flex: "1", maxWidth: "100%", children: [
              title && (0, import_jsx_runtime.jsx)(import_alert.AlertTitle, { id: ids == null ? void 0 : ids.title, children: title }),
              description && (0, import_jsx_runtime.jsx)(import_alert.AlertDescription, { id: ids == null ? void 0 : ids.description, display: "block", children: description })
            ] }),
            isClosable && (0, import_jsx_runtime.jsx)(
              import_close_button.CloseButton,
              {
                size: "sm",
                onClick: onClose,
                position: "absolute",
                insetEnd: 1,
                top: 1
              }
            )
          ]
        }
      );
    };
    function createRenderToast(options = {}) {
      const { render, toastComponent: ToastComponent2 = Toast } = options;
      const renderToast = (props) => {
        if (typeof render === "function") {
          return render({ ...props, ...options });
        }
        return (0, import_jsx_runtime.jsx)(ToastComponent2, { ...props, ...options });
      };
      return renderToast;
    }
    function createToastFn(dir, defaultOptions) {
      const normalizeToastOptions = (options) => {
        var _a;
        return {
          ...defaultOptions,
          ...options,
          position: getToastPlacement(
            (_a = options == null ? void 0 : options.position) != null ? _a : defaultOptions == null ? void 0 : defaultOptions.position,
            dir
          )
        };
      };
      const toast = (options) => {
        const normalizedToastOptions = normalizeToastOptions(options);
        const Message = createRenderToast(normalizedToastOptions);
        return toastStore.notify(Message, normalizedToastOptions);
      };
      toast.update = (id, options) => {
        toastStore.update(id, normalizeToastOptions(options));
      };
      toast.promise = (promise, options) => {
        const id = toast({
          ...options.loading,
          status: "loading",
          duration: null
        });
        promise.then(
          (data) => toast.update(id, {
            status: "success",
            duration: 5e3,
            ...(0, import_shared_utils.runIfFn)(options.success, data)
          })
        ).catch(
          (error) => toast.update(id, {
            status: "error",
            duration: 5e3,
            ...(0, import_shared_utils.runIfFn)(options.error, error)
          })
        );
      };
      toast.closeAll = toastStore.closeAll;
      toast.close = toastStore.close;
      toast.isActive = toastStore.isActive;
      return toast;
    }
    var import_react3 = require_react();
    var import_framer_motion2 = require_cjs();
    var import_portal = require_dist58();
    var import_react_use_timeout = require_dist82();
    var import_react_use_update_effect = require_dist30();
    var import_shared_utils2 = require_dist3();
    var import_framer_motion = require_cjs();
    var import_system2 = require_dist12();
    var import_react = require_react();
    var import_jsx_runtime2 = require_jsx_runtime();
    var toastMotionVariants = {
      initial: (props) => {
        const { position } = props;
        const dir = ["top", "bottom"].includes(position) ? "y" : "x";
        let factor = ["top-right", "bottom-right"].includes(position) ? 1 : -1;
        if (position === "bottom")
          factor = 1;
        return {
          opacity: 0,
          [dir]: factor * 24
        };
      },
      animate: {
        opacity: 1,
        y: 0,
        x: 0,
        scale: 1,
        transition: {
          duration: 0.4,
          ease: [0.4, 0, 0.2, 1]
        }
      },
      exit: {
        opacity: 0,
        scale: 0.85,
        transition: {
          duration: 0.2,
          ease: [0.4, 0, 1, 1]
        }
      }
    };
    var ToastComponent = (0, import_react.memo)((props) => {
      const {
        id,
        message,
        onCloseComplete,
        onRequestRemove,
        requestClose = false,
        position = "bottom",
        duration = 5e3,
        containerStyle,
        motionVariants = toastMotionVariants,
        toastSpacing = "0.5rem"
      } = props;
      const [delay, setDelay] = (0, import_react.useState)(duration);
      const isPresent = (0, import_framer_motion.useIsPresent)();
      (0, import_react_use_update_effect.useUpdateEffect)(() => {
        if (!isPresent) {
          onCloseComplete == null ? void 0 : onCloseComplete();
        }
      }, [isPresent]);
      (0, import_react_use_update_effect.useUpdateEffect)(() => {
        setDelay(duration);
      }, [duration]);
      const onMouseEnter = () => setDelay(null);
      const onMouseLeave = () => setDelay(duration);
      const close = () => {
        if (isPresent)
          onRequestRemove();
      };
      (0, import_react.useEffect)(() => {
        if (isPresent && requestClose) {
          onRequestRemove();
        }
      }, [isPresent, requestClose, onRequestRemove]);
      (0, import_react_use_timeout.useTimeout)(close, delay);
      const containerStyles = (0, import_react.useMemo)(
        () => ({
          pointerEvents: "auto",
          maxWidth: 560,
          minWidth: 300,
          margin: toastSpacing,
          ...containerStyle
        }),
        [containerStyle, toastSpacing]
      );
      const toastStyle = (0, import_react.useMemo)(() => getToastStyle(position), [position]);
      return (0, import_jsx_runtime2.jsx)(
        import_framer_motion.motion.div,
        {
          layout: true,
          className: "chakra-toast",
          variants: motionVariants,
          initial: "initial",
          animate: "animate",
          exit: "exit",
          onHoverStart: onMouseEnter,
          onHoverEnd: onMouseLeave,
          custom: { position },
          style: toastStyle,
          children: (0, import_jsx_runtime2.jsx)(
            import_system2.chakra.div,
            {
              role: "status",
              "aria-atomic": "true",
              className: "chakra-toast__inner",
              __css: containerStyles,
              children: (0, import_shared_utils2.runIfFn)(message, { id, onClose: close })
            }
          )
        }
      );
    });
    ToastComponent.displayName = "ToastComponent";
    var import_react2 = require_react();
    var import_react_context = require_dist13();
    var import_jsx_runtime3 = require_jsx_runtime();
    var [ToastOptionProvider, useToastOptionContext] = (0, import_react_context.createContext)({
      name: `ToastOptionsContext`,
      strict: false
    });
    var ToastProvider = (props) => {
      const state = (0, import_react2.useSyncExternalStore)(
        toastStore.subscribe,
        toastStore.getState,
        toastStore.getState
      );
      const {
        motionVariants,
        component: Component = ToastComponent,
        portalProps
      } = props;
      const stateKeys = Object.keys(state);
      const toastList = stateKeys.map((position) => {
        const toasts = state[position];
        return (0, import_jsx_runtime3.jsx)(
          "div",
          {
            role: "region",
            "aria-live": "polite",
            id: `chakra-toast-manager-${position}`,
            style: getToastListStyle(position),
            children: (0, import_jsx_runtime3.jsx)(import_framer_motion2.AnimatePresence, { initial: false, children: toasts.map((toast) => (0, import_jsx_runtime3.jsx)(
              Component,
              {
                motionVariants,
                ...toast
              },
              toast.id
            )) })
          },
          position
        );
      });
      return (0, import_jsx_runtime3.jsx)(import_portal.Portal, { ...portalProps, children: toastList });
    };
    function useToast(options) {
      const { theme } = (0, import_system3.useChakra)();
      const defaultOptions = useToastOptionContext();
      return (0, import_react3.useMemo)(
        () => createToastFn(theme.direction, {
          ...defaultOptions,
          ...options
        }),
        [options, theme.direction, defaultOptions]
      );
    }
    var import_system4 = require_dist12();
    var import_theme = __toESM(require_dist10());
    var import_jsx_runtime4 = require_jsx_runtime();
    var defaults = {
      duration: 5e3,
      variant: "solid"
    };
    var defaultStandaloneParam = {
      theme: import_theme.default,
      colorMode: "light",
      toggleColorMode: () => {
      },
      setColorMode: () => {
      },
      defaultOptions: defaults,
      forced: false
    };
    function createStandaloneToast({
      theme = defaultStandaloneParam.theme,
      colorMode = defaultStandaloneParam.colorMode,
      toggleColorMode = defaultStandaloneParam.toggleColorMode,
      setColorMode = defaultStandaloneParam.setColorMode,
      defaultOptions = defaultStandaloneParam.defaultOptions,
      motionVariants,
      toastSpacing,
      component,
      forced
    } = defaultStandaloneParam) {
      const colorModeContextValue = {
        colorMode,
        setColorMode,
        toggleColorMode,
        forced
      };
      const ToastContainer = () => (0, import_jsx_runtime4.jsx)(import_system4.ThemeProvider, { theme, children: (0, import_jsx_runtime4.jsx)(import_system4.ColorModeContext.Provider, { value: colorModeContextValue, children: (0, import_jsx_runtime4.jsx)(
        ToastProvider,
        {
          defaultOptions,
          motionVariants,
          toastSpacing,
          component
        }
      ) }) });
      return {
        ToastContainer,
        toast: createToastFn(theme.direction, defaultOptions)
      };
    }
  }
});

// ../../node_modules/@chakra-ui/tooltip/dist/index.js
var require_dist84 = __commonJS({
  "../../node_modules/@chakra-ui/tooltip/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      Tooltip: () => Tooltip,
      useTooltip: () => useTooltip
    });
    module.exports = __toCommonJS2(src_exports);
    var import_popper2 = require_dist52();
    var import_portal = require_dist58();
    var import_system = require_dist12();
    function omit(object, keysToOmit = []) {
      const clone = Object.assign({}, object);
      for (const key of keysToOmit) {
        if (key in clone) {
          delete clone[key];
        }
      }
      return clone;
    }
    function pick(object, keysToPick) {
      const result = {};
      for (const key of keysToPick) {
        if (key in object) {
          result[key] = object[key];
        }
      }
      return result;
    }
    var import_framer_motion = require_cjs();
    var import_react2 = require_react();
    var scale = {
      exit: {
        scale: 0.85,
        opacity: 0,
        transition: {
          opacity: { duration: 0.15, easings: "easeInOut" },
          scale: { duration: 0.2, easings: "easeInOut" }
        }
      },
      enter: {
        scale: 1,
        opacity: 1,
        transition: {
          opacity: { easings: "easeOut", duration: 0.2 },
          scale: { duration: 0.2, ease: [0.175, 0.885, 0.4, 1.1] }
        }
      }
    };
    var import_react_use_event_listener = require_dist39();
    var import_react_use_disclosure = require_dist53();
    var import_popper = require_dist52();
    var import_react_use_merge_refs = require_dist14();
    var import_shared_utils = require_dist3();
    var import_react = require_react();
    var getDoc = (ref) => {
      var _a;
      return ((_a = ref.current) == null ? void 0 : _a.ownerDocument) || document;
    };
    var getWin = (ref) => {
      var _a, _b;
      return ((_b = (_a = ref.current) == null ? void 0 : _a.ownerDocument) == null ? void 0 : _b.defaultView) || window;
    };
    function useTooltip(props = {}) {
      const {
        openDelay = 0,
        closeDelay = 0,
        closeOnClick = true,
        closeOnMouseDown,
        closeOnScroll,
        closeOnPointerDown = closeOnMouseDown,
        closeOnEsc = true,
        onOpen: onOpenProp,
        onClose: onCloseProp,
        placement,
        id,
        isOpen: isOpenProp,
        defaultIsOpen,
        arrowSize = 10,
        arrowShadowColor,
        arrowPadding,
        modifiers,
        isDisabled,
        gutter,
        offset,
        direction,
        ...htmlProps
      } = props;
      const { isOpen, onOpen, onClose } = (0, import_react_use_disclosure.useDisclosure)({
        isOpen: isOpenProp,
        defaultIsOpen,
        onOpen: onOpenProp,
        onClose: onCloseProp
      });
      const { referenceRef, getPopperProps, getArrowInnerProps, getArrowProps } = (0, import_popper.usePopper)({
        enabled: isOpen,
        placement,
        arrowPadding,
        modifiers,
        gutter,
        offset,
        direction
      });
      const uuid = (0, import_react.useId)();
      const uid = id != null ? id : uuid;
      const tooltipId = `tooltip-${uid}`;
      const ref = (0, import_react.useRef)(null);
      const enterTimeout = (0, import_react.useRef)();
      const clearEnterTimeout = (0, import_react.useCallback)(() => {
        if (enterTimeout.current) {
          clearTimeout(enterTimeout.current);
          enterTimeout.current = void 0;
        }
      }, []);
      const exitTimeout = (0, import_react.useRef)();
      const clearExitTimeout = (0, import_react.useCallback)(() => {
        if (exitTimeout.current) {
          clearTimeout(exitTimeout.current);
          exitTimeout.current = void 0;
        }
      }, []);
      const closeNow = (0, import_react.useCallback)(() => {
        clearExitTimeout();
        onClose();
      }, [onClose, clearExitTimeout]);
      const dispatchCloseEvent = useCloseEvent(ref, closeNow);
      const openWithDelay = (0, import_react.useCallback)(() => {
        if (!isDisabled && !enterTimeout.current) {
          dispatchCloseEvent();
          const win = getWin(ref);
          enterTimeout.current = win.setTimeout(onOpen, openDelay);
        }
      }, [dispatchCloseEvent, isDisabled, onOpen, openDelay]);
      const closeWithDelay = (0, import_react.useCallback)(() => {
        clearEnterTimeout();
        const win = getWin(ref);
        exitTimeout.current = win.setTimeout(closeNow, closeDelay);
      }, [closeDelay, closeNow, clearEnterTimeout]);
      const onClick = (0, import_react.useCallback)(() => {
        if (isOpen && closeOnClick) {
          closeWithDelay();
        }
      }, [closeOnClick, closeWithDelay, isOpen]);
      const onPointerDown = (0, import_react.useCallback)(() => {
        if (isOpen && closeOnPointerDown) {
          closeWithDelay();
        }
      }, [closeOnPointerDown, closeWithDelay, isOpen]);
      const onKeyDown = (0, import_react.useCallback)(
        (event) => {
          if (isOpen && event.key === "Escape") {
            closeWithDelay();
          }
        },
        [isOpen, closeWithDelay]
      );
      (0, import_react_use_event_listener.useEventListener)(
        () => getDoc(ref),
        "keydown",
        closeOnEsc ? onKeyDown : void 0
      );
      (0, import_react_use_event_listener.useEventListener)(
        () => getDoc(ref),
        "scroll",
        () => {
          if (isOpen && closeOnScroll) {
            closeNow();
          }
        }
      );
      (0, import_react.useEffect)(() => {
        if (!isDisabled)
          return;
        clearEnterTimeout();
        if (isOpen)
          onClose();
      }, [isDisabled, isOpen, onClose, clearEnterTimeout]);
      (0, import_react.useEffect)(
        () => () => {
          clearEnterTimeout();
          clearExitTimeout();
        },
        [clearEnterTimeout, clearExitTimeout]
      );
      (0, import_react_use_event_listener.useEventListener)(() => ref.current, "pointerleave", closeWithDelay);
      const getTriggerProps = (0, import_react.useCallback)(
        (props2 = {}, _ref = null) => {
          const triggerProps = {
            ...props2,
            ref: (0, import_react_use_merge_refs.mergeRefs)(ref, _ref, referenceRef),
            onPointerEnter: (0, import_shared_utils.callAllHandlers)(props2.onPointerEnter, (e) => {
              if (e.pointerType === "touch")
                return;
              openWithDelay();
            }),
            onClick: (0, import_shared_utils.callAllHandlers)(props2.onClick, onClick),
            onPointerDown: (0, import_shared_utils.callAllHandlers)(props2.onPointerDown, onPointerDown),
            onFocus: (0, import_shared_utils.callAllHandlers)(props2.onFocus, openWithDelay),
            onBlur: (0, import_shared_utils.callAllHandlers)(props2.onBlur, closeWithDelay),
            "aria-describedby": isOpen ? tooltipId : void 0
          };
          return triggerProps;
        },
        [
          openWithDelay,
          closeWithDelay,
          onPointerDown,
          isOpen,
          tooltipId,
          onClick,
          referenceRef
        ]
      );
      const getTooltipPositionerProps = (0, import_react.useCallback)(
        (props2 = {}, forwardedRef = null) => getPopperProps(
          {
            ...props2,
            style: {
              ...props2.style,
              [import_popper.popperCSSVars.arrowSize.var]: arrowSize ? `${arrowSize}px` : void 0,
              [import_popper.popperCSSVars.arrowShadowColor.var]: arrowShadowColor
            }
          },
          forwardedRef
        ),
        [getPopperProps, arrowSize, arrowShadowColor]
      );
      const getTooltipProps = (0, import_react.useCallback)(
        (props2 = {}, ref2 = null) => {
          const styles = {
            ...props2.style,
            position: "relative",
            transformOrigin: import_popper.popperCSSVars.transformOrigin.varRef
          };
          return {
            ref: ref2,
            ...htmlProps,
            ...props2,
            id: tooltipId,
            role: "tooltip",
            style: styles
          };
        },
        [htmlProps, tooltipId]
      );
      return {
        isOpen,
        show: openWithDelay,
        hide: closeWithDelay,
        getTriggerProps,
        getTooltipProps,
        getTooltipPositionerProps,
        getArrowProps,
        getArrowInnerProps
      };
    }
    var closeEventName = "chakra-ui:close-tooltip";
    function useCloseEvent(ref, close) {
      (0, import_react.useEffect)(() => {
        const doc = getDoc(ref);
        doc.addEventListener(closeEventName, close);
        return () => doc.removeEventListener(closeEventName, close);
      }, [close, ref]);
      return () => {
        const doc = getDoc(ref);
        const win = getWin(ref);
        doc.dispatchEvent(new win.CustomEvent(closeEventName));
      };
    }
    var import_jsx_runtime = require_jsx_runtime();
    var MotionDiv = (0, import_system.chakra)(import_framer_motion.motion.div);
    var Tooltip = (0, import_system.forwardRef)((props, ref) => {
      var _a, _b;
      const styles = (0, import_system.useStyleConfig)("Tooltip", props);
      const ownProps = (0, import_system.omitThemingProps)(props);
      const theme = (0, import_system.useTheme)();
      const {
        children,
        label,
        shouldWrapChildren,
        "aria-label": ariaLabel,
        hasArrow,
        bg,
        portalProps,
        background,
        backgroundColor,
        bgColor,
        motionProps,
        ...rest
      } = ownProps;
      const userDefinedBg = (_b = (_a = background != null ? background : backgroundColor) != null ? _a : bg) != null ? _b : bgColor;
      if (userDefinedBg) {
        styles.bg = userDefinedBg;
        const bgVar = (0, import_system.getCSSVar)(theme, "colors", userDefinedBg);
        styles[import_popper2.popperCSSVars.arrowBg.var] = bgVar;
      }
      const tooltip = useTooltip({ ...rest, direction: theme.direction });
      const shouldWrap = typeof children === "string" || shouldWrapChildren;
      let trigger;
      if (shouldWrap) {
        trigger = (0, import_jsx_runtime.jsx)(
          import_system.chakra.span,
          {
            display: "inline-block",
            tabIndex: 0,
            ...tooltip.getTriggerProps(),
            children
          }
        );
      } else {
        const child = import_react2.Children.only(children);
        trigger = (0, import_react2.cloneElement)(
          child,
          tooltip.getTriggerProps(child.props, child.ref)
        );
      }
      const hasAriaLabel = !!ariaLabel;
      const _tooltipProps = tooltip.getTooltipProps({}, ref);
      const tooltipProps = hasAriaLabel ? omit(_tooltipProps, ["role", "id"]) : _tooltipProps;
      const srOnlyProps = pick(_tooltipProps, ["role", "id"]);
      if (!label) {
        return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
      }
      return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
        trigger,
        (0, import_jsx_runtime.jsx)(import_framer_motion.AnimatePresence, { children: tooltip.isOpen && (0, import_jsx_runtime.jsx)(import_portal.Portal, { ...portalProps, children: (0, import_jsx_runtime.jsx)(
          import_system.chakra.div,
          {
            ...tooltip.getTooltipPositionerProps(),
            __css: {
              zIndex: styles.zIndex,
              pointerEvents: "none"
            },
            children: (0, import_jsx_runtime.jsxs)(
              MotionDiv,
              {
                variants: scale,
                initial: "exit",
                animate: "enter",
                exit: "exit",
                ...motionProps,
                ...tooltipProps,
                __css: styles,
                children: [
                  label,
                  hasAriaLabel && (0, import_jsx_runtime.jsx)(import_system.chakra.span, { srOnly: true, ...srOnlyProps, children: ariaLabel }),
                  hasArrow && (0, import_jsx_runtime.jsx)(
                    import_system.chakra.div,
                    {
                      "data-popper-arrow": true,
                      className: "chakra-tooltip__arrow-wrapper",
                      children: (0, import_jsx_runtime.jsx)(
                        import_system.chakra.div,
                        {
                          "data-popper-arrow-inner": true,
                          className: "chakra-tooltip__arrow",
                          __css: { bg: styles.bg }
                        }
                      )
                    }
                  )
                ]
              }
            )
          }
        ) }) })
      ] });
    });
    Tooltip.displayName = "Tooltip";
  }
});

// ../../node_modules/@chakra-ui/provider/dist/index.js
var require_dist85 = __commonJS({
  "../../node_modules/@chakra-ui/provider/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      ChakraProvider: () => ChakraProvider
    });
    module.exports = __toCommonJS2(src_exports);
    var import_css_reset = require_dist38();
    var import_portal = require_dist58();
    var import_system = require_dist12();
    var import_react_env = require_dist48();
    var import_jsx_runtime = require_jsx_runtime();
    var ChakraProvider = (props) => {
      const {
        children,
        colorModeManager,
        portalZIndex,
        resetScope,
        resetCSS = true,
        theme = {},
        environment,
        cssVarsRoot,
        disableEnvironment
      } = props;
      const _children = (0, import_jsx_runtime.jsx)(
        import_react_env.EnvironmentProvider,
        {
          environment,
          disabled: disableEnvironment,
          children
        }
      );
      return (0, import_jsx_runtime.jsx)(import_system.ThemeProvider, { theme, cssVarsRoot, children: (0, import_jsx_runtime.jsxs)(
        import_system.ColorModeProvider,
        {
          colorModeManager,
          options: theme.config,
          children: [
            resetCSS ? (0, import_jsx_runtime.jsx)(import_css_reset.CSSReset, { scope: resetScope }) : (0, import_jsx_runtime.jsx)(import_css_reset.CSSPolyfill, {}),
            (0, import_jsx_runtime.jsx)(import_system.GlobalStyle, {}),
            portalZIndex ? (0, import_jsx_runtime.jsx)(import_portal.PortalManager, { zIndex: portalZIndex, children: _children }) : _children
          ]
        }
      ) });
    };
  }
});

// ../../node_modules/@chakra-ui/react/dist/index.js
var require_dist86 = __commonJS({
  "../../node_modules/@chakra-ui/react/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      ChakraBaseProvider: () => ChakraBaseProvider,
      ChakraProvider: () => ChakraProvider
    });
    module.exports = __toCommonJS2(src_exports);
    __reExport(src_exports, require_dist20(), module.exports);
    __reExport(src_exports, require_dist22(), module.exports);
    __reExport(src_exports, require_dist25(), module.exports);
    __reExport(src_exports, require_dist26(), module.exports);
    __reExport(src_exports, require_dist27(), module.exports);
    __reExport(src_exports, require_dist28(), module.exports);
    __reExport(src_exports, require_dist33(), module.exports);
    __reExport(src_exports, require_dist34(), module.exports);
    __reExport(src_exports, require_dist35(), module.exports);
    __reExport(src_exports, require_dist37(), module.exports);
    __reExport(src_exports, require_dist38(), module.exports);
    __reExport(src_exports, require_dist41(), module.exports);
    __reExport(src_exports, require_dist43(), module.exports);
    __reExport(src_exports, require_dist29(), module.exports);
    __reExport(src_exports, require_dist44(), module.exports);
    __reExport(src_exports, require_dist18(), module.exports);
    __reExport(src_exports, require_dist23(), module.exports);
    __reExport(src_exports, require_dist45(), module.exports);
    __reExport(src_exports, require_dist47(), module.exports);
    __reExport(src_exports, require_dist49(), module.exports);
    __reExport(src_exports, require_dist57(), module.exports);
    __reExport(src_exports, require_dist59(), module.exports);
    __reExport(src_exports, require_dist61(), module.exports);
    __reExport(src_exports, require_dist62(), module.exports);
    __reExport(src_exports, require_dist63(), module.exports);
    __reExport(src_exports, require_dist52(), module.exports);
    __reExport(src_exports, require_dist58(), module.exports);
    __reExport(src_exports, require_dist64(), module.exports);
    __reExport(src_exports, require_dist65(), module.exports);
    __reExport(src_exports, require_dist48(), module.exports);
    __reExport(src_exports, require_dist66(), module.exports);
    __reExport(src_exports, require_dist68(), module.exports);
    __reExport(src_exports, require_dist74(), module.exports);
    __reExport(src_exports, require_dist21(), module.exports);
    __reExport(src_exports, require_dist75(), module.exports);
    __reExport(src_exports, require_dist76(), module.exports);
    __reExport(src_exports, require_dist77(), module.exports);
    __reExport(src_exports, require_dist12(), module.exports);
    __reExport(src_exports, require_dist78(), module.exports);
    __reExport(src_exports, require_dist79(), module.exports);
    __reExport(src_exports, require_dist80(), module.exports);
    __reExport(src_exports, require_dist81(), module.exports);
    __reExport(src_exports, require_dist10(), module.exports);
    __reExport(src_exports, require_dist11(), module.exports);
    __reExport(src_exports, require_dist83(), module.exports);
    __reExport(src_exports, require_dist84(), module.exports);
    __reExport(src_exports, require_dist19(), module.exports);
    __reExport(src_exports, require_dist31(), module.exports);
    var import_provider = require_dist85();
    var import_theme = require_dist10();
    var import_toast = require_dist83();
    var import_jsx_runtime = require_jsx_runtime();
    var createChakraProvider = (providerTheme) => {
      return function ChakraProvider2({
        children,
        theme = providerTheme,
        toastOptions,
        ...restProps
      }) {
        return (0, import_jsx_runtime.jsxs)(import_provider.ChakraProvider, { theme, ...restProps, children: [
          (0, import_jsx_runtime.jsx)(import_toast.ToastOptionProvider, { value: toastOptions == null ? void 0 : toastOptions.defaultOptions, children }),
          (0, import_jsx_runtime.jsx)(import_toast.ToastProvider, { ...toastOptions })
        ] });
      };
    };
    var ChakraProvider = createChakraProvider(import_theme.theme);
    var ChakraBaseProvider = createChakraProvider(import_theme.baseTheme);
  }
});

// ../../node_modules/@chakra-ui/storybook-addon/dist/preset/decorators.js
var require_decorators = __commonJS({
  "../../node_modules/@chakra-ui/storybook-addon/dist/preset/decorators.js"(exports, module) {
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var decorators_exports = {};
    __export(decorators_exports, {
      decorators: () => decorators
    });
    module.exports = __toCommonJS2(decorators_exports);
    var import_react4 = require_react();
    var import_react5 = require_dist86();
    var import_react = require_react();
    var import_react2 = require_dist86();
    var import_addons = (init_public_api(), __toCommonJS(public_api_exports));
    var ADDON_ID = "@chakra-ui/storybook-addon";
    var COLOR_MODE_TOOL_ID = `${ADDON_ID}/color-mode-tool`;
    var DIRECTION_TOOL_ID = `${ADDON_ID}/direction-tool`;
    var EVENTS = {
      TOGGLE_COLOR_MODE: `${ADDON_ID}/toggleColorMode`,
      TOGGLE_DIRECTION: `${ADDON_ID}/toggleDirection`
    };
    function ColorModeSync() {
      const { setColorMode } = (0, import_react2.useColorMode)();
      (0, import_react.useEffect)(() => {
        const channel = import_addons.addons.getChannel();
        const colorModeToolCallback = (value) => setColorMode(value);
        channel.on(EVENTS.TOGGLE_COLOR_MODE, colorModeToolCallback);
        return () => {
          channel.removeListener(EVENTS.TOGGLE_COLOR_MODE, colorModeToolCallback);
        };
      }, [setColorMode]);
      return null;
    }
    var import_react3 = require_react();
    var import_addons2 = (init_public_api(), __toCommonJS(public_api_exports));
    var useDirection = (initialDirection = "ltr") => {
      const [direction, setDirection] = (0, import_react3.useState)(initialDirection.toLowerCase());
      (0, import_react3.useEffect)(() => {
        document.documentElement.dir = direction;
      }, [direction]);
      (0, import_react3.useEffect)(() => {
        const channel = import_addons2.addons.getChannel();
        const callback = (value) => setDirection(value);
        channel.on(EVENTS.TOGGLE_DIRECTION, callback);
        return () => {
          channel.removeListener(EVENTS.TOGGLE_DIRECTION, callback);
        };
      }, [setDirection]);
      return direction;
    };
    var import_jsx_runtime = require_jsx_runtime();
    function ChakraProviderDecorator(Story, context) {
      const {
        parameters: { chakra: chakraParams },
        globals: { [DIRECTION_TOOL_ID]: globalDirection }
      } = context;
      const chakraTheme = (chakraParams == null ? void 0 : chakraParams.theme) ? typeof chakraParams.theme === "function" ? chakraParams.theme(context) : chakraParams.theme : import_react5.theme;
      const direction = useDirection(globalDirection || (chakraTheme == null ? void 0 : chakraTheme.direction));
      const themeWithDirectionOverride = (0, import_react4.useMemo)(
        () => (0, import_react5.extendTheme)({ direction }, chakraTheme),
        [chakraTheme, direction]
      );
      return (0, import_jsx_runtime.jsxs)(import_react5.ChakraProvider, { ...chakraParams, theme: themeWithDirectionOverride, children: [
        (0, import_jsx_runtime.jsx)(ColorModeSync, {}),
        (0, import_jsx_runtime.jsx)(Story, { ...context })
      ] });
    }
    var decorators = [ChakraProviderDecorator];
  }
});
export default require_decorators();
//# sourceMappingURL=@chakra-ui_storybook-addon_dist_preset_decorators__js.js.map
